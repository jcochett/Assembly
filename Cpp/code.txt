#include <vector>
#include <map>
#include <deque>
#include <fstream>
#include <string>
#include <cstdint>
#include <iostream>
#include "defs.hpp"
/**
* Using the following functions (defined in defs.hpp):
* 
* std::string get_proc_name(uint32_t pid);
* uint32_t get_pidlist(std::vector<uint32_t>& buf);
*
* 1.) Call get_pidlist, providing a vector as input. It will
* return the number of bytes written in the vector. If the number
* of bytes is equal to the number of BYTES in the vector then there
* is likely more data and the vector should be made bigger.  You have to resizse that so its bigger than zero 
* 
* 2.) Resize the vector to accomodate the remaining PIDs
*
* 3.) Populate the procList map with all process ID/process name combinations,
* calling get_proc_name on each pid to try and retrieve its name. Make sure you
* filter out processes you aren't able to open (the string "Unable to open process. Skipping..."
* will be returned).
*
* 4.) Iterate through the map, printing the consolidated list of all processes retrieved.
*/
std::map<uint32_t, std::string> procList;
std::vector<uint32_t> pids;

void print_procs(const std::map<uint32_t, std::string>& procs)
{
	// Print the map
	for (const auto& n : procs) {
		std::cout << "PID:[" << n.first << "] PROCESSNAME:[" << n.second << "]\n";
	}
}


int main(int argc, char** argv, char** envp)
{
	//std::cout << "You still wake up sometimes, don't you? You wake up in the dark and hear the screaming of the lambdas." << std::endl;
	//std::cout << "I don't get these jokes -- Jeff" << std::endl;

	pids.resize(10);

	while (auto size = get_pidlist(pids))
	{
		if (size >= pids.size())
		{
			pids.resize(pids.size() + 1);
		}
		else
		{
			break;
		}
	}

	//std::cout << pids.size() << std::endl;	

	// Load the map
	for (auto i = pids.begin(); i != pids.end(); ++i)
	{
		std::string s = get_proc_name(*i);
		if (*i == 0) continue;
		if (s == "Unable to open process. Skipping...") continue;
		if (s == "") continue;

		std::pair<uint32_t, std::string> keypair(*i, s);
		procList.insert(keypair);
		//std::cout << *i << ' ' << get_proc_name(*i) << std::endl;
	}

	// Load map different way
	// for (auto x : pids) procList[x] = get_proc_name(x);

	// Print the list
	print_procs(procList);
	
	return 0;
}
#include <Windows.h>
#include <Psapi.h>
#include "defs.hpp"
#include <iostream>

std::string get_proc_name(uint32_t pid)
{
	HANDLE		hProc = NULL;
	HMODULE		hMod = NULL;
	DWORD   	sizeNeeded = 0;

	char buffer[MAX_PATH + 1] = { 0 };
	std::string buf;

	if (NULL == (hProc = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pid))) {
		if (5 == GetLastError())
			return "Unable to open process. Skipping...";

		return "";
	}
	try {
		if (EnumProcessModules(hProc, &hMod, sizeof(hMod), &sizeNeeded)) {
			GetModuleBaseName(hProc, hMod, buffer, sizeof(buffer));
			buf = buffer;
		}
		else {
			//std::cout << " Getting mod name failed!" << std::endl;
		}
	}
	catch (std::runtime_error e) {
		
	}
	CloseHandle(hProc);

	return  buf;
}

uint32_t get_pidlist(std::vector<uint32_t>& buf)
{
	DWORD sizeNeeded = 0;

	if (!EnumProcesses(reinterpret_cast<DWORD*>(buf.data()), buf.capacity()*sizeof(DWORD), &sizeNeeded))
		return 0;

	return sizeNeeded;
}
#include <iostream>
#include <deque>
#include <functional>
#include <utility>

using WorkQueue = std::deque<std::function<int(int)>>;

int processWork(WorkQueue queue, int start)
{
    for (auto fun : queue)
    {
        start = fun(start);
    }
    return start;
}

int add(int a, int b)
{
    return a + b;
}



// This is a functor...
// You can use this like a normal funciton sub(1,2) = -1...
struct sub
{
    int operator()(int a, int b)
    {
        return a - b;
    }
};


int main()
{
    WorkQueue workQueue; //A work queue that stores functions that take an int and return an int.

	auto mul10 = [](int a) { return a * 10; };
	auto add10 = [](int a) { return a + 10; };
	auto add2 = [](int a) { return add(a, 2);};
	
	std::function<int(int, int)> fn = sub();
	
	// Add using bind example
	//workQueue.push_back(std::bind(add, 2, std::placeholders::_1));
	workQueue.push_back(add2); //Use add above to add 2 

	// Add direct lamba example
	//workQueue.push_back([](int a) {return 10 + a; });
    workQueue.push_back(add10); //Use a lambda to add 10

	// Subtration examples local function and bind
	//sub subFun;
	//workQueue.push_back([&subFun](int a) {return subFun(a, 7);});
	//workQueue.push_back(std::bind(sub(), std::placeholders::_1, 7));
	workQueue.push_back([fn](int a) {return fn(a, 7);}); //Use the sub functor to sub 7;

    workQueue.push_back(mul10); //Use a lambda to multiply by 10;

    std::cout << "Processing 100: " << processWork(workQueue, 100) << "\n";

	return 0;
}#include <iostream>
#include <algorithm>
#include <vector>
#include <cstdint>

/*
All comparitors comp(a,b):
 
  * For all a, comp(a,a) == false
  * If comp(a,b) == true, then comp(b, a) == false
  * If comp(a,b) == true and comp(b,c) == true, then comp(a,c) == true
  
  */
// Source: gha.st/comprehensive-cpp-lambda-overview/

//Less typing! :)
using uint = unsigned int; // == typedef unsigned int uint;

void printVec(const std::vector<uint>& vec)
{
    bool first = true;
    for (auto item : vec)
    {
        first ? std::cout << item : std::cout << ", " << item;
        first = false;
    }
    std::cout << "\n";
}


int main()
{
    const std::vector<uint> dataset = { 10,2,2503,3,5,64,4095,9086,12402,0xDEADBEEF,0765432,9 };

    std::cout << "Increasing order: \n";
    auto increasingOrder(dataset); //a copy
	std::sort(increasingOrder.begin(), increasingOrder.end(), [](uint a, uint b) { return a == b ? false : a < b ? true : false; });	/*LAMBDA HERE*/
    printVec(increasingOrder);

    std::cout << "Decreasing order: \n";
    auto decreasingOrder(dataset);
	std::sort(decreasingOrder.begin(), decreasingOrder.end(), [](uint a, uint b) { return a == b ? false : a > b ? true : false;});	/*LAMBDA HERE*/
    printVec(decreasingOrder);

    std::cout << "Odd First: \n";
    auto oddFirst(dataset);
	auto oddOverEven = [](uint a, uint b) { return a == b ? false : (a % 2) > (b % 2) ? true : false; };			/*LAMBDA HERE*/
    std::sort(oddFirst.begin(), oddFirst.end(), oddOverEven);
    printVec(oddFirst);
    
    std::cout << "Even First: \n";
    auto evenFirst(dataset);
	auto evenOverOdd = [](uint a, uint b) { return a == b ? false : (a % 2) < (b % 2) ? true : false; };		/*LAMBDA HERE*/
    std::sort(evenFirst.begin(), evenFirst.end(), evenOverOdd);
    printVec(evenFirst);
    
    std::cout << "Increasing Odd First: \n";
    auto increasingOddFirst(dataset);
	auto oddOverEvenIncrease = [oddOverEven](uint a, uint b) {if (a % 2 != b % 2) return a % 2 > b % 2; else return a < b;};	/*LAMBDA HERE*/
    std::sort(increasingOddFirst.begin(), increasingOddFirst.end(), oddOverEvenIncrease);
    printVec(increasingOddFirst);
   
    std::cout << "Increasing Even First: \n";
    auto increasingEvenFirst(dataset);
	auto evenOverOddIncrease = [](uint a, uint b) {if (a % 2 != b % 2) return b % 2 > a % 2; else return a < b;};				/*LAMBDA HERE*/
    std::sort(increasingEvenFirst.begin(), increasingEvenFirst.end(), evenOverOddIncrease);
    printVec(increasingEvenFirst);

	
    return 0;
}#include "Date.h"


///////// DAY
bool Day::verifyDay(int d)
{
    return d > 0 && d <= 31;
}

Day::Day(int d)
{
    day_ = verifyDay(d) ? d : 1;
}

int Day::getDay() const
{
    return day_;
}

void Day::setDay(int d)
{
    day_ = verifyDay(d) ? d : 1;
}

std::ostream& operator<<(std::ostream& os, const Day& day)
{
    os << day.getDay();
    return os;
}


//////////////////// Month
const std::map<int, std::string> Month::monthNames_ = { 
    {1, "Jan"},
    {2, "Feb"},
    {3, "March"},
    {4, "April"},
    {5, "May"},
    {6, "June"},
    {7, "July"},
    {8, "August"},
    {9, "September"},
    {10, "October"},
    {11, "November"},
    {12, "December"} };

const std::map<int, int> Month::monthDays_ = { 
    {1, 31},
    {2, 28},
    {3, 31},
    {4, 30},
    {5, 31},
    {6, 30},
    {7, 31},
    {8, 31},
    {9, 30},
    {10, 31},
    {11, 30},
    {12, 31} };


bool Month::verifyMonth(int m)
{
    return m > 0 && m <= 12;
}

Month::Month(int m) { month_ = verifyMonth(m) ? m : 1; }

int Month::getMonth() const
{
    return month_; 
}

std::string Month::str() const
{
    return monthNames_.at(month_);
}

int Month::daysInMonth() const
{
    return monthDays_.at(month_);
}

void Month::setMonth(int m)
{
    month_ = verifyMonth(m) ? m : month_;
}

std::ostream& operator<<(std::ostream& os, const Month& month)
{
    os << month.str();
    return os;
}

std::ostream & operator<<(std::ostream & os, const Date & year)
{
    
	os << year.getMonth() << "-" << year.getDay() << "-" << year.getYear();

    return os;
}

int operator-(const Date & date1, const Date & date2)  
{
	const std::map<int, int> mm = { { 1, 31 },{ 2, 28 },{ 3, 31 },{ 4, 30 },{ 5, 31 },{ 6, 30 },
									{ 7, 31 },{ 8, 31 },{ 9, 30 },{10, 31 },{11, 30 },{12, 31 } };
	int m1 = date1.getMonth(), m2 = date2.getMonth();
	int y1 = date1.getYear(),  y2 = date2.getYear();
	int julian1 = 0, julian2 = 0;
		
	// Compute julian dates
	for (int i = 1; i < m1; i++)
		julian1 += mm.at(i);
	julian1 += date1.getDay();

	// Computer julian date
	for (int i = 1; i < m2; i++)
		julian2 += mm.at(i);
	julian2 += date2.getDay();

	// Computer the number of total years
	int age = (y1 - y2);

	// Compute leap year
	int leap = age / 4;
	if (!(y1 % 4) && (m1 > 1)) leap++; 
	if (!(y2 % 4) && (m2 > 1)) leap++;

	// Add it all together
   	age = age * 365 + (julian1 - julian2) + leap;

    return age;
}

//Year
Year::Year(int y) :year_(y) {}

int Year::getYear() const
{  
	return year_;
}

void Year::setYear(int y)
{
	year_ = y;
}


/////////////////// Date
//IMPLEMENT DATE!

Date::Date(const Day & d, const Month & m, const Year & y)
{
	setDay(d);
	setMonth(m);
	setYear(y);
}

int Date::getDay() const
{
    return d_.getDay();
}

int Date::getMonth() const
{
    return m_.getMonth();
}

int Date::getYear() const
{
    return y_.getYear();
}

void Date::setDay(const Day & d)
{
	d_.setDay(d.getDay()); 
}

void Date::setMonth(const Month & m)
{
	m_.setMonth(m.getMonth());
}

void Date::setYear(const Year & y)
{
	y_.setYear(y.getYear());
}


#include "Date.h"
#include <iostream> 

int main()
{
    Date date1(Day{ 25 }, Month{ 2 }, Year{ 1984 });
    Date date2(Day{ 7 }, Month{ 6 }, Year{ 2016 });

    std::cout << "Jeff was born on " << date1 << ".\n";
    std::cout << "Jeff is " << date2 - date1 << " days old!\n";

	Date date3(Day{ 22 }, Month{ 7 }, Year{ 2008 });

	std::cout << "Ethan was born on " << date3 << ".\n";
	std::cout << "Ethan is " << date2 - date3 << " days old!\n";

	Date date4(Day{ 8 }, Month{ 1 }, Year{ 1935 });
	std::cout << "Elvis was born on " << date4 << ".\n";
	std::cout << "Elvis is " << date2 - date4 << " days old! If he was still alive.\n";

	Date date5(Day{ 25 }, Month{ 12 }, Year{ 0000 });
	std::cout << "Jesus was born on " << date5 << ".\n";
	std::cout << "Jesus is " << date2 - date5 << " days old!\n";

        	return 0;
}#include <iostream>
#include <deque>
#include <functional>
#include <utility>
/********************************************************************
Your Assignment 

In the main function:
* Convert all std::bind to use lambdas
* Convert all lambdas to use std::bind
**********************************************************************/

using WorkQueue = std::deque<std::function<int(int)>>;

int processWork(WorkQueue queue, int start)
{
    for (auto fun : queue)
    {
        start = fun(start);
    }
    return start;
}

int add(int a, int b)
{
    return a + b;
}

int abs(int a)
{
    return a < 0 ? -a : a;
}

int sub(int a, int b)
{
    return a - b;
}

int power(int a, int b)
{
    int tmp = a;
    for (int i = 0; i < b; i++)
        tmp *= a;
    return tmp;
}

int divide(int a, int b)
{
    return a / b;
}

int mod(int a, int b)
{
    return a % b;
}

int multiply(int a, int b)
{
    return a * b;
}

int main()
{
    WorkQueue workQueue; //A work queue that stores functions that take an int and return an int.

 //   workQueue.push_back(std::bind(add, 2, std::placeholders::_1)); //Use add above to add 2 
 //   workQueue.push_back(std::bind(divide, 1000, std::placeholders::_1)); //divided 1000 by x
 //   workQueue.push_back(std::bind(power, 2, std::placeholders::_1)); //2 ^x
 //   workQueue.push_back(std::bind(mod, std::placeholders::_1, 0xF));
 //   workQueue.push_back([](int a) {return multiply(a, 100); });
 //   workQueue.push_back([](int a) {return divide(0xDEAD, a); });


	workQueue.push_back([](int a) {return add(a, 2);}); //Use add above to add 2
	workQueue.push_back([](int a) {return divide(1000, a);});
	workQueue.push_back([](int a) {return power(2, a);});
	workQueue.push_back([](int a) {return mod(a, 0xF);});
	workQueue.push_back(std::bind(multiply, 100, std::placeholders::_1));
	workQueue.push_back(std::bind(divide, 0xDEAD, std::placeholders::_1));
	

	std::cout << "Processing 100  (should print 142): " << processWork(workQueue, 100) << "\n"; //should print 142
	std::cout << "Processing 1000 (should print 285): " << processWork(workQueue, 1000) << "\n"; //should print 285
    return 0;
}













#include "Inheritance.hpp"


/**
*  Objective: 
*   * You must implement the IFileOps interface, and ensure the following:
*     - It can open a file for reading, or writing, and will return true or false to indicate the operation's success
*     - writeFile should return true or false to indicate success, and write the contents of the provided string to
*       the current file opened (or false, if no file is currently open for writing).
*     - readFile should return either the contents of the file in a string, or an empty string (""), if the operation
*       fails.
*     - If a file is opened for reading, it should not be writable. Likewise, a file open for writing should fail read
*       requests.
*	* Finally, the function below should be implemented to return a shared_ptr containing an instance of your class 
*     that implements all required interfaces.
*/
std::shared_ptr<IFileOps> get_file_ops()
{
	return std::make_shared<IFile>();
}

bool IFile::openFile(const std::string & filename, bool writing)
{
	if (fs_) fs_.close();

	if (writing)
	{
		fs_.open(filename, std::fstream::out);
	}
	else
	{
		fs_.open(filename, std::fstream::in);
	}

	if (!fs_.is_open())
		return false;

	writing_ = writing;

	return true;
}

bool IFile::closeFile()
{
	if (fs_.is_open())
	{
		fs_.close();
		return true;
	}
	
	return false;
}

bool IFile::writeFile(const std::string & contents)
{
	if (!fs_.is_open() || !writing_)
		return false;

	fs_ << contents;

	return true;
}

std::string IFile::readFile()
{
	std::string s;

	if (!fs_.is_open() || writing_)
		return s;

	fs_ >> s;

	return s;
}


#define CATCH_CONFIG_MAIN
#include "catch.hpp"
#include "grader_code.hpp"
#include "Inheritance.hpp"

#define TMP_FNAME	"tmp.txt"
#define TMP_FSIZE	(size_t)1024

TEST_CASE("Inheritance Tests", "[InheritanceTests]") {
	auto fops = get_file_ops();

	SECTION("ReadFile Test") {
		std::string tmp = "";
		REQUIRE(random_file(TMP_FNAME, TMP_FSIZE, tmp));
		REQUIRE(tmp != "");
		REQUIRE(fops->openFile(TMP_FNAME, false));
		REQUIRE(tmp == fops->readFile());
		REQUIRE(false == fops->writeFile(random_string(1024)));
	}

	SECTION("WriteFile Test") {
		REQUIRE(trunc_file(TMP_FNAME));
		auto tmp = random_string(TMP_FSIZE);
		REQUIRE(fops->openFile(TMP_FNAME, true));
		REQUIRE(fops->writeFile(tmp));
		REQUIRE(fops->closeFile());
		auto tmp2 = load_file(TMP_FNAME);
		REQUIRE(tmp2 != "");
		REQUIRE(tmp2 == tmp);
		REQUIRE("" == fops->readFile());
	}

	SECTION("Locked File Test") {
		std::string tmp;
		REQUIRE(random_file(TMP_FNAME, TMP_FSIZE, tmp));
		gLockFile lf(TMP_FNAME);

		SECTION("Write Failure") {
			REQUIRE(false == fops->openFile(TMP_FNAME, true));
			REQUIRE(false == fops->writeFile("asdfjlaksdjflkasdjfklajsldkfjasdlkjfklasdj"));
		}
		SECTION("Read Failure") {
			REQUIRE(false == fops->openFile(TMP_FNAME, false));
			REQUIRE("" == fops->readFile());
		}
	}
}
#include "board.h"


void Board::printBoard()
{	
	for (int i = 1; i <= 10; ++i) std::cout << bmTop_.at(i);  // Top Row
	
	std::cout << midSection_;

	for (int i = 1; i <= 10; ++i) std::cout << bmMid_.at(i);  // Middle Row
	
	std::cout << midSection_;
	
	for (int i = 1; i <= 10; ++i) std::cout << bmBot_.at(i);  // Bottom Row
	
	std::cout << std::endl;

	return;
}

bool Board::move(Player p, int row, int col)
{
	char xo = p == Player::O ? 'O' : 'X';

	switch (row)
	{
	case 1:
		if (col == 1 && A1 == ' ')		A1 = xo; 
		else if (col == 2 && A2 == ' ') A2 = xo;
		else if (col == 3 && A3 == ' ') A3 = xo; 
		else return false;
		break;
	case 2:
		if (col == 1 && B1 == ' ')		B1 = xo;
		else if (col == 2 && B2 == ' ') B2 = xo;
		else if (col == 3 && B3 == ' ') B3 = xo;
		else return false;
		break;
	case 3:
		if (col == 1 && C1 == ' ')		C1 = xo;
		else if (col == 2 && C2 == ' ') C2 = xo;
		else if (col == 3 && C3 == ' ') C3 = xo;
		else return false;
		break;
	default:
		return false;
	}
	
	numberOfPlays_++;

	return true;
}

//	Board Layout
//	Top A1 A2 A3
//	Mid B1 B2 B3
//	Bot	C1 C2 C3
bool Board::hasWinner() const
{

	if (A1 != ' ' && A1 == A2 && A1 == A3) { winner_ = A1; return true; } // row 1
	if (B1 != ' ' && B1 == B2 && B1 == B3) { winner_ = B1; return true; } // row 2
	if (C1 != ' ' && C1 == C2 && C1 == C3) { winner_ = C1; return true; } // row 3

	if (A1 != ' ' && A1 == B1 && A1 == C1) { winner_ = A1; return true; } // col 1
	if (A2 != ' ' && A2 == B2 && A2 == C2) { winner_ = A2; return true; } // col 2
	if (A3 != ' ' && A3 == B3 && A3 == B3) { winner_ = A3; return true; } // col 3

	if (A1 != ' ' && A1 == B2 && A1 == C3) { winner_ = A1; return true; } // dag 1
	if (A3 != ' ' && A3 == B2 && A3 == C1) { winner_ = A3; return true; } // dag 2

	return false;
}

iBoard::Player Board::winner() const
{
	Player xplayer = winner_ == 'X' ? Player::X : Player::O;
	
	if (draw())
		std::cout << "\nThe game is a draw.\n";
	else
		std::cout << "\nWinner is: " << winner_ << "\n";

	return xplayer;
}

bool Board::draw() const
{
	if (numberOfPlays_ >= 9 && !hasWinner())
		return true;

	return false;
}
#include "iBoard.h"
#include "board.h"
#include <memory>
#include <iostream>



int main()
{
	std::unique_ptr<iBoard> board = std::make_unique<Board>();
    iBoard::Player player = iBoard::Player::X;

    while (!board->draw() && !board->hasWinner())
    {
        std::cout << "Player " << (player == iBoard::Player::X ? 'X' : 'O') << "'s turn\n";
        bool validMove = false;
        while (!validMove)
        {
            board->printBoard();
            int row{ -1 }, col{ -1 };
            std::cout << "Enter a row: ";
            std::cin >> row;
            std::cout << "Enter a col: ";
            std::cin >> col;
            validMove = board->move(player, row, col);
        }

        player = player == iBoard::Player::X ? iBoard::Player::O : iBoard::Player::X;

    }

	std::cout << "\n\n------------ GAME OVER ------------\n\n";
	board->printBoard();
	board->winner();
	
	return 0;
}
ï»¿#include "BigNum.h"

//Implement BigNum

BigNum::BigNum(uint64_t num):BigNum(std::to_string(num))
{

}

BigNum::BigNum(const std::string aBigNum)
{
	std::string s = aBigNum;
	
	while(!s.empty())
	{
		std::string t;
		t.push_back(s.back());
		nums_.push_back(std::stoi(t));
		s.pop_back();
	}
}

std::string BigNum::toString(uint64_t n) const
{
	std::string s = std::to_string(n);
	
	return s;
}

BigNum BigNum::operator+(BigNum b) const
{
	BigNum tmp(*this);
	tmp += b;
	return tmp;
}

BigNum BigNum::operator+=(BigNum b)
{
	short carry = 0, tmp = 0;
	auto y = (*this).nums_.begin();
	
	for (auto x = b.nums_.begin(); x != b.nums_.end(); ++x)
	{
		tmp = *y + *x + carry;
		if (tmp >= 10)
		{
			*y = tmp % 10;
			carry = 1;
		}
		else
		{
			*y = tmp;
			carry = 0;
		}
		y++;
	}

	// Last carry over
	if (carry)
	{
		(*this).nums_.push_back(carry);
	}

	return *this;
}

BigNum BigNum::operator-(BigNum b) const
{
	BigNum tmp(*this);
	tmp -= b;
	return tmp;
}

BigNum BigNum::operator-=(BigNum b)
{  
	// Should check for greater since only implementing positive numbers
	BigNum zero(0);
	if (*this <= b)
	{
		*this = 0;
		return *this;
	}
	

	short borrow = 0, tmp = 0;
	auto y = (*this).nums_.begin();

	for (auto x = b.nums_.begin(); x != b.nums_.end(); ++x)
	{
		tmp = *y - *x - borrow;
		if (tmp < 0)
		{
			tmp += 10;
			borrow = 1;
		}
		else
		{
			borrow = 0;
		}

  		*y = tmp;
		y++;
	}

	while (borrow && y != (*this).nums_.end())
	{
		tmp = *y - borrow;
		if (tmp < 0)
		{
			tmp += 10;
			borrow = 1;
		}
		else
		{
			borrow = 0;
		}

		*y = tmp;
		y++;
	}

	// Eliminate leading zeros (man this is ugly)
	auto z = (*this).nums_.end();
	int count = 0;
	z--;
	while (*z == 0)
	{
		count++;
		z--;
	}
	for (int i = 0; i < count; i++)
	{
		(*this).nums_.pop_back();
	}
	
	return  *this;
}

bool BigNum::operator==(BigNum b) const
{
	return !(*this != b);
}

bool BigNum::operator!=(BigNum b) const
{
	if ((*this).nums_.size() != b.nums_.size())
		return true;
	
	auto y = (*this).nums_.begin();
	for (auto x = b.nums_.begin(); x != b.nums_.end(); ++x)
	{
		if (*y != *x) return true;
		y++;
	}

	return false;
}

bool BigNum::operator>(BigNum b) const
{
	if ((*this).nums_.size() < b.nums_.size())	return false;
	if ((*this).nums_.size() > b.nums_.size())	return true;

	auto y = (*this).nums_.rbegin();
	for (auto x = b.nums_.rbegin(); x != b.nums_.rend(); ++x)
	{
		if (*y > *x) return true;
		if (*y < *x) return false;
		y++;
	}

	return false;
}

bool BigNum::operator<(BigNum b) const
{
	if ((*this).nums_.size() < b.nums_.size())	return true;
	if ((*this).nums_.size() > b.nums_.size())	return false;

	auto y = (*this).nums_.rbegin();
	for (auto x = b.nums_.rbegin(); x != b.nums_.rend(); ++x)
	{
		if (*y < *x) return true;
		if (*y > *x) return false;
		y++;
	}

	return false;
}

bool BigNum::operator<=(BigNum b) const
{
	if ((*this) < b || (*this) == b) return true;
	return false;
}

bool BigNum::operator>=(BigNum b) const
{
	if ((*this) > b || (*this) == b) return true;
	return false;
}

BigNum BigNum::operator*(BigNum b) const
{
	BigNum tmp(*this);
	tmp *= b;
	return tmp;
}

BigNum BigNum::operator*=(BigNum b)
{
	uint64_t m = 1;
	BigNum borg = *this;

	// Zero not implemented
	BigNum z(0);
	if (b == z) return *this;

	for (auto x = b.nums_.begin(); x != b.nums_.end(); ++x)
	{
		for (uint64_t i = 1; i < (*x * m); i++)
			*this += borg;
		m *= 10;
	}

	return *this;
}

BigNum BigNum::operator/(BigNum b) const
{
	BigNum tmp(*this);
	tmp /= b;
	return tmp;
}

BigNum BigNum::operator/=(BigNum b)
{
	// Zero not implemented
 	BigNum zero(0);
	BigNum one(1);

	if (b == zero || b == one) return *this;

	int i = 0;  // Divider

	while (*this >= b)
	{
		*this -= b;
   		i++;
	}
	BigNum tmp(i);
	*this = tmp;

	return *this;
}

BigNum BigNum::operator%(BigNum b) const
{
	BigNum tmp(*this);
	tmp %= b;
	return tmp;
}

BigNum BigNum::operator%=(BigNum b)
{
	BigNum zero(0);
	BigNum one(1);

	if (b == zero) return zero;

	while (*this >= b) *this -= b;

	return *this;
}

std::ostream & operator<<(std::ostream & os, const BigNum & num)
{
	for (auto it = num.nums_.rbegin(); it != num.nums_.rend(); ++it)
	{
		os << *it;
	}

	return os;
}#include "BigNum.h"
#include <Windows.h>

int main()
{
	BigNum bm1("1000000000000000000000000000000000000000000000000000000000000000000009");	// stored as 87654321
	BigNum bm2("1111111111111111111111111111111111111111111111111111111111111111111111");	// stored as 21111111
	BigNum tmp(0);
							//			109765432 
	
	std::cout << "1st Big Number: "; std::cout << bm1 << std::endl;
	std::cout << "2nd Big Number: "; std::cout << bm2 << std::endl << std::endl;
	

	/**********************************************************
	// Implement
	***************************************************************/

	//operator+
	std::cout << "Addition ------------------------- " << std::endl;
	tmp =  bm1 + bm2;
	std::cout << tmp; std::cout << " should be: 103456790" << std::endl;
	//operator+=
	std::cout << "Plus Equal += ------------------------- " << std::endl;
	tmp = bm1; tmp += bm2;
	std::cout << tmp; std::cout << " should be: 103456790" << std::endl;
	//operator-
	std::cout << "Subtraction - ------------------------- " << std::endl;
	BigNum s0(0), s1(1000), s2(999), s3(50), s4(25), s5(2), s6(1);

	s0 = s5 - s5;
	std::cout << "Subtract " << s5 << " - " << s5 << " = "; std::cout << s0; std::cout << std::endl;
	s0 = s1 - s2;
	std::cout << "Subtract " << s1 << " - " << s2 << " = "; std::cout << s0; std::cout << std::endl;
	s0 = s1 - s3;
	std::cout << "Subtract " << s1 << " - " << s3 << " = "; std::cout << s0; std::cout << std::endl;
	s0 = s1 - s4;
	std::cout << "Subtract " << s1 << " - " << s4 << " = "; std::cout << s0; std::cout << std::endl;
	s0 = s1 - s5;
	std::cout << "Subtract " << s1 << " - " << s5 << " = "; std::cout << s0; std::cout << std::endl;
	s0 = s1 - s6;
	std::cout << "Subtract " << s1 << " - " << s6 << " = "; std::cout << s0; std::cout << std::endl;
	s0 = s2 - s3;
	std::cout << "Subtract " << s2 << " - " << s3 << " = "; std::cout << s0; std::cout << std::endl;
	s0 = s2 - s4;
	std::cout << "Subtract " << s2 << " - " << s4 << " = "; std::cout << s0; std::cout << std::endl;
	s0 = s2 - s5;
	std::cout << "Subtract " << s2 << " - " << s5 << " = "; std::cout << s0; std::cout << std::endl;
	s0 = s2 - s6;
	std::cout << "Subtract " << s2 << " - " << s6 << " = "; std::cout << s0; std::cout << std::endl;
	s0 = s6 - s2;
	std::cout << "Subtract " << s6 << " - " << s2 << " = "; std::cout << s0; std::cout << std::endl;

	//operator-=
	std::cout << "Minus Equal -= ------------------------- " << std::endl;
	tmp = bm1 + bm2;	
	std::cout << "Big Number Test: "; std::cout << tmp; std::cout << " - "; std::cout << bm1; 
	tmp -= bm1;
	std::cout << " = "; std::cout << tmp; std::cout << " Should be: 11111112\n";

	s0 = s5; s0 -= s5;
	std::cout << "Minus Equal " << s0 << " -= " << s5 << " = "; std::cout << s0; std::cout << std::endl;
	s0 = s1; s0 -= s2;
	std::cout << "Minus Equal " << s0 << " -= " << s2 << " = "; std::cout << s0; std::cout << std::endl;
	s0 = s1; s0 -= s3;
	std::cout << "Minus Equal " << s0 << " -= " << s3 << " = "; std::cout << s0; std::cout << std::endl;
	s0 = s1; s0 -= s4;
	std::cout << "Minus Equal " << s0 << " -= " << s4 << " = "; std::cout << s0; std::cout << std::endl;
	s0 = s1; s0 -= s5;
	std::cout << "Minus Equal " << s0 << " -= " << s5 << " = "; std::cout << s0; std::cout << std::endl;
	s0 = s1; s0 -= s6;
	std::cout << "Minus Equal " << s0 << " -= " << s6 << " = "; std::cout << s0; std::cout << std::endl;
	s0 = s2; s0 -= s3;
	std::cout << "Minus Equal " << s0 << " -= " << s3 << " = "; std::cout << s0; std::cout << std::endl;
	s0 = s2; s0 -= s4;
	std::cout << "Minus Equal " << s0 << " -= " << s4 << " = "; std::cout << s0; std::cout << std::endl;
	s0 = s2; s0 -= s5;
	std::cout << "Minus Equal " << s0 << " -= " << s5 << " = "; std::cout << s0; std::cout << std::endl;
	s0 = s2; s0 -= s6;
	std::cout << "Minus Equal " << s0 << " -= " << s6 << " = "; std::cout << s0; std::cout << std::endl;
	s0 = s6; s0 -= s2;
	std::cout << "Minus Equal " << s0 << " -= " << s2 << " = "; std::cout << s0; std::cout << std::endl;

	//operator==
	BigNum e1(12345678), e2(12345678), e3(12345677), e4(12345678999);
	std::cout << "Comparison Values ------------------------- " << std::endl;
	std::cout << "e1: "; std::cout << e1 << "\t";
	std::cout << "e2: "; std::cout << e2 << "\t";
	std::cout << "e3: "; std::cout << e3 << "\t";
	std::cout << "e4: "; std::cout << e4 << "\n";
	std::cout << "Equal ------------------------- " << std::endl;
	std::cout << "e1 == e2 is "; if (e1 == e2) std::cout << "true\n"; else std::cout << "false\n";
	std::cout << "e1 == e3 is "; if (e1 == e3) std::cout << "true\n"; else std::cout << "false\n";
	std::cout << "e1 == e4 is "; if (e1 == e4) std::cout << "true\n"; else std::cout << "false\n";
	//operator!=
	std::cout << "Not Equal ------------------------- " << std::endl;
	std::cout << "e1 != e2 is "; if (e1 != e2) std::cout << "true\n"; else std::cout << "false\n";
	std::cout << "e1 != e3 is "; if (e1 != e3) std::cout << "true\n"; else std::cout << "false\n";
	std::cout << "e1 != e4 is "; if (e1 != e4) std::cout << "true\n"; else std::cout << "false\n";
	//operator>
	std::cout << "Greater Than ------------------------- " << std::endl;
	std::cout << "e1 > e2 is "; if (e1 > e2) std::cout << "true\n"; else std::cout << "false\n";
	std::cout << "e1 > e3 is "; if (e1 > e3) std::cout << "true\n"; else std::cout << "false\n";
	std::cout << "e1 > e4 is "; if (e1 > e4) std::cout << "true\n"; else std::cout << "false\n";
	//operator<
	std::cout << "Less Than ------------------------- " << std::endl;
	std::cout << "e1 < e2 is "; if (e1 < e2) std::cout << "true\n"; else std::cout << "false\n";
	std::cout << "e1 < e3 is "; if (e1 < e3) std::cout << "true\n"; else std::cout << "false\n";
	std::cout << "e1 < e4 is "; if (e1 < e4) std::cout << "true\n"; else std::cout << "false\n";
	//operator<=
	std::cout << "Less Than Equal to ------------------------- " << std::endl;
	std::cout << "e1 <= e2 is "; if (e1 <= e2) std::cout << "true\n"; else std::cout << "false\n";
	std::cout << "e1 <= e3 is "; if (e1 <= e3) std::cout << "true\n"; else std::cout << "false\n";
	std::cout << "e1 <= e4 is "; if (e1 <= e4) std::cout << "true\n"; else std::cout << "false\n";
	//operator>=
	std::cout << "Greater Than Equal to ------------------------- " << std::endl;
	std::cout << "e1 >= e2 is "; if (e1 >= e2) std::cout << "true\n"; else std::cout << "false\n";
	std::cout << "e1 >= e3 is "; if (e1 >= e3) std::cout << "true\n"; else std::cout << "false\n";
	std::cout << "e1 >= e4 is "; if (e1 >= e4) std::cout << "true\n"; else std::cout << "false\n";

	std::cout << "Multiplication Values ------------------------- " << std::endl;
	BigNum m0(0), m1(11111111), m2(1), m3(2), m4(10);
	std::cout << "m1: "; std::cout << m1 << "\t";
	std::cout << "m2: "; std::cout << m2 << "\t";
	std::cout << "m3: "; std::cout << m3 << "\t";
	std::cout << "m4: "; std::cout << m4 << "\n";
	//operator*
	std::cout << "Multiplication ------------------------- " << std::endl;
	m0 = m1 * m2;
	std::cout << "m1 * m2 is "; std::cout << m0; std::cout << std::endl;
	m0 = m1 * m3;
	std::cout << "m1 * m3 is "; std::cout << m0; std::cout << std::endl;
	m0 = m1 * m4;
	std::cout << "m1 * m4 is "; std::cout << m0; std::cout << std::endl;
	//operator*=
	std::cout << "Star Equal *= ------------------------- " << std::endl;
	m0 = m1; m0 *= m2;
	std::cout << "m1 *= m2 is "; std::cout << m0; std::cout << std::endl;
	m0 = m1; m0 *= m3;
	std::cout << "m1 *= m3 is "; std::cout << m0; std::cout << std::endl;
	m0 = m1; m0 *= m4;
	std::cout << "m1 *= m4 is "; std::cout << m0; std::cout << std::endl;
	
	std::cout << "Division Values ------------------------- " << std::endl;
	BigNum d0(0), d1(88888), d2(1), d3(2), d4(5);
	std::cout << "d1: "; std::cout << d1 << "\t";
	std::cout << "d2: "; std::cout << d2 << "\t";
	std::cout << "d3: "; std::cout << d3 << "\t";
	std::cout << "d4: "; std::cout << d4 << "\n";
	//operator/
	std::cout << "Division ------------------------- " << std::endl;
	d0 = d1 / d2;
	std::cout << "d1 / d2: "; std::cout << d0; std::cout << std::endl;
	d0 = d1 / d3;
	std::cout << "d1 / d3: "; std::cout << d0; std::cout << std::endl;
	d0 = d1 / d4;
	std::cout << "d1 / d4: "; std::cout << d0; std::cout << std::endl;
	//operator/=
	std::cout << "Division Equal /= ------------------------- " << std::endl;
	d0 = d1; d0 /= d2;
	std::cout << "d1 /= d2: "; std::cout << d0; std::cout << std::endl;
	d0 = d1; d0 /= d3;
	std::cout << "d1 /= d3: "; std::cout << d0; std::cout << std::endl;
	d0 = d1; d0 /= d4;
	std::cout << "d1 /= d4: "; std::cout << d0; std::cout << std::endl;
	//operator%
	std::cout << "Modulus ------------------------- " << std::endl;
	d0 = d1 % d2;
	std::cout << "d1 % d2: "; std::cout << d0; std::cout << std::endl;
	d0 = d1 % d3;
	std::cout << "d1 % d3: "; std::cout << d0; std::cout << std::endl;
	d0 = d1 % d4;
	std::cout << "d1 % d4: "; std::cout << d0; std::cout << std::endl;
	//operator%=
	std::cout << "Modulus Equal %= ------------------------- " << std::endl;
	d0 = d1; d0 %= d2;
	std::cout << "d1 %= d2: "; std::cout << d0; std::cout << std::endl;
	d0 = d1; d0 %= d3;
	std::cout << "d1 %= d3: "; std::cout << d0; std::cout << std::endl;
	d0 = d1; d0 %= d4;
	std::cout << "d1 %= d4: "; std::cout << d0; std::cout << std::endl;

	//Sleep(18000);
	return 0;
}#include <memory>
#include <iostream>
#include <string>
#include <vector>
#include <map>
#include <cctype>
#include <sstream>
// Source for sstream: www.cplusplus.com/articles/D9j2Nwbp/


class Variant_Type{

public:
    enum class Type {intType, doubleType, stringType };
    using type = void;
    virtual Type getType() = 0;
    virtual int asInt() = 0;
    virtual double asDouble() = 0;
    virtual std::string asString() = 0;
};

using Variant = std::unique_ptr<Variant_Type>;

/**************************************** Write Code Below ************************************************/
class myInt : public Variant_Type 
{
    int x_;
public:
	myInt(int x) { x_ = x; };
	Type getType() { return Type::intType; };
	int asInt() { return x_; };
	double asDouble() { return static_cast<double>(x_); };
	std::string asString() { std::string s = static_cast<std::ostringstream*>(&(std::ostringstream() << x_))->str(); return s; };
};

Variant make_variant(int x) 
{
    return std::make_unique<myInt>(x);
}

class myDouble : public Variant_Type 
{
	double x_;
public:
	myDouble(double x) { x_ = x; };
	Type getType() { return Type::doubleType; };
	int asInt() { return static_cast<int>(x_); };
	double asDouble() { return x_; };
	std::string asString() { std::string s = static_cast<std::ostringstream*>(&(std::ostringstream() << x_))->str(); return s; };

};

Variant make_variant(double x)
{
	return std::make_unique<myDouble>(x);
}

class myString : public Variant_Type 
{
	std::string x_;
public:
	myString(std::string x) { x_ = x; };
	Type getType() { return Type::stringType; };
	int asInt() { return std::stoi(x_); };
	double asDouble() { return std::stod(x_); };
	std::string asString() { return x_; };

};

Variant make_variant(const std::string& x) 
{
	return std::make_unique<myString>(x);
}

/************************************** End Writing Code ****************************************************/
int main()
{
    std::vector<Variant> bunchOStuff;
    bunchOStuff.push_back(make_variant(5));
    bunchOStuff.push_back(make_variant(2.34));
    bunchOStuff.push_back(make_variant("This is a string"));


    for (auto& x : bunchOStuff)
    {
        switch (x->getType())
        {
        case Variant_Type::Type::doubleType:
            std::cout << x->asDouble();
            break;
        case Variant_Type::Type::intType:
            std::cout << x->asInt();
            break;
        case Variant_Type::Type::stringType:
            std::cout << x->asString();
            break;
        }
        std::cout << "\n";
    }

    return 0;

}#include "config.h"
#include "except.h"
#include <sstream>
#include <iostream>
#include <string>
#include "helpers.h"
#include <fstream>

void Config::readConfig() {

	/*!
	* @brief Processes the config file
	*
	*  Should process every line possible. Lines that weren't able to
	*  be processed should be put into a message and thrown in BadConfig
	* @throw BadConfig
	*/
	std::string line;
	auto linenumber = 0;
	while (std::getline(inFile_, line))
	{
		++linenumber;
		try
		{
			processLine(line);		
			//std::cout << line << std::endl;
		}
		catch (BadConfig e) {
			std::cout << "Error on line [" << linenumber << "]:  " << e.what() << std::endl;
			//throw;  // Re-throws the same exception
		}
	}
}

void Config::processLine(const std::string& line) {
    if (line.size() == 0 || line.front() == '#') return;
    auto pos = line.find(':');
    if (pos == std::string::npos)
        throw BadConfig("Config Not Conforming!");
    auto key = trim(line.substr(0, pos));
    auto value = trim(line.substr(pos+1, line.size() - pos));
    settings_[key] = value;
}

Config::Config(const std::string& filename): inFile_(filename) {

	if (!inFile_)
		throw BadFile(filename + " cannot be opened");
}

std::size_t Config::size() const { 
    return settings_.size();
}

const std::string Config::operator[](const std::string& key) const { // TODO
	/*!
    * @brief Const version of the setting getter
    * @throw SettingNotFound if asked for something that isn't there.
    */
	auto exists = settings_.count(key);
	
	if (!exists)
		throw SettingNotFound(key + " key was not found");

	auto value = settings_.at(key);

    return value;
}

std::string Config::operator[](const std::string& key) { // TODO
	/*!
    * @brief Gets a setting from the config.
    * @throw SettingNotFound if asked for something that isn't there.
    */
	auto exists = settings_.count(key);

	if (!exists)
		throw SettingNotFound(key + " key was not found");
	
	auto value = settings_[key];

    return value;
}

Config::iterator Config::begin() {
    return settings_.begin();
}

Config::iterator Config::end() {
    return settings_.end();
}#include "helpers.h"

//Taken from: http://stackoverflow.com/questions/1798112/removing-leading-and-trailing-spaces-from-a-string
std::string trim(const std::string& str,
    const std::string& whitespace)
{
    const auto strBegin = str.find_first_not_of(whitespace);
    if (strBegin == std::string::npos)
        return ""; // no content

    const auto strEnd = str.find_last_not_of(whitespace);
    const auto strRange = strEnd - strBegin + 1;

    return str.substr(strBegin, strRange);
}#include "except.h"
#include "config.h"
#include <iostream>


/*
You should create a config object and read the config. 
Your Config object should continue to process the file even if there 
was error in the configfile (i.e. catch BadConfig)
*BUT* you should let the user know about the error so they can go fix the config file
for next time by throwing an exception with the line numbers of the problems.

In main:
You should instantiate a Config.
You should read the config. 
You should print any bad config lines errors to the user.
Finally, you should print out the setting asked for. 

Bonus that everyone should do:
After you get it working this far, add catch statements after main for the 
actual exceptions being thrown and print out which one is caught. 

For the myConfig.txt file provided you should get the following output:

---------------------------------------------------------------------
C:\Users\...\Instructor Solutions>hierarchical.exe myConfig.txt port
Config Line: 8 Config Not Conforming!

port: 444
-------------------------------------------------------------------------
C:\Users\...Instructor Solutions>hierarchical.exe myConfig.txt fooBar
Config Line: 8 Config Not Conforming!

EXCEPTION!!
fooBar Not Found!
-------------------------------------------------------------------------
C:\Users\Instructor Solutions>hierarchical.exe myConfig.tx fooBar
EXCEPTION!!
myConfig.tx Could not open
*/


int main(int argc, char* argv[]) try {
    if (argc != 3) {
        std::cerr << "Usage: " << argv[0] << " <ConfigFile> <Setting>\n";
        exit(0);
    }
    std::string configFile = argv[1];
    std::string key = argv[2];

	// Call the constructor with the file - catch BadFile
	Config c(configFile);

	// Read the configure find - catches BadConfig but continues to process file
	c.readConfig();	

	// Get a value of the map contain called key.  [] is overloaded to throw SettingNotFound
	auto value = c[key];
	std::cout << "Key[" << key << "] = Value[" << value << "]\n";
	
    return 0;
}

// add more catch states and print our what type of exception it is
catch (BadFile e)
{
	std::cout << "Error BadFile caught.\n";
	std::cout << e.what();
	exit(-1);
}
catch (SettingNotFound e)
{
	std::cout << "Error SettingNotFound caught.\n";
	std::cout << e.what();
	exit(-1);
}
catch (const std::runtime_error& e) {
	//Handle Runtime Error
	std::cout << "Error - runtime error: \n";
	std::cout << e.what();
	exit(-1);
}
catch (const std::exception e) {
    std::cout << "EXCEPTION!!\n";
    std::cout << e.what();
    exit(-1);
}
catch (...) {
	std::cout << "Something Bad Happened and nobody knows what that is!!\n";
	//std::cout << e.what();
	exit(-1);
}
#include "guard.h"
#include <Windows.h>
#include <vector>
#include <cstdint>
#include <string>
#include <stdexcept>
#include <iostream>
/*******************************************************************************************
                 ### INSTRUCTIONS ###
* Build a scopeguard that will take a void() function
* Modify readBin to use scopeguard to call closeHandle to make that code exception safe.
*******************************************************************************************/

//THIS SHOULD NEVER BE GLOBAL IT IS EVIL BUT I NEEDED IT TO BE ABLE TO TEST.
//DO NOT DO THIS IN PRODUCTION CODE!!!
HANDLE g_hFile = INVALID_HANDLE_VALUE;

struct BadFile : std::runtime_error {
    BadFile(const std::string& what) :std::runtime_error(what) {}
};

void processBin(std::vector<uint8_t>& bin)
{
    throw std::runtime_error("BAD");
}

std::vector<uint8_t> readBin(const std::wstring& filename)
{
    std::vector<uint8_t> bin;
    g_hFile = CreateFile(filename.c_str(), GENERIC_READ, FILE_SHARE_READ, nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (g_hFile == INVALID_HANDLE_VALUE) {
        std::cerr << "ERROR: " << GetLastError() << "\n";
        throw BadFile("Can't Open File\n");
    }
	// USE SCOPE GAURD - object that passes a lamba that it can use
	//auto silent = []() { CloseHandle(g_hFile);  g_hFile = INVALID_HANDLE_VALUE;};
	//Guard g(silent);

	// SCOPE GUARD - version 2
	Guard g([]() {CloseHandle(g_hFile);  g_hFile = INVALID_HANDLE_VALUE;});

    bin.resize(GetFileSize(g_hFile, nullptr));
    DWORD bytesRead = 0;
    ReadFile(g_hFile, bin.data(), bin.size(), &bytesRead, nullptr);

    processBin(bin);
    ////////////Protect with scopeGuard//////////////////
    //CloseHandle(g_hFile);
    //g_hFile = INVALID_HANDLE_VALUE;
    /////////////////////////////////////////////////////
    return bin;
}

int main()
{
    try {
        auto file = readBin(L"C:\\Windows\\System32\\calc.exe");
    }
    catch (const BadFile& e) {
        std::cerr << e.what() << "\n";
        return -1;
    }
    catch (...) {
        //don't terminate.
    }

    if (g_hFile == INVALID_HANDLE_VALUE) {
        std::cout << "PASS!\n";
        return 0;
    }

    std::cerr << "FAIL!\n";
    return -1;
}#define CATCH_CONFIG_MAIN
#include "catch.hpp"
#include "max.h"
#include <vector>
#include <deque>
#include <list>
#include <set>

TEST_CASE("Max Test", "[Max Test]") {
    SECTION("Max Vector Ints") {
        std::vector<int> nums{ 1,3,2,4,5,7,6,8,9,10 };
        Max<decltype(nums)> max(nums);
        REQUIRE(max.getMin() == 1);
        REQUIRE(max.getMax() == 10);
        REQUIRE(max.getMean() == 5.5);
        typename decltype(nums) sorted = max.getSorted();
        for(auto i = 0U; i < 10; ++i)
            REQUIRE(sorted[i] == (i + 1));
    }
    SECTION("Max Vector Doubles") {
        std::vector<double> nums{ 1.0,3.0,2.0,4.0,5.0,7.0,6.0,8.0,9.0,10.0 };
        Max<decltype(nums)> max(nums);
        REQUIRE(max.getMin() == 1.0);
        REQUIRE(max.getMax() == 10.0);
        REQUIRE(max.getMean() == 5.5);
        auto sorted = max.getSorted();
        for(auto i = 0U; i < 10; ++i)
            REQUIRE(sorted[i] == (i + 1));
    }
    SECTION("Max Deque Ints") {
        std::deque<int> nums{ 1,3,2,4,5,7,6,8,9,10 };
        Max<decltype(nums)> max(nums);
        REQUIRE(max.getMin() == 1);
        REQUIRE(max.getMax() == 10);
        REQUIRE(max.getMean() == 5.5);
        typename decltype(nums) sorted = max.getSorted();
        for(auto i = 0U; i < 10; ++i)
            REQUIRE(sorted[i] == (i + 1));
    }
    SECTION("Max Set Ints") {
        std::set<int> nums{ 1,3,2,4,5,7,6,8,9,10 };
        Max<decltype(nums)> max(nums);
        REQUIRE(max.getMin() == 1);
        REQUIRE(max.getMax() == 10);
        REQUIRE(max.getMean() == 5.5);
        typename decltype(nums) sorted = max.getSorted();
        //for(auto i = 0U; i < 10; ++i)
        //    REQUIRE(sorted[i] == (i + 1));
    }
    SECTION("Max List Ints") {
        std::list<int> nums{ 1,3,2,4,5,7,6,8,9,10 };
        Max<decltype(nums)> max(nums);
        REQUIRE(max.getMin() == 1);
        REQUIRE(max.getMax() == 10);
        REQUIRE(max.getMean() == 5.5);
        typename decltype(nums) sorted = max.getSorted();
        //for(auto i = 0U; i < 10; ++i)
        //    REQUIRE(sorted[i] == (i + 1));
    }
}
#include <iostream>
#include "unique_ptr.h"
#include <Windows.h>
#include <vector>
#include <deque>
#include <windows.media.playlists.h>
#include <set>
#include "catch.hpp"



TEST_CASE("Unique_ptr Test", "[Unique_ptr Test]") {
	SECTION("Unique_ptr int*") {
		unique_ptr<int> pointer(new int(42));
		REQUIRE(*pointer == 42);
		REQUIRE(std::is_copy_constructible<decltype(pointer)>::value == false);
		REQUIRE(std::is_copy_assignable<decltype(pointer)>::value == false);
	}

}

	//int foo = 7;
	//int poo = 9;
	//int *par = &poo;
	//unique_ptr<int> bar = &foo;
	////auto bar = std::make_unique<int>(5);
	//bar.uniprint();

	//std::cout << foo << std::endl;

	//int loo = *bar;
	//std::cout << "loo is: " << loo << std::endl;

	////bar = par;

	////bar.uniprint();

	//Sleep(2000);
	//return 0;
#define CATCH_CONFIG_MAIN
#include "catch.hpp"
#include "Vector.h"
#include <vector>

TEST_CASE("Vector Test", "[VECTOR TEST]") {

    SECTION("doubles") {
        Vector<double> a;
        a.push_back(1.2);
        a.push_back(2.3);
        a.push_back(3.4);
        a.push_back(4.5);
        std::vector<double> reference{ 1.2,2.3,3.4,4.5 };
        REQUIRE(a[0] == 1.2);
        REQUIRE(a[1] == 2.3);
        REQUIRE(a[2] == 3.4);
        REQUIRE(a[3] == 4.5);
        int i = 0;
        for (auto x : a)
        {
            REQUIRE(x == reference[i]);
            i++;
        }
        REQUIRE(a.size() == reference.size());
    }

    SECTION("ints") {
        Vector<int> a;
        a.push_back(1);
        a.push_back(2);
        a.push_back(3);
        a.push_back(4);
        std::vector<double> reference{ 1,2,3,4 };
        REQUIRE(a[0] == reference[0]);
        REQUIRE(a[1] == reference[1]);
        REQUIRE(a[2] == reference[2]);
        REQUIRE(a[3] == reference[3]);
        int i = 0;
        for (auto x : a)
        {
            REQUIRE(x == reference[i]);
            i++;
        }
        REQUIRE(a.size() == reference.size());
    }

    /*
    SECTION("initializer BONUS!") {
        Vector<int> a{ 1,2,3,4,5,6,7,8,9,10 };
        std::vector<int> r{ 1,2,3,4,5,6,7,8,9,10 };
        auto ri = r.begin();
        for (auto ai = a.begin(); ai != a.end() || ri != r.end(); ++ai, ++ri)
            REQUIRE(*ai == *ri);
        REQUIRE(a.size() == r.size());
    }
    */
}#include "Vector.h"
/*******************************************************
////////////////////////////////////////////////////////

 WARNING WARNING WARNING

 TEMPLATES SHOULD BE WRITEN ENTIRELY IN THE HEADER
 THIS IS HERE FOR REFERENCE
 ////////////////////////////////////////////////////////
 *******************************************************/

/*

Vector::iterator Vector::begin()
{
    return iterator{ this, 0 };
}

Vector::iterator Vector::end()
{
    return iterator{ this, size_ };
}

Vector::size_type Vector::size() const
{
    return size_;
}

void Vector::push_back(int x)
{
    if (capacity_ - size_ == 0)
    {
        grow();
    }
    array_[size_] = x;
    size_++;
}

int Vector::nextCapacity()
{
    if (capacity_ = 0)
        return 10;
    else
        return capacity_ * 2;
}

void Vector::grow()
{
    auto newsize = nextCapacity();
    std::unique_ptr<int[]> newArray = std::make_unique<int[]>(newsize);
    for (auto i = 0U; i < size_; ++i)
        newArray[i] = array_[i];
    array_ = std::move(newArray);
    capacity_ = newsize;
}

Vector::reference Vector::operator[](size_type index)
{
    return array_[index];
}

Vector::iterator& VectorIterator::operator++()
{
    pos_++;
    return *this;
}

Vector::iterator VectorIterator::operator++(int)
{
    auto copy = *this;
    pos_++;
    return copy;
}

Vector::iterator& VectorIterator::operator--()
{
    pos_--;
    return *this;
}

Vector::iterator VectorIterator::operator--(int)
{
    auto copy = *this;
    pos_--;
    return copy;
}

Vector::reference VectorIterator::operator*()
{
    if (nullptr == container_)
        throw std::runtime_error("VectorIntIterator Not Initialized");
    return container_->array_[pos_];
}

bool VectorIterator::operator!=(const Vector::iterator& it)
{
    return it.container_ != container_ || it.pos_ != pos_;
}

bool VectorIterator::operator==(const Vector::iterator& it)
{
    return !(*this != it);
}
*/

// This is a #include... notice there is no .h at the end. 
// The standard doesn't say that the standard library include files have to have 
// the .h. Additionally they don't even have to be on disk. This is really up to
// the implementer. The most common compilers typically do have files on disk with 
// the library names. Your headers will have a .h and will look more like your used
// to if your fimilar with C.
#include <iostream>
#include <string>
#include <fstream>
#include <sstream>

//We can also utilize C headers but should use the standard libraries implementation. 
//The standard library will overload functions so that they are more useful for template 
//programming as well as include them in the std namespace. 
#include <cstdio>

//See http://en.cppreference.com/w/cpp/header for a list of headers in the standard library. 

// typically I won't use using namespace... but I haven't talked about them.
// For now ignore. 
using namespace std;

// Below is the definition for main.
// Main is a special program in C++.
// From http://en.cppreference.com/w/cpp/language/main_function
// 1. main cannot be used anywhere in the program
//    a. in particular, it cannot be called recursively
//    b. its address cannot be taken
// 2. It cannot be predefined and cannot be overloaded:...
// 3. It cannot be defined as deleted or declared inline, static, or constexpr (since C++17)
// 4. The body of the main function does not need to contain the return statement: if control 
//    reaches the end of main without encountering a return statement, the effect is that of 
//    executing 'return 0;'.
// 5. ... long way to say stuff gets destroyed and then std::exit with the return value is called. 
// 6. ... destructors throwing if main is wrapped with try catch don't actually throw. 
// 7. (since C++14) The return type of the main function cannot be deduced... no auto main(). 

int main(int argc, char* argv[])
{

	/*
	1. Modify your Hello World program so that it can take a command line argument.Allow a user 
	to pass a filename into the program.If the user supplies a command line argument "hello world" 
	should output to a file.


	2.Ask the user "What is your name?", when the program starts up.Allow the user to input 
	a string and store their name in a std::string.Then instead of outputting "Hello, World!" 
	output "Hello, < USER NAME >!"

	Program should always print to stdout but only sometimes print to a file.
	Program should deal with being fed a file that doesn't exist. (printing a warning and 
	exit is good). 

	*/
	std::string name;

	cout << "Please input name: ";
	cin >> name;
	cout << "Hello, < " << name << " >!" << endl;

	if (argc == 2)
	{
		std::ofstream outFile(argv[1]);
		outFile << name;
	}


	//Print out command line args.
	//   for (auto i = 0U; i < argc; ++i) //unsigned int 
	//       std::cout << argv[i] << std::endl;

	//cout << "Hello World once!\n";
  
	//cout.flush();

	//or
	//cout << "Hello World twice!" << std::endl;

	//We can use printf too... We did include cstdio after all. 
	//printf("Hello World and a third time!\n");

	//This is the exit code of the program...
	//In linux with bash you can see the exit code of the previous program with 'echo $?'
	//In windows echo %errorlevel%
	//In windows with gui applications use 'start /wait guiapp.exe' to launch the application 
	//and then 'echo %errorlevel%' to see the error code. 
	return 0;
}#include <iostream>
#include <fstream>
#include <sstream>
#include <string>

using namespace std;

int main(int argc, char* argv[])
{
	/*
	Assignment 2.1:

	Write a program called max that can read in 32 bit integers from a comma separated file. 
	To make things a little easier files will contain 256 numbers or less. Store the numbers 
	in an array and use a range-for to iterate through them looking for the Max number. Once 
	you have found the max number print it to stdout. 
	Free all dynamically allocated memory. 
	Use functions to structure your code as needed. 
	An example data input is provided below. 
	Don't worry about dealing with malformed data files. 

	*/

	
	if (argc != 2)
	{
		cout << "Usage: ./max filename" << endl << "\tfilename - name of CSV with 32bit integers" << endl;
		return -1;
	}

	std::ifstream outFile(argv[1]);
		
	int arr[256] = { 0 };
	int value, i = 0;
	int max = 0;
	char c;

	while (outFile >> value)
	{		
		arr[i++] = value;
		outFile >> c;
	}

	
	for (int& i : arr)  // for (auto i : arr)
	{
		if (i > max) max = i;
	}

	cout << "Max value: " << max << endl;

    return 0;
}#include <iostream>
#include <string>

using namespace std;



int main()
{
	int intSize, longSize, pointerSize;
	string arch = "Hello i am a ";

	cout << arch;

	intSize = sizeof(int) * 8;
	longSize = sizeof(long) * 8;
	pointerSize = sizeof(int *) * 8;

	if (intSize == 16 && longSize == 32 && pointerSize == 32)
		cout << "LP 32" << endl;
	else if (intSize == 32 && longSize == 32 && pointerSize == 32)
		cout << "LLP 32" << endl;
	else if (intSize == 32 && longSize == 32 && pointerSize == 64)
		cout << "LLP 64" << endl;
	else if (intSize == 32 && longSize == 64 && pointerSize == 64)
		cout << "LP 64" << endl;
	else 
		cout << "Unknown" << intSize << ":" << longSize << ":" << pointerSize << endl;

	/*
	if (intSize == 32)
	{
		if (longSize == 32)
		{
			if (pointerSize == 32)
			{
				cout << "ILP 32" << endl;
			}
			else if (pointerSize == 64)
			{
				cout << "LLP 64" << endl;
			}
			else
			{
				cout << "Unknown" << intSize << ":" << longSize << ":" << pointerSize << endl;
			}
		}
		else if (longSize == 64 && pointerSize == 64)
		{
			cout << "LP64" << endl;
		}
		else
		{
			cout << "Unknown" << intSize << ":" << longSize << ":" << pointerSize << endl;
		}

	}
	else if (longSize == 32 && pointerSize == 32)
	{
		cout << "LP32" << endl;
	}
	else
	{
		cout << "Unknown" << intSize << ":" << longSize << ":" << pointerSize << endl;
	}
	*/

	return 0;
}

#include "pizza.hpp"

Basic::Basic(Pizza::Size s)
{
	cost_ = 0.0;

	size_ = s;

	if (s == Pizza::Size::small_) cost_ = 5.00;
	if (s == Pizza::Size::medium) cost_ = 8.00;
	if (s == Pizza::Size::large) cost_ = 10.00;

	toppings_.push_back("Cheese");
}


std::ostream & operator<<(std::ostream & os, const Basic & basic)
{
	os << "Basic Pizza: ";

	if (basic.getSize() == Pizza::Size::small_) os << "\tSize Small\n";
	if (basic.getSize() == Pizza::Size::medium) os << "\tSize Medium\n";
	if (basic.getSize() == Pizza::Size::large) os << "\tSize Large\n";

	os << "Toppings: ";

	auto t = basic.getToppings();
	unsigned int count = 0;

	for (auto x : t)
	{
		os << x;
		if (++count < t.size()) os << ", ";
	}

	os << std::endl;

	os << "Cost: " << basic.getCost();

	os << std::endl;

	return os;
}

/*
Supreme::Supreme(Pizza::Size s) : size_(s) {

	if (s == Pizza::Size::small_) cost_ = 5.00;
	if (s == Pizza::Size::medium) cost_ = 8.00;
	if (s == Pizza::Size::large) cost_ = 10.00;

	toppings_.push_back("Cheese");
	toppings_.push_back("Pepperoni");		cost_ += 1.25;
	toppings_.push_back("Mushrooms");		cost_ += 1.25;
	toppings_.push_back("Green Pepper");	cost_ += 1.25;
	toppings_.push_back("Onions");			cost_ += 1.25;
	toppings_.push_back("Sausage");			cost_ += 1.25;
}


std::ostream & operator<<(std::ostream & os, const Supreme & supreme)
{
	os << "Supreme Pizza: ";
	
	if (supreme.getSize() == Pizza::Size::small_) os << "\tSize Small\n";
	if (supreme.getSize() == Pizza::Size::medium) os << "\tSize Medium\n";
	if (supreme.getSize() == Pizza::Size::large) os << "\tSize Large\n";

	os << "Toppings: ";

	auto t = supreme.getToppings();
	unsigned int count = 0;

	for (auto x : t)
	{
		os << x;
		if (++count < t.size()) os << ", ";
	}

	os << std::endl;

	os << "Cost: " << supreme.getCost();
	
	os << std::endl;

	return os;
}

std::ostream & operator<<(std::ostream & os, const MeatLovers & meatlovers)
{
	os << "Supreme Pizza: ";

	if (meatlovers.getSize() == Pizza::Size::small_) os << "\tSize Small\n";
	if (meatlovers.getSize() == Pizza::Size::medium) os << "\tSize Medium\n";
	if (meatlovers.getSize() == Pizza::Size::large) os << "\tSize Large\n";

	os << "Toppings: ";

	auto t = meatlovers.getToppings();
	unsigned int count = 0;

	for (auto x : t)
	{
		os << x;
		if (++count < t.size()) os << ", ";
	}

	os << std::endl;

	os << "Cost: " << meatlovers.getCost();

	os << std::endl;

	return os;
}

MeatLovers::MeatLovers(Pizza::Size s): size_(s)
{
	if (s == Pizza::Size::small_) cost_ = 5.00;
	if (s == Pizza::Size::medium) cost_ = 8.00;
	if (s == Pizza::Size::large) cost_ = 10.00;

	toppings_.push_back("Cheese");
	toppings_.push_back("Pepperoni");		cost_ += 1.25;
	toppings_.push_back("Sausage");			cost_ += 1.25;
	toppings_.push_back("Ham");				cost_ += 1.25;
	toppings_.push_back("Ground Beef");		cost_ += 1.25;
	toppings_.push_back("Candian Bacon");	cost_ += 1.25;
}
*/

#include <iostream>
#include "pizza.hpp"
#include <Windows.h>


int main(void) try
{
	using std::cout;
	using std::endl;

	/*
	cout << "Order up.  1 Supreme Pizza" << endl;
	Supreme pie1;
	cout << pie1;

	cout << endl << "Order up. 1 Meat Lovers Pizza" << endl;
	MeatLovers pie2(Pizza::Size::large);
	cout << pie2;
	*/

	cout << endl << "Order up. 1 Custom Pizza" << endl;
	Basic pie3;

	pie3.addToppings("Bacon");
	pie3.addToppings("Sausage");
	pie3.addToppings("Pepperoni");
	pie3.addToppings("Jalapenos");
	cout << pie3;

	cout << endl;
	Pepperoni pie4;
	cout << pie4;

	cout << "Baking 5 minutes... ";
	cout << "Bake time left: " << pie4.bake(5) << endl;
	cout << "Baking 10 more minutes... ";
	cout << "Bake time left: " << pie4.bake(10) << endl;
	cout << "Baking 15 more minutes... ";
	cout << "Bake time left: " << pie4.bake(15) << endl;
	cout << "Baking 5 more minutes... ";
	cout << "Bake time left: " << pie4.bake(5) << endl;
	cout << "Baking 10 more minutes... ";
	pie4.bake(10);

	Sleep(6000);
	return 0;
}
catch (BurntPizza e)
{
	std::cout << "Oh no: " << e.what() << std::endl;
	exit(-1);
}
catch (...) {
	std::cout << "Something Bad Happened and nobody knows what that is!!\n";
	exit(-1);
}#include "encryption.h"
#include <cctype>
#include <random>
#include <algorithm>

Encryption::Encryption(const std::string & key)
{
	setKey(key);
}

Encryption::Encryption()
{
	std::string s;
	s = generateKey();
	setKey(s);
}

std::string Encryption::encrypt(const std::string & clearText)
{
	std::string s;
	
	s = encode(clearText, KeyType::EncryptKey);

	return s;
}

std::string Encryption::decrypt(const std::string & encodeText)
{
	std::string s;

	s = encode(encodeText, KeyType::DecryptKey);

	return s;
}

bool Encryption::setKey(const std::string & key)
{
	char c = 'a';

	if (key.empty() || (key.size() != 26))
		return false;

	for (auto x : key)
	{
		if (std::isalpha(x))
		{
			encrypt_key_[x] = c;
			decrypt_key_[c] = x;
		}
		c++;  // Pun not intended
	}

	return true;
}

std::string Encryption::getKey()
{
	std::string s;

	for (const auto& n : encrypt_key_)
		s.push_back(n.first);

	return s;
}

std::string Encryption::generateKey()
{
	std::string s("abcdefghijklmnopqrstuvwxyz");
	std::random_shuffle(s.begin(), s.end());
	return s;
}

std::string Encryption::encode(const std::string & data, KeyType type)
{
	std::string s;
	const std::unordered_map<char, char>* key = nullptr;

	if (type == KeyType::EncryptKey)
	{
		key = &encrypt_key_;
	}
	else
	{
		key = &decrypt_key_;
	}

	for (auto c : data)
	{
		if (std::isalpha(c))
		{
			s.push_back(key->at(std::tolower(c)));	
		}
		else
		{
			s.push_back(c);
		}
	}

	return s;
}
#include <iostream>
#include "encryption.h"
#include <time.h>


int main()
{
	srand(time(NULL));//set random # seed
	using std::cout;
	using std::endl;

	std::string plainText = "Hello this is a test! For 2nd encryption lab.";

	// Create the class object
	Encryption e;

	// A random key was created
	cout << "Show key: " << e.getKey() << endl;

	// Ecrypt test
	std::string cipherText = e.encrypt(plainText);
	cout << "Encypted message: " << cipherText << endl;
	
	// Decrypt test
	cout << "Decrypted message: " << e.decrypt(cipherText);

	return 0;
}#include "VectorInt.h"
#include <stdexcept>

////////////////////////////////////////VectorInt
int& VectorInt::operator[](VectorInt::size_type pos)
{
    return array_[pos];
}

VectorInt::size_type VectorInt::size() const
{
    return size_;
}

VectorInt::iterator VectorInt::begin()
{
    return VectorInt::iterator(this, 0);
}

VectorInt::iterator VectorInt::end()
{
    return VectorInt::iterator(this, size_);
}

void VectorInt::push_back(int x)
{
    if (size_ == capacity_)
    {
        grow();
    }
    array_[size_] = x;
    size_++;
}

int VectorInt::back() const
{
    if (size_ == 0)
        throw std::runtime_error("ARRAY IS EMPTY YOU IDIOT!!!");
    return array_[size_ - 1];
}

void VectorInt::pop_back()
{
    if (size_ == 0)
        throw std::runtime_error("ARRAY IS EMPTY YOU IDIOT");
    size_--;
}

void VectorInt::grow()
{
   
    if (capacity_ == 0)
    {
        capacity_ = 10;
    }
    else
    {
        capacity_ *= 2;
    }

    auto tmp = std::make_unique<int[]>(capacity_);
    for (auto i = 0U; i < size_; ++i)
        tmp[i] = array_[i];
    array_ = std::move(tmp);
}



////////////////////////////////////////Iterator
VectorIntIterator::VectorIntIterator(VectorInt* ptr, VectorInt::size_type pos):container_(ptr), pos_(pos) {}

VectorInt::iterator& VectorIntIterator::operator++()
{
    pos_++;
    return *this;
}

VectorInt::iterator VectorIntIterator::operator++(int)
{
    VectorIntIterator tmp = *this;
    pos_++;
    return tmp;
}

VectorInt::iterator& VectorIntIterator::operator--()
{
    pos_--;
    return *this;
}

VectorInt::iterator VectorIntIterator::operator--(int)
{
    VectorIntIterator tmp = *this;
    pos_--;
    return tmp;
}

VectorInt::reference VectorIntIterator::operator*()
{
    return (*container_)[pos_];
}

bool VectorIntIterator::operator!=(const VectorInt::iterator& n)
{
    return container_ != n.container_ || pos_ != n.pos_;
}

bool VectorIntIterator::operator==(const VectorInt::iterator& n)
{
    return !(*this != n);
//    return !operator!=(n);
}



#include "Classes.hpp"
#include <cctype>
#include <string>

ValueType Value::getType() const
{
	return vt_;
}

int Value::getInt()
{
	return du_.x_;
}

std::string Value::getString()
{
	return du_.s_;
}

double Value::getDouble()
{
	return du_.d_;
}

int Value::operator+(int i)
{
	auto ret = (*this).getInt() + i;
	du_.x_ = ret;
	return ret;
}

double Value::operator+(double d)
{
	auto ret = (*this).getDouble() + d;
	du_.d_ = ret;
	return ret;
}

std::string Value::operator+(std::string s) 
{
	auto ret = (*this).getString() + s;
	du_.s_ = ret;
	return ret;
}

void Stack::push(std::shared_ptr<IValue>&& v)
{
	vstack_.push_back(v);
}

std::shared_ptr<IValue> Stack::pop()
{
	auto ret = vstack_.back();
	vstack_.pop_back();	
	return ret;
}

uint32_t Stack::count() const
{
	return vstack_.size();
}

std::shared_ptr<IValue> make_value(int x) { return std::make_shared<Value>(x); }
std::shared_ptr<IValue> make_value(double x) { return std::make_shared<Value>(x); }
std::shared_ptr<IValue> make_value(std::string x) { return std::make_shared<Value>(x); }

std::unique_ptr<IStack> make_stack() { return std::make_unique<Stack>(); }#define CATCH_CONFIG_MAIN
#include "catch.hpp"
#include "Classes.hpp"


TEST_CASE("Classes Test", "[Classes]") {
	auto stack = make_stack();

	REQUIRE(stack->count() == 0);
	
	auto x = make_value(10);

	REQUIRE(((*x) + 10) == 20);
	REQUIRE(x->getInt() == 20);
	stack->push(std::move(x));

	REQUIRE(stack->count() == 1);
	auto y = make_value(1.23);

	REQUIRE(((*y) + 2.34) == 3.57);
	REQUIRE(y->getDouble() == 3.57);
	stack->push(std::move(y));

	REQUIRE(stack->count() == 2);

	std::string s = "asdkfj";
	std::string m = "derp";
	auto z = make_value(s);

	REQUIRE(z->getString() == s);
	REQUIRE(((*z) + m) == (s + m));
	stack->push(std::move(z));

	REQUIRE(stack->count() == 3);
	stack->pop();
	REQUIRE(stack->count() == 2);
	stack->pop();
	REQUIRE(stack->count() == 1);
	stack->pop();
	REQUIRE(stack->count() == 0);

}

#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>
#include <numeric>
#include <string>
#include <map>
//Add container headers that you want to use here

////////////////////////////////////////////////

/**************************************************
Write an application that will:

* Take exactly one command line parameter with the filename of
  the file to be processed

* Read the numbers in from that file. The file should be in the 
  format of "98, 43, 34". i.e. it will start with and number and 
  end with a number. All numbers will be seperated by a comma. 

* Determine the min number, the max number, the median number and
  the mean number and print them to the screen. 

* Determine the number that appears the most in the file.

* Write all the numbers back out to a file named the same as the input
  filename BUT with .sorted.txt appended to the filename. 

  YOU ARE NOT ALLOWED TO USE AN ARRAY TO STORE DATA ONLY STL CONTAINERS!!!: 

Things to think about:
* Which containers would be good for sorting the data?
* Which containers would be good for indexing the numbers?
* What container would make it easy to get the median number out of? 

***************************************************/

// Source: stackoverflow.com/questions/16792694/maximum-occurrences
int most_frequent_element(std::vector<int> const& v)
{   
	std::map<int, int> frequencyMap;
	int maxFrequency = 0;
	int mostFrequentElement = 0;
	for (int x : v)
	{
		int f = ++frequencyMap[x];
		if (f > maxFrequency)
		{
			maxFrequency = f;
			mostFrequentElement = x;
		}
	}

	return mostFrequentElement;
}

/*
Containers overview

Vectors	An internal array and allows a user to dynamically grow that array at the end of the array.

Deque	A "double-ended queue"
Array	Useful as a better C-Style Array
List	A doubly linked list
forward_list (C++11) Saves memory by only having a pointer to the next element and not the previous

set is a collection in which elements are sorted according to their own values.
multiset is a collection like the set that allows elements to exist more than once.
map is a collection of elements with key/value pairs that is sorted based on the key.
multimap is a collection like the map that allows elements to be in the collection multiple times.

unordered set: A collection of unordered elements. Elements may only occur once.
unordered multiset: The same as an unordered set but allows duplicates.
unordered map: A collection of key/value pairs where the key is only allowed to be in the collection once.
unordered multimap: The same a unordered map but allows for duplicate keys.

*/

int main(int argc, char* argv[])
{
	if (argc != 2)
	{
		std::cout << "Usage: max.exe filename" << std::endl;
		return -1;
	}

	std::ifstream inFile(argv[1]);
	if (!inFile)
	{
		return -1;
	}

	int value;
	char comma;

	// Vector container was selected because Steve recommended it
	// He knows more C++ than me
	std::vector<int> v;

	// Read file and input into the vector
	while (!inFile.eof())
	{
		inFile >> value;
		v.push_back(value);	
		inFile >> comma;		// Request a better way to do this
	}

	// Sort the vector
	std::sort(v.begin(), v.end());
	
	// Print all numbers (debugging)
	//for (int& i : v) std::cout << i << std::endl; std::cout << std::endl;
	
	// Print min number and the max number
	std::cout << "Min number: " << v.front() << std::endl;
	std::cout << "Max number: " << v.back() << std::endl;

	// Calculate median and print
	// stackoverflow.com/questions/2114797/compute-median-of-values-stored-in-vector-c
	double median;
	size_t size = v.size();
	if (size % 2 == 0) 
		median = (v[size / 2 - 1] + v[size / 2]) / 2;
	else 
		median = v[size / 2];
	std::cout << "Median number: " << median << std::endl;

	// Calculate mean and print
	// stackoverflow.com/questions/4852954/in-c-how-to-compute-the-mean-of-a-vector-of-integers-using-a-vector-view-and
	double mean = std::accumulate(v.begin(), v.end(), 0.0) / v.size();
	std::cout << "Mean number: " << mean << std::endl;

	// Determine the number that appears the most in the file
	std::cout << "Number that appears most: " << most_frequent_element(v);

	// Write all the numbers back out to a file with .sorted.txt appended to the filename
	std::string filename = argv[1];
	filename.append(".sorted.txt");	
	std::ofstream outFile(filename);
	for (auto itr = v.begin(); itr < v.end(); ++itr)
	{
		outFile << *itr;
		if (itr < (v.end() - 1))
			outFile << ",";
	}

	return 0;
}#include <iostream>
#include <fstream>
//Add container headers that you want to use here
#include <ctime>			// random
#include <cstdlib>			// random


////////////////////////////////////////////////

/**************************************************
Write an application that will:
generate random numbers for the Max 2 application. 

* You program should take 2 parameters
  * 1st - the max number of numbers
  * 2nd - the filename to output to

Not allowed to use any arrays only STL containers

***EXTRA BONUS 
* utilize the random functions in <random>
* Take commandline options so that
  * the generator only generates random negative numbers
  * so the largest number is the last element
  * so the largest number is the first element

***************************************************/
int main(int argc, char* argv[])
{
	// Check for correct args
	if (argc != 3)
	{
		std::cerr << "Usage: " << argv[0] << " Quantity Filename" << std::endl;
		return -1;
	}

	// Ensure more 0 numbers
	if (std::atoi(argv[1]) < 0)
	{
		std::cerr << "Usage: " << argv[0] << " Quantity Filename" << std::endl;
		std::cerr << "Error: Quanity " << argv[1] << " must be greater than 0" << std::endl;
		return -1;
	}

	std::ofstream outFile(argv[2]);
	if (!outFile)
	{
		std::cerr << "Error: Unable to open " << argv[2] << std::endl;
		return -1;
	}

	// Seed ran gen
	srand(time(NULL));
	std::cout << rand() << std::endl;
	
	for (int i = 0; i < std::atoi(argv[1]) - 1; i++)
	{
		outFile << rand() << ",";
	}
	outFile << rand();
}#include <iostream>
#include <fstream>
//Add container headers that you want to use here
#include <unordered_map>
#include <cctype>


////////////////////////////////////////////////

/**************************************************
ciphermap

Takes a key file and converts it to an unordered
map hash.

Returns an unordered map hash

***************************************************/
std::unordered_map<char,char> ciphermap(std::ifstream& key)
{
	std::unordered_map<char, char> um;
	char c;
	char alpha = 'a';

	while (!key.eof())
	{
		key >> c;
		std::pair<char, char> keypair(alpha++, c);
		um.insert(keypair);
	}

	return um;
}


/**************************************************
decipher

Takes the unorder map, the encrypted file, and file
to write the output to

returns 1 for success or 0 for failure

***************************************************/
int decipher(std::unordered_map<char, char>& um, std::ifstream& encrypted, std::ofstream& outFile)
{
	char c;

	if (!encrypted || !outFile)
	{
		std::cerr << "Error(decipher): cannot read or write files" << std::endl;
		return 0;
	}
		
	// Allows reading of whitespaces (newlines, tabs, etc)
	encrypted.unsetf(_IOSskipws);		

	// Get the first character to initalize loop
	encrypted >> c;

	while (!encrypted.eof())
	{
		if (std::isalpha(c))
		{
			outFile << um[c];
		}
		else
		{
			outFile << c;
		}
		encrypted >> c;
	}

	return 0;
}


/**************************************************
Write an application that will:
Decode a subsitution cipher encoded message

* You program should take 2 parameters
* 1st - encrypted message filename
* 2nd - the filename containing the key

It should decode the message and output to a file name
the encrypted files name appended with .clear.txt
***************************************************/
int main(int argc, char* argv[])
{
	// Usage
	if (argc != 3)
	{
		std::cerr << "Usage: encryptedfile key" << std::endl;
		return -1;
	}
	
	// Create and open the outfile
	std::string filename(argv[1]);
	filename.append(".clear.txt");

	// Open the files
	std::ifstream encrypted(argv[1]);
	std::ifstream key(argv[2]);
	std::ofstream outFile(filename);

	// Check if file exists
	if (!encrypted)
	{
		std::cerr << "Error: could not open " << argv[1] << std::endl;
		return -1;
	}

	// Check if file exists
	if (!key)
	{
		std::cerr << "Error: could not open " << argv[2] << std::endl;
	}

	// Check if file exists
	if (!outFile)
	{
		std::cerr << "Error: could not open " << filename.c_str() << std::endl;
	}

	// Build the key map with an unordered map
	std::unordered_map<char, char> um = ciphermap(key);
	
	// Decipher
	decipher(um, encrypted, outFile);

	return 0;
}#include <iostream>
#include <fstream>
//Add container headers that you want to use here
#include <unordered_map>
#include <cctype>

////////////////////////////////////////////////

/**************************************************
cipher

Input: file with a key mapping

Output: An unordered map container with a mapping of
alphabet chars to their substuted characters
***************************************************/
std::unordered_map<char, char> mapcipher(std::ifstream& key)
{
	char c;
	char alpha = 'a';
	std::unordered_map<char, char> um;

	while (!key.eof())
	{
		key >> c;
		std::pair<char, char> keypair(c, alpha++);
		um.insert(keypair);
	}

	// Ensure we have a proper key set
	if (um.size() != 26)
	{
		std::cout << "Error: key file should have 26 characters not " << um.size() << std::endl;
	}

	// Iterate and print keys and values of unordered_map
	// Source www.cplusplus.com/reference
	// for (const auto& n : um) std::cout << "Key:[" << n.first << "] Value:[" << n.second << "]\n";
}

/**************************************************
cipher

Input: file with a key mapping

Output: An unordered map container with a mapping of
alphabet chars to their substuted characters
***************************************************/
int cipher(std::unordered_map<char, char>& um, std::ifstream& plaintext, std::ofstream& outFile)
{
	char c;

	// Allow >> to read in spaces (newlines, tabs, etc)
	plaintext.unsetf(_IOSskipws);

	// Loop dynamics, enter loop with the first character
	plaintext >> c;

	while (!plaintext.eof())
	{
		if (std::isalpha(c))		// Encrypt 
		{
			c = std::tolower(c);
			outFile << um[c];
		}
		else						// Do not encrypt
		{
			outFile << c;
		}
		plaintext >> c;
	}

	return 0;
}


/**************************************************
Write an application that will:
Encode a subsitution cipher encoded message

* You program should take 2 parameters
* 1st - plaintext message filename
* 2nd - the filename containing the key

It should encode the message and output to a file name
the encrypted files name appended with .enc.txt
***************************************************/
int main(int argc, char* argv[])
{
	// Key File: file with 26 letters no spaces that maps to a-z
	if (argc != 3)
	{
		std::cerr << "Usage: " << argv[0] << " plaintext key" << std::endl;
		return -1;
	}

	// Write output file appended with .enc.txt
	std::string filename = argv[1];
	filename.append(".enc.txt");

	// Open files
	std::ifstream plaintext(argv[1]);
	std::ifstream key(argv[2]);
	std::ofstream outFile(filename);

	// Ensure file is open
	if (!plaintext)
	{
		std::cerr << "Error: could not open " << argv[1] << std::endl;
		return -1;
	}

	// Ensure file is open
	if (!key)
	{
		std::cerr << "Error: could not open " << argv[2] << std::endl;
		return -1;
	}

	// Ensure file is open
	if (!outFile)
	{
		std::cerr << "Error: could not open " << filename.c_str() << std::endl;
		return -1;
	}
	
	// Build key map with an unordered map
	std::unordered_map<char, char> um = mapcipher(key);
	
	// Encrypt the plaintext with the hash (um) and write to the outFile
	cipher(um, plaintext, outFile);

	return 0;
}#include <iostream>
#include <fstream>
//Add container headers that you want to use here

////////////////////////////////////////////////

/**************************************************
So you think your pretty good eh? 

Well keep reading to accept your challenge. 

############ BONUS BONUS BONUS ########################
Write an application that will:
Crack a substitution cipher using frequency analysis. 

* You program should take 1 parameters
* 1st - encrypted message filename

It should decode the message and output to a file name
the encrypted files name appended with .clear.txt
and a file named the encrypted filename with .key.txt appended to it.

Check the file share to get a hint on how you may go about doing this. 
***************************************************/

int main(int argc, char* argv[])
{


}#include "Scheduler.h"
#include <thread>
#include <algorithm>

using namespace std;


void Scheduler::schedule_tasklet(timepoint scheduled_time, std::shared_ptr<ITasklet> tasklet) {
    // Store the tasklet in tasklets
	std::pair<timepoint, std::shared_ptr<ITasklet>> keypair(scheduled_time, tasklet);
	tasklets.insert(keypair);
}

std::pair<timepoint, std::shared_ptr<ITasklet>> Scheduler::next_tasklet() const {
    /*
    * @brief Returns the next_tasklet to run
    *
    * @throw std::exception if tasklets is empty.
    */
	if (tasklets.empty())  throw std::runtime_error("No tasklets assigned.");	

	for (const auto& elem : tasklets)
		return elem;
}

std::string Scheduler::completed_tasklet_result(long tasklet_id) const {
    /*
    * @brief returns the result for a tasklet that has run
    *
    * @throw std::exception if tasklet result not found.
    */
	if (!results.count(tasklet_id)) 
		throw std::exception("Tasklet result not found.");

	return results.at(tasklet_id);
}

void Scheduler::register_tasklet_hook(std::function<void(const ITasklet&)> hook) {
    /*
    * IMPLEMENT ME!
    * @brief stored the tasklet hook to be used later.
    */
	hooks.push_back(hook);
}

void Scheduler::run() {
    while (contains_tasks()) {
        this_thread::sleep_until(next_tasklet().first);
        while (contains_tasks() && next_tasklet().first < chrono::system_clock::now()) {
            complete_next_tasklet();
        }
    }
}

bool Scheduler::contains_tasks() const {
    /*
    * IMPLEMENT ME!
    * @brief returns true if there are any tasklets to process.
    */
	return !tasklets.empty();
}

void Scheduler::complete_next_tasklet() {
    /*
    * @details:
    * 1. should get "next_tasklet()"
    * 2. should call execute on the tasklet
    * 3. should store the result
    * 4. should pass the tasklet to all hooks
    * 5. should remove the tasklet from tasklets.
    */
	auto n = next_tasklet();

	auto s = n.second->execute();

	results[n.second->get_tasklet_id()] = s;

	for (auto fn : hooks)
		fn(*n.second);

	tasklets.erase(n.first);
	
}
#define CATCH_CONFIG_MAIN
#include "catch.hpp"
#include "Scheduler.h"
#include "ITasklet.h"
#include <memory>
#include <chrono>

using namespace std;
using namespace chrono;

class TestTasklet : public ITasklet {
public:
	TestTasklet(const std::string &expected_string, const long &expected_tasklet_id) : 
		expected_string(expected_string), expected_tasklet_id(expected_tasklet_id) { 
	}

	long get_tasklet_id() const override {
		return expected_tasklet_id;
	}

	std::string execute() override {
		executed = true;
		return expected_string;
	}

	bool was_executed() {
		return executed;
	}
private:
	std::string expected_string;
	long expected_tasklet_id;
	bool executed = false;
};

TEST_CASE("SchedulerInserts", "Scheduler can insert tasklets") {
	Scheduler scheduler;
	auto time = std::chrono::system_clock::now();
	auto tasklet = make_shared<TestTasklet>("result", 1);

	scheduler.schedule_tasklet(time, tasklet);

	auto result = scheduler.next_tasklet();
	REQUIRE(result.first == time);
	REQUIRE(result.second == tasklet);
}

TEST_CASE("SchedulerExecutes", "Scheduler can execute tasklets in sequence") {
	Scheduler scheduler;
	auto time_1 = system_clock::now();
	auto time_2 = time_1 + milliseconds(100);
	auto time_3 = time_2 + milliseconds(100);
	auto tasklet_1 = make_shared<TestTasklet>("result 1", 1);
	auto tasklet_2 = make_shared<TestTasklet>("result 2", 2);
	auto tasklet_3 = make_shared<TestTasklet>("result 3", 3);

	scheduler.schedule_tasklet(time_1, tasklet_1);
	scheduler.schedule_tasklet(time_2, tasklet_2);
	scheduler.schedule_tasklet(time_3, tasklet_3);

	scheduler.run();

	REQUIRE(tasklet_1->was_executed());
	REQUIRE(tasklet_2->was_executed());
	REQUIRE(tasklet_3->was_executed());
}

TEST_CASE("SchedulerContainsTasks", "Scheduler correctly reports whether it contains tasks") {
	Scheduler scheduler;
	REQUIRE(!scheduler.contains_tasks());

	scheduler.schedule_tasklet(system_clock::now(), make_shared<TestTasklet>("result 1", 1));
	REQUIRE(scheduler.contains_tasks());

	scheduler.run();
	REQUIRE(!scheduler.contains_tasks());
}

TEST_CASE("SchedulerCallsHooks", "Scheduler correctly calls hooks on execution") {
	vector<long> hooked_tasklet_ids;

	Scheduler scheduler;
	auto time_1 = system_clock::now();
	auto time_2 = time_1 + milliseconds(100);
	auto tasklet_1 = make_shared<TestTasklet>("result 1", 1);
	auto tasklet_2 = make_shared<TestTasklet>("result 2", 2);

	scheduler.schedule_tasklet(time_1, tasklet_1);
	scheduler.schedule_tasklet(time_2, tasklet_2);
	scheduler.register_tasklet_hook([&hooked_tasklet_ids](const ITasklet &x) { hooked_tasklet_ids.push_back(x.get_tasklet_id()); });
	scheduler.run();

	REQUIRE(hooked_tasklet_ids[0] == 1);
	REQUIRE(hooked_tasklet_ids[1] == 2);
}

TEST_CASE("SchedulerCompletedTaskResult", "Scheduler correctly returns completed tasks") {
	Scheduler scheduler;
	auto time_1 = system_clock::now();
	auto time_2 = time_1 + milliseconds(100);
	auto tasklet_1 = make_shared<TestTasklet>("result 1", 1);
	auto tasklet_2 = make_shared<TestTasklet>("result 2", 2);

	scheduler.schedule_tasklet(time_1, tasklet_1);
	scheduler.schedule_tasklet(time_2, tasklet_2);

	scheduler.run();

	REQUIRE(scheduler.completed_tasklet_result(1) == "result 1");
	REQUIRE(scheduler.completed_tasklet_result(2) == "result 2");
}

TEST_CASE("SchedulerThrowsNextTasklet", "Scheduler throws exception when there is no next tasklet") {
	Scheduler scheduler;
	bool exception_thrown = false;
	try
	{
		scheduler.next_tasklet();
	}
	catch (exception e)
	{
		exception_thrown = string(e.what()) == "No tasklets assigned.";
	}
	REQUIRE(exception_thrown);
}

TEST_CASE("SchedulerThrowsCompletedTaskletResult", "Scheduler throws exception when there is no tasklet result") {
	Scheduler scheduler;
	bool exception_thrown = false;
	try
	{
		scheduler.completed_tasklet_result(1234);
	}
	catch (exception e)
	{
		exception_thrown = string(e.what()) == "Tasklet result not found.";
	}
	REQUIRE(exception_thrown);
}
#define CATCH_CONFIG_MAIN
#include "catch.hpp"
#include "ScaledNum.h"

TEST_CASE("ScaledNums", "[ScaledNums]") {

    SECTION("operator==") {
        ScaledNum num1(4.0, 1.0);
        ScaledNum num2(2.0, 2.0);
        ScaledNum num3(8.0, 0.5);

        REQUIRE(num1 == num2);
        REQUIRE(num2 == num3);
        REQUIRE(num1 == num3);
    }

    SECTION("operator!=") {
        ScaledNum num1(4.0, 3.0);
        ScaledNum num2(2.0, 2.0);
        ScaledNum num3(8.1, 1.5);

        REQUIRE(num1 != num2);
        REQUIRE(num2 != num3);
        REQUIRE(num1 != num3);
    }

    SECTION("Add") {
        ScaledNum num1(2.0, 2.0);
        ScaledNum num2(2.0, 3.0);
        auto num3 = num1 + num2;
        num1 += num2;
        REQUIRE(num1 == num3);
        REQUIRE(num1 == ScaledNum(10, 1));
    }

    SECTION("Sub") {
        ScaledNum num1(2.0, 2.0);
        ScaledNum num2(2.0, 3.0);
        auto num3 = num2 - num1;
        num2 -= num1;
        REQUIRE(num3 == num2);
        REQUIRE(num2 == ScaledNum(2, 1));
    }

    SECTION("MUL") {
        ScaledNum num1(2.0, 5.0);
        ScaledNum num2(10.0, 1.0);
        auto num3 = num1*num2;
        num1 *= num2;
        REQUIRE(num1 == num3);
        REQUIRE(num1 == ScaledNum(100, 1));
    }

    SECTION("Div") {
        ScaledNum num1(100.0, 1);
        ScaledNum num2(1.0, 0.5);
        auto num3 = num1 / num2;
        num1 /= num2;
        REQUIRE(num1 == num3);
        REQUIRE(num1 == ScaledNum(200.0, 1.0));
    }

}#include "ScaledNum.h"

ScaledNum::ScaledNum(double num, double factor):num_(num), factor_(factor)
{
}

ScaledNum::ScaledNum(const ScaledNum & n):num_(n.num_), factor_(n.factor_)
{
}

double ScaledNum::getFactor() const
{
    return factor_;
}

void ScaledNum::setFactor(double factor)
{
    factor_ = factor;
}

std::pair<double, double> ScaledNum::getVals() const
{
    return std::make_pair(num_, factor_);
}

ScaledNum& ScaledNum::operator=(double num)
{
    num_ = num;
    return *this;
}

ScaledNum& ScaledNum::operator=(const ScaledNum & n)
{
    num_ = n.num_;
    factor_ = n.factor_;
    return *this;
}

bool ScaledNum::operator!=(ScaledNum b) const
{
	if (((*this).num_ * (*this).factor_) != (b.num_ * b.factor_))
		return true;
	return false;
}

bool ScaledNum::operator==(ScaledNum b) const
{
	return !(*this != b);
}

ScaledNum ScaledNum::operator+(ScaledNum b) const
{
	ScaledNum tmp(*this);
	tmp += b;
	return tmp;
}

ScaledNum ScaledNum::operator+=(ScaledNum b)
{
	(*this).num_ = (((*this).num_ * (*this).factor_) + (b.num_ * b.factor_)) / ((*this).factor_);
	return *this;
}

ScaledNum ScaledNum::operator-(ScaledNum b) const
{
	ScaledNum tmp(*this);
	tmp -= b;
	return tmp;
}

ScaledNum ScaledNum::operator-=(ScaledNum b)
{
	(*this).num_ = (((*this).num_ * (*this).factor_) - (b.num_ * b.factor_)) / ((*this).factor_);
	return *this;
}

ScaledNum ScaledNum::operator*(ScaledNum b) const
{
	ScaledNum tmp(*this);
	tmp *= b;
	return tmp;
}

ScaledNum ScaledNum::operator*=(ScaledNum b)
{
	(*this).num_ = (((*this).num_ * (*this).factor_) * (b.num_ * b.factor_)) / ((*this).factor_);
	return *this;
}

ScaledNum ScaledNum::operator/(ScaledNum b) const
{
	ScaledNum tmp(*this);
	tmp /= b;
	return tmp;
}

ScaledNum ScaledNum::operator/=(ScaledNum b)
{
	(*this).num_ = (((*this).num_ * (*this).factor_) / (b.num_ * b.factor_)) / ((*this).factor_);
	return *this;
}


std::ostream & operator<<(std::ostream & os, const ScaledNum & n)
{
    os << n.num_ * n.factor_;
    return os;
}
#define CATCH_CONFIG_MAIN
#include "catch.hpp"
#include "yourCode.h"
#include "Person.h"
#include <vector>
#include <sstream>

std::vector<Person> buildPeople()
{
    std::vector<Person> people;
    people.push_back(Person("Jeff", "Scaparra", 32));
    people.push_back(Person("Aaron", "Bray", 28));
    people.push_back(Person("Chet", "Wall", 35));
    people.push_back(Person("Charles", "Heaton", 30));
    people.push_back(Person("Agent", "Smith", 007));
    people.push_back(Person("Cleaning", "Lady", 23));
    people.push_back(Person("Mail", "Mann", 57));
    return people;
}

TEST_CASE("Test2", "[Test2]") {

    SECTION("AGE") {
        auto people = buildPeople();
        auto sortPeople = people;
        sortByAge(sortPeople);
        REQUIRE(people.size() == sortPeople.size());
        REQUIRE(sortPeople.front().age() == 7);
        REQUIRE(sortPeople.back().age() == 57);
        REQUIRE(sortPeople[4].getLast() == "Scaparra");
    }

    SECTION("Name") {
        auto people = buildPeople();
        auto sortPeople = people;
        sortByLastName(sortPeople);
        REQUIRE(people.size() == sortPeople.size());
        REQUIRE(sortPeople.front().getLast() == "Bray");
        REQUIRE(sortPeople.back().getLast() == "Wall");
        REQUIRE(sortPeople[4].getLast() == "Scaparra");
    }

    SECTION("Printing") {
        std::stringstream ss;
        auto people = buildPeople();
        ss << people[0];
        REQUIRE(ss.str() == "Jeff Scaparra, Age: 32");
        ss.str("");
        ss << people[1];
        REQUIRE(ss.str() == "Aaron Bray, Age: 28");
        ss.str("");
        ss << people.back();
        REQUIRE(ss.str() == "Mail Mann, Age: 57");
    }

}#include "Person.h"

std::string Person::getFirst() const
{
    return first_name_;
}

std::string Person::getLast() const
{
    return last_name_;
}

int Person::age() const
{
    return age_;
}
#include "Person.h"
#include <algorithm>
#include <iostream>

//Overload the ostream operator for a person so that it prints out like
// "Jeff Scaparra, Age: 32"
std::ostream& operator<<(std::ostream& os, const Person& p)
{
	os << p.getFirst() << " " << p.getLast() << ", Age: " << p.age();
	return os;
}


#define CATCH_CONFIG_MAIN
#include <cstdint>
#include "catch.hpp"
#include "Header.h"
#include <vector>
#include <deque>
#include <list>
#include <set>

template<typename T> 
void checkAccumulate(T thing) {
    auto count = 3;
    for (auto i = 0; i < 10; ++i, ++count)
        REQUIRE(*(thing++) == count);
}

TEST_CASE("Test3", "[Test3]") {
    SECTION("SizeOfAll") {
        std::vector<uint32_t> int100(100, 0);
        auto size = sizeOfAll(int100);
        REQUIRE(size == 400);
        std::vector<std::vector<uint64_t>> vecvec(20, std::vector<uint64_t>(10, 7));
        size = sizeOfAll(vecvec);
        REQUIRE(size == 20 * sizeof(vecvec[0]));
    }

    SECTION("Accumulate1") {
        std::vector<int> nums{ 1,2,3,4,5,6,7,8,9,10 };
        std::deque<int> nums2(nums.begin(), nums.end());
        std::list<int> nums3(nums.begin(), nums.end());
        //std::set<int> nums4(nums.begin(), nums.end());
        accumulate(nums.begin(), nums.end(), 2);
        accumulate(nums2.begin(), nums2.end(), 2);
        accumulate(nums3.begin(), nums3.end(), 2);
        //accumulate(nums4.begin(), nums4.end(), 2);
        checkAccumulate(nums.begin());
        checkAccumulate(nums2.begin());
        checkAccumulate(nums3.begin());
        //checkAccumulate(nums4.begin());
    }

    SECTION("Accumulate2") {
        int nums[] = { 1,2,3,4,5,6,7,8,9,10 };
        double nums2[] = { 1,2,3,4,5,6,7,8,9,10 };
        accumulate(nums, nums + 10, 2);
        accumulate(nums2, nums2 + 10, 2.0);
        checkAccumulate((int*)nums);
        checkAccumulate((double*)nums2);
    }
}// //////////////////////////////////////////////////////////
// crc32.cpp
// Copyright (c) 2014,2015 Stephan Brumme. All rights reserved.
// see http://create.stephan-brumme.com/disclaimer.html
//

#include "crc32.h"

// big endian architectures need #define __BYTE_ORDER __BIG_ENDIAN
#ifndef _MSC_VER
#include <endian.h>
#endif


/// same as reset()
CRC32::CRC32()
{
  reset();
}


/// restart
void CRC32::reset()
{
  m_hash = 0;
}


namespace
{
  /// look-up table
  static const uint32_t crc32Lookup[8][256] =
  {
    // generated by:
    //for (uint32_t i = 0; i <= 0xFF; i++)
    //{
    //  uint32_t crc = i;
    //  for (unsigned int j = 0; j < 8; j++)
    //    crc = (crc >> 1) ^ ((crc & 1) * Polynomial);
    //  crc32Lookup[0][i] = crc;
    //}
    // slicing-by-8 algorithm (from Intel):
    // http://www.intel.com/technology/comms/perfnet/download/CRC_generators.pdf
    // http://sourceforge.net/projects/slicing-by-8/
    //for (unsigned int i = 0; i <= 0xFF; i++)
    //{
    //  crc32Lookup[1][i] = (crc32Lookup[0][i] >> 8) ^ crc32Lookup[0][crc32Lookup[0][i] & 0xFF];
    //  crc32Lookup[2][i] = (crc32Lookup[1][i] >> 8) ^ crc32Lookup[0][crc32Lookup[1][i] & 0xFF];
    //  crc32Lookup[3][i] = (crc32Lookup[2][i] >> 8) ^ crc32Lookup[0][crc32Lookup[2][i] & 0xFF];

    //  crc32Lookup[4][i] = (crc32Lookup[3][i] >> 8) ^ crc32Lookup[0][crc32Lookup[3][i] & 0xFF];
    //  crc32Lookup[5][i] = (crc32Lookup[4][i] >> 8) ^ crc32Lookup[0][crc32Lookup[4][i] & 0xFF];
    //  crc32Lookup[6][i] = (crc32Lookup[5][i] >> 8) ^ crc32Lookup[0][crc32Lookup[5][i] & 0xFF];
    //  crc32Lookup[7][i] = (crc32Lookup[6][i] >> 8) ^ crc32Lookup[0][crc32Lookup[6][i] & 0xFF];
    //}
    { 0x00000000,0x77073096,0xEE0E612C,0x990951BA,0x076DC419,0x706AF48F,0xE963A535,0x9E6495A3,
      0x0EDB8832,0x79DCB8A4,0xE0D5E91E,0x97D2D988,0x09B64C2B,0x7EB17CBD,0xE7B82D07,0x90BF1D91,
      0x1DB71064,0x6AB020F2,0xF3B97148,0x84BE41DE,0x1ADAD47D,0x6DDDE4EB,0xF4D4B551,0x83D385C7,
      0x136C9856,0x646BA8C0,0xFD62F97A,0x8A65C9EC,0x14015C4F,0x63066CD9,0xFA0F3D63,0x8D080DF5,
      0x3B6E20C8,0x4C69105E,0xD56041E4,0xA2677172,0x3C03E4D1,0x4B04D447,0xD20D85FD,0xA50AB56B,
      0x35B5A8FA,0x42B2986C,0xDBBBC9D6,0xACBCF940,0x32D86CE3,0x45DF5C75,0xDCD60DCF,0xABD13D59,
      0x26D930AC,0x51DE003A,0xC8D75180,0xBFD06116,0x21B4F4B5,0x56B3C423,0xCFBA9599,0xB8BDA50F,
      0x2802B89E,0x5F058808,0xC60CD9B2,0xB10BE924,0x2F6F7C87,0x58684C11,0xC1611DAB,0xB6662D3D,
      0x76DC4190,0x01DB7106,0x98D220BC,0xEFD5102A,0x71B18589,0x06B6B51F,0x9FBFE4A5,0xE8B8D433,
      0x7807C9A2,0x0F00F934,0x9609A88E,0xE10E9818,0x7F6A0DBB,0x086D3D2D,0x91646C97,0xE6635C01,
      0x6B6B51F4,0x1C6C6162,0x856530D8,0xF262004E,0x6C0695ED,0x1B01A57B,0x8208F4C1,0xF50FC457,
      0x65B0D9C6,0x12B7E950,0x8BBEB8EA,0xFCB9887C,0x62DD1DDF,0x15DA2D49,0x8CD37CF3,0xFBD44C65,
      0x4DB26158,0x3AB551CE,0xA3BC0074,0xD4BB30E2,0x4ADFA541,0x3DD895D7,0xA4D1C46D,0xD3D6F4FB,
      0x4369E96A,0x346ED9FC,0xAD678846,0xDA60B8D0,0x44042D73,0x33031DE5,0xAA0A4C5F,0xDD0D7CC9,
      0x5005713C,0x270241AA,0xBE0B1010,0xC90C2086,0x5768B525,0x206F85B3,0xB966D409,0xCE61E49F,
      0x5EDEF90E,0x29D9C998,0xB0D09822,0xC7D7A8B4,0x59B33D17,0x2EB40D81,0xB7BD5C3B,0xC0BA6CAD,
      0xEDB88320,0x9ABFB3B6,0x03B6E20C,0x74B1D29A,0xEAD54739,0x9DD277AF,0x04DB2615,0x73DC1683,
      0xE3630B12,0x94643B84,0x0D6D6A3E,0x7A6A5AA8,0xE40ECF0B,0x9309FF9D,0x0A00AE27,0x7D079EB1,
      0xF00F9344,0x8708A3D2,0x1E01F268,0x6906C2FE,0xF762575D,0x806567CB,0x196C3671,0x6E6B06E7,
      0xFED41B76,0x89D32BE0,0x10DA7A5A,0x67DD4ACC,0xF9B9DF6F,0x8EBEEFF9,0x17B7BE43,0x60B08ED5,
      0xD6D6A3E8,0xA1D1937E,0x38D8C2C4,0x4FDFF252,0xD1BB67F1,0xA6BC5767,0x3FB506DD,0x48B2364B,
      0xD80D2BDA,0xAF0A1B4C,0x36034AF6,0x41047A60,0xDF60EFC3,0xA867DF55,0x316E8EEF,0x4669BE79,
      0xCB61B38C,0xBC66831A,0x256FD2A0,0x5268E236,0xCC0C7795,0xBB0B4703,0x220216B9,0x5505262F,
      0xC5BA3BBE,0xB2BD0B28,0x2BB45A92,0x5CB36A04,0xC2D7FFA7,0xB5D0CF31,0x2CD99E8B,0x5BDEAE1D,
      0x9B64C2B0,0xEC63F226,0x756AA39C,0x026D930A,0x9C0906A9,0xEB0E363F,0x72076785,0x05005713,
      0x95BF4A82,0xE2B87A14,0x7BB12BAE,0x0CB61B38,0x92D28E9B,0xE5D5BE0D,0x7CDCEFB7,0x0BDBDF21,
      0x86D3D2D4,0xF1D4E242,0x68DDB3F8,0x1FDA836E,0x81BE16CD,0xF6B9265B,0x6FB077E1,0x18B74777,
      0x88085AE6,0xFF0F6A70,0x66063BCA,0x11010B5C,0x8F659EFF,0xF862AE69,0x616BFFD3,0x166CCF45,
      0xA00AE278,0xD70DD2EE,0x4E048354,0x3903B3C2,0xA7672661,0xD06016F7,0x4969474D,0x3E6E77DB,
      0xAED16A4A,0xD9D65ADC,0x40DF0B66,0x37D83BF0,0xA9BCAE53,0xDEBB9EC5,0x47B2CF7F,0x30B5FFE9,
      0xBDBDF21C,0xCABAC28A,0x53B39330,0x24B4A3A6,0xBAD03605,0xCDD70693,0x54DE5729,0x23D967BF,
      0xB3667A2E,0xC4614AB8,0x5D681B02,0x2A6F2B94,0xB40BBE37,0xC30C8EA1,0x5A05DF1B,0x2D02EF8D },

    { 0x00000000,0x191B3141,0x32366282,0x2B2D53C3,0x646CC504,0x7D77F445,0x565AA786,0x4F4196C7,
      0xC8D98A08,0xD1C2BB49,0xFAEFE88A,0xE3F4D9CB,0xACB54F0C,0xB5AE7E4D,0x9E832D8E,0x87981CCF,
      0x4AC21251,0x53D92310,0x78F470D3,0x61EF4192,0x2EAED755,0x37B5E614,0x1C98B5D7,0x05838496,
      0x821B9859,0x9B00A918,0xB02DFADB,0xA936CB9A,0xE6775D5D,0xFF6C6C1C,0xD4413FDF,0xCD5A0E9E,
      0x958424A2,0x8C9F15E3,0xA7B24620,0xBEA97761,0xF1E8E1A6,0xE8F3D0E7,0xC3DE8324,0xDAC5B265,
      0x5D5DAEAA,0x44469FEB,0x6F6BCC28,0x7670FD69,0x39316BAE,0x202A5AEF,0x0B07092C,0x121C386D,
      0xDF4636F3,0xC65D07B2,0xED705471,0xF46B6530,0xBB2AF3F7,0xA231C2B6,0x891C9175,0x9007A034,
      0x179FBCFB,0x0E848DBA,0x25A9DE79,0x3CB2EF38,0x73F379FF,0x6AE848BE,0x41C51B7D,0x58DE2A3C,
      0xF0794F05,0xE9627E44,0xC24F2D87,0xDB541CC6,0x94158A01,0x8D0EBB40,0xA623E883,0xBF38D9C2,
      0x38A0C50D,0x21BBF44C,0x0A96A78F,0x138D96CE,0x5CCC0009,0x45D73148,0x6EFA628B,0x77E153CA,
      0xBABB5D54,0xA3A06C15,0x888D3FD6,0x91960E97,0xDED79850,0xC7CCA911,0xECE1FAD2,0xF5FACB93,
      0x7262D75C,0x6B79E61D,0x4054B5DE,0x594F849F,0x160E1258,0x0F152319,0x243870DA,0x3D23419B,
      0x65FD6BA7,0x7CE65AE6,0x57CB0925,0x4ED03864,0x0191AEA3,0x188A9FE2,0x33A7CC21,0x2ABCFD60,
      0xAD24E1AF,0xB43FD0EE,0x9F12832D,0x8609B26C,0xC94824AB,0xD05315EA,0xFB7E4629,0xE2657768,
      0x2F3F79F6,0x362448B7,0x1D091B74,0x04122A35,0x4B53BCF2,0x52488DB3,0x7965DE70,0x607EEF31,
      0xE7E6F3FE,0xFEFDC2BF,0xD5D0917C,0xCCCBA03D,0x838A36FA,0x9A9107BB,0xB1BC5478,0xA8A76539,
      0x3B83984B,0x2298A90A,0x09B5FAC9,0x10AECB88,0x5FEF5D4F,0x46F46C0E,0x6DD93FCD,0x74C20E8C,
      0xF35A1243,0xEA412302,0xC16C70C1,0xD8774180,0x9736D747,0x8E2DE606,0xA500B5C5,0xBC1B8484,
      0x71418A1A,0x685ABB5B,0x4377E898,0x5A6CD9D9,0x152D4F1E,0x0C367E5F,0x271B2D9C,0x3E001CDD,
      0xB9980012,0xA0833153,0x8BAE6290,0x92B553D1,0xDDF4C516,0xC4EFF457,0xEFC2A794,0xF6D996D5,
      0xAE07BCE9,0xB71C8DA8,0x9C31DE6B,0x852AEF2A,0xCA6B79ED,0xD37048AC,0xF85D1B6F,0xE1462A2E,
      0x66DE36E1,0x7FC507A0,0x54E85463,0x4DF36522,0x02B2F3E5,0x1BA9C2A4,0x30849167,0x299FA026,
      0xE4C5AEB8,0xFDDE9FF9,0xD6F3CC3A,0xCFE8FD7B,0x80A96BBC,0x99B25AFD,0xB29F093E,0xAB84387F,
      0x2C1C24B0,0x350715F1,0x1E2A4632,0x07317773,0x4870E1B4,0x516BD0F5,0x7A468336,0x635DB277,
      0xCBFAD74E,0xD2E1E60F,0xF9CCB5CC,0xE0D7848D,0xAF96124A,0xB68D230B,0x9DA070C8,0x84BB4189,
      0x03235D46,0x1A386C07,0x31153FC4,0x280E0E85,0x674F9842,0x7E54A903,0x5579FAC0,0x4C62CB81,
      0x8138C51F,0x9823F45E,0xB30EA79D,0xAA1596DC,0xE554001B,0xFC4F315A,0xD7626299,0xCE7953D8,
      0x49E14F17,0x50FA7E56,0x7BD72D95,0x62CC1CD4,0x2D8D8A13,0x3496BB52,0x1FBBE891,0x06A0D9D0,
      0x5E7EF3EC,0x4765C2AD,0x6C48916E,0x7553A02F,0x3A1236E8,0x230907A9,0x0824546A,0x113F652B,
      0x96A779E4,0x8FBC48A5,0xA4911B66,0xBD8A2A27,0xF2CBBCE0,0xEBD08DA1,0xC0FDDE62,0xD9E6EF23,
      0x14BCE1BD,0x0DA7D0FC,0x268A833F,0x3F91B27E,0x70D024B9,0x69CB15F8,0x42E6463B,0x5BFD777A,
      0xDC656BB5,0xC57E5AF4,0xEE530937,0xF7483876,0xB809AEB1,0xA1129FF0,0x8A3FCC33,0x9324FD72 },

    { 0x00000000,0x01C26A37,0x0384D46E,0x0246BE59,0x0709A8DC,0x06CBC2EB,0x048D7CB2,0x054F1685,
      0x0E1351B8,0x0FD13B8F,0x0D9785D6,0x0C55EFE1,0x091AF964,0x08D89353,0x0A9E2D0A,0x0B5C473D,
      0x1C26A370,0x1DE4C947,0x1FA2771E,0x1E601D29,0x1B2F0BAC,0x1AED619B,0x18ABDFC2,0x1969B5F5,
      0x1235F2C8,0x13F798FF,0x11B126A6,0x10734C91,0x153C5A14,0x14FE3023,0x16B88E7A,0x177AE44D,
      0x384D46E0,0x398F2CD7,0x3BC9928E,0x3A0BF8B9,0x3F44EE3C,0x3E86840B,0x3CC03A52,0x3D025065,
      0x365E1758,0x379C7D6F,0x35DAC336,0x3418A901,0x3157BF84,0x3095D5B3,0x32D36BEA,0x331101DD,
      0x246BE590,0x25A98FA7,0x27EF31FE,0x262D5BC9,0x23624D4C,0x22A0277B,0x20E69922,0x2124F315,
      0x2A78B428,0x2BBADE1F,0x29FC6046,0x283E0A71,0x2D711CF4,0x2CB376C3,0x2EF5C89A,0x2F37A2AD,
      0x709A8DC0,0x7158E7F7,0x731E59AE,0x72DC3399,0x7793251C,0x76514F2B,0x7417F172,0x75D59B45,
      0x7E89DC78,0x7F4BB64F,0x7D0D0816,0x7CCF6221,0x798074A4,0x78421E93,0x7A04A0CA,0x7BC6CAFD,
      0x6CBC2EB0,0x6D7E4487,0x6F38FADE,0x6EFA90E9,0x6BB5866C,0x6A77EC5B,0x68315202,0x69F33835,
      0x62AF7F08,0x636D153F,0x612BAB66,0x60E9C151,0x65A6D7D4,0x6464BDE3,0x662203BA,0x67E0698D,
      0x48D7CB20,0x4915A117,0x4B531F4E,0x4A917579,0x4FDE63FC,0x4E1C09CB,0x4C5AB792,0x4D98DDA5,
      0x46C49A98,0x4706F0AF,0x45404EF6,0x448224C1,0x41CD3244,0x400F5873,0x4249E62A,0x438B8C1D,
      0x54F16850,0x55330267,0x5775BC3E,0x56B7D609,0x53F8C08C,0x523AAABB,0x507C14E2,0x51BE7ED5,
      0x5AE239E8,0x5B2053DF,0x5966ED86,0x58A487B1,0x5DEB9134,0x5C29FB03,0x5E6F455A,0x5FAD2F6D,
      0xE1351B80,0xE0F771B7,0xE2B1CFEE,0xE373A5D9,0xE63CB35C,0xE7FED96B,0xE5B86732,0xE47A0D05,
      0xEF264A38,0xEEE4200F,0xECA29E56,0xED60F461,0xE82FE2E4,0xE9ED88D3,0xEBAB368A,0xEA695CBD,
      0xFD13B8F0,0xFCD1D2C7,0xFE976C9E,0xFF5506A9,0xFA1A102C,0xFBD87A1B,0xF99EC442,0xF85CAE75,
      0xF300E948,0xF2C2837F,0xF0843D26,0xF1465711,0xF4094194,0xF5CB2BA3,0xF78D95FA,0xF64FFFCD,
      0xD9785D60,0xD8BA3757,0xDAFC890E,0xDB3EE339,0xDE71F5BC,0xDFB39F8B,0xDDF521D2,0xDC374BE5,
      0xD76B0CD8,0xD6A966EF,0xD4EFD8B6,0xD52DB281,0xD062A404,0xD1A0CE33,0xD3E6706A,0xD2241A5D,
      0xC55EFE10,0xC49C9427,0xC6DA2A7E,0xC7184049,0xC25756CC,0xC3953CFB,0xC1D382A2,0xC011E895,
      0xCB4DAFA8,0xCA8FC59F,0xC8C97BC6,0xC90B11F1,0xCC440774,0xCD866D43,0xCFC0D31A,0xCE02B92D,
      0x91AF9640,0x906DFC77,0x922B422E,0x93E92819,0x96A63E9C,0x976454AB,0x9522EAF2,0x94E080C5,
      0x9FBCC7F8,0x9E7EADCF,0x9C381396,0x9DFA79A1,0x98B56F24,0x99770513,0x9B31BB4A,0x9AF3D17D,
      0x8D893530,0x8C4B5F07,0x8E0DE15E,0x8FCF8B69,0x8A809DEC,0x8B42F7DB,0x89044982,0x88C623B5,
      0x839A6488,0x82580EBF,0x801EB0E6,0x81DCDAD1,0x8493CC54,0x8551A663,0x8717183A,0x86D5720D,
      0xA9E2D0A0,0xA820BA97,0xAA6604CE,0xABA46EF9,0xAEEB787C,0xAF29124B,0xAD6FAC12,0xACADC625,
      0xA7F18118,0xA633EB2F,0xA4755576,0xA5B73F41,0xA0F829C4,0xA13A43F3,0xA37CFDAA,0xA2BE979D,
      0xB5C473D0,0xB40619E7,0xB640A7BE,0xB782CD89,0xB2CDDB0C,0xB30FB13B,0xB1490F62,0xB08B6555,
      0xBBD72268,0xBA15485F,0xB853F606,0xB9919C31,0xBCDE8AB4,0xBD1CE083,0xBF5A5EDA,0xBE9834ED },

    { 0x00000000,0xB8BC6765,0xAA09C88B,0x12B5AFEE,0x8F629757,0x37DEF032,0x256B5FDC,0x9DD738B9,
      0xC5B428EF,0x7D084F8A,0x6FBDE064,0xD7018701,0x4AD6BFB8,0xF26AD8DD,0xE0DF7733,0x58631056,
      0x5019579F,0xE8A530FA,0xFA109F14,0x42ACF871,0xDF7BC0C8,0x67C7A7AD,0x75720843,0xCDCE6F26,
      0x95AD7F70,0x2D111815,0x3FA4B7FB,0x8718D09E,0x1ACFE827,0xA2738F42,0xB0C620AC,0x087A47C9,
      0xA032AF3E,0x188EC85B,0x0A3B67B5,0xB28700D0,0x2F503869,0x97EC5F0C,0x8559F0E2,0x3DE59787,
      0x658687D1,0xDD3AE0B4,0xCF8F4F5A,0x7733283F,0xEAE41086,0x525877E3,0x40EDD80D,0xF851BF68,
      0xF02BF8A1,0x48979FC4,0x5A22302A,0xE29E574F,0x7F496FF6,0xC7F50893,0xD540A77D,0x6DFCC018,
      0x359FD04E,0x8D23B72B,0x9F9618C5,0x272A7FA0,0xBAFD4719,0x0241207C,0x10F48F92,0xA848E8F7,
      0x9B14583D,0x23A83F58,0x311D90B6,0x89A1F7D3,0x1476CF6A,0xACCAA80F,0xBE7F07E1,0x06C36084,
      0x5EA070D2,0xE61C17B7,0xF4A9B859,0x4C15DF3C,0xD1C2E785,0x697E80E0,0x7BCB2F0E,0xC377486B,
      0xCB0D0FA2,0x73B168C7,0x6104C729,0xD9B8A04C,0x446F98F5,0xFCD3FF90,0xEE66507E,0x56DA371B,
      0x0EB9274D,0xB6054028,0xA4B0EFC6,0x1C0C88A3,0x81DBB01A,0x3967D77F,0x2BD27891,0x936E1FF4,
      0x3B26F703,0x839A9066,0x912F3F88,0x299358ED,0xB4446054,0x0CF80731,0x1E4DA8DF,0xA6F1CFBA,
      0xFE92DFEC,0x462EB889,0x549B1767,0xEC277002,0x71F048BB,0xC94C2FDE,0xDBF98030,0x6345E755,
      0x6B3FA09C,0xD383C7F9,0xC1366817,0x798A0F72,0xE45D37CB,0x5CE150AE,0x4E54FF40,0xF6E89825,
      0xAE8B8873,0x1637EF16,0x048240F8,0xBC3E279D,0x21E91F24,0x99557841,0x8BE0D7AF,0x335CB0CA,
      0xED59B63B,0x55E5D15E,0x47507EB0,0xFFEC19D5,0x623B216C,0xDA874609,0xC832E9E7,0x708E8E82,
      0x28ED9ED4,0x9051F9B1,0x82E4565F,0x3A58313A,0xA78F0983,0x1F336EE6,0x0D86C108,0xB53AA66D,
      0xBD40E1A4,0x05FC86C1,0x1749292F,0xAFF54E4A,0x322276F3,0x8A9E1196,0x982BBE78,0x2097D91D,
      0x78F4C94B,0xC048AE2E,0xD2FD01C0,0x6A4166A5,0xF7965E1C,0x4F2A3979,0x5D9F9697,0xE523F1F2,
      0x4D6B1905,0xF5D77E60,0xE762D18E,0x5FDEB6EB,0xC2098E52,0x7AB5E937,0x680046D9,0xD0BC21BC,
      0x88DF31EA,0x3063568F,0x22D6F961,0x9A6A9E04,0x07BDA6BD,0xBF01C1D8,0xADB46E36,0x15080953,
      0x1D724E9A,0xA5CE29FF,0xB77B8611,0x0FC7E174,0x9210D9CD,0x2AACBEA8,0x38191146,0x80A57623,
      0xD8C66675,0x607A0110,0x72CFAEFE,0xCA73C99B,0x57A4F122,0xEF189647,0xFDAD39A9,0x45115ECC,
      0x764DEE06,0xCEF18963,0xDC44268D,0x64F841E8,0xF92F7951,0x41931E34,0x5326B1DA,0xEB9AD6BF,
      0xB3F9C6E9,0x0B45A18C,0x19F00E62,0xA14C6907,0x3C9B51BE,0x842736DB,0x96929935,0x2E2EFE50,
      0x2654B999,0x9EE8DEFC,0x8C5D7112,0x34E11677,0xA9362ECE,0x118A49AB,0x033FE645,0xBB838120,
      0xE3E09176,0x5B5CF613,0x49E959FD,0xF1553E98,0x6C820621,0xD43E6144,0xC68BCEAA,0x7E37A9CF,
      0xD67F4138,0x6EC3265D,0x7C7689B3,0xC4CAEED6,0x591DD66F,0xE1A1B10A,0xF3141EE4,0x4BA87981,
      0x13CB69D7,0xAB770EB2,0xB9C2A15C,0x017EC639,0x9CA9FE80,0x241599E5,0x36A0360B,0x8E1C516E,
      0x866616A7,0x3EDA71C2,0x2C6FDE2C,0x94D3B949,0x090481F0,0xB1B8E695,0xA30D497B,0x1BB12E1E,
      0x43D23E48,0xFB6E592D,0xE9DBF6C3,0x516791A6,0xCCB0A91F,0x740CCE7A,0x66B96194,0xDE0506F1 },

    { 0x00000000,0x3D6029B0,0x7AC05360,0x47A07AD0,0xF580A6C0,0xC8E08F70,0x8F40F5A0,0xB220DC10,
      0x30704BC1,0x0D106271,0x4AB018A1,0x77D03111,0xC5F0ED01,0xF890C4B1,0xBF30BE61,0x825097D1,
      0x60E09782,0x5D80BE32,0x1A20C4E2,0x2740ED52,0x95603142,0xA80018F2,0xEFA06222,0xD2C04B92,
      0x5090DC43,0x6DF0F5F3,0x2A508F23,0x1730A693,0xA5107A83,0x98705333,0xDFD029E3,0xE2B00053,
      0xC1C12F04,0xFCA106B4,0xBB017C64,0x866155D4,0x344189C4,0x0921A074,0x4E81DAA4,0x73E1F314,
      0xF1B164C5,0xCCD14D75,0x8B7137A5,0xB6111E15,0x0431C205,0x3951EBB5,0x7EF19165,0x4391B8D5,
      0xA121B886,0x9C419136,0xDBE1EBE6,0xE681C256,0x54A11E46,0x69C137F6,0x2E614D26,0x13016496,
      0x9151F347,0xAC31DAF7,0xEB91A027,0xD6F18997,0x64D15587,0x59B17C37,0x1E1106E7,0x23712F57,
      0x58F35849,0x659371F9,0x22330B29,0x1F532299,0xAD73FE89,0x9013D739,0xD7B3ADE9,0xEAD38459,
      0x68831388,0x55E33A38,0x124340E8,0x2F236958,0x9D03B548,0xA0639CF8,0xE7C3E628,0xDAA3CF98,
      0x3813CFCB,0x0573E67B,0x42D39CAB,0x7FB3B51B,0xCD93690B,0xF0F340BB,0xB7533A6B,0x8A3313DB,
      0x0863840A,0x3503ADBA,0x72A3D76A,0x4FC3FEDA,0xFDE322CA,0xC0830B7A,0x872371AA,0xBA43581A,
      0x9932774D,0xA4525EFD,0xE3F2242D,0xDE920D9D,0x6CB2D18D,0x51D2F83D,0x167282ED,0x2B12AB5D,
      0xA9423C8C,0x9422153C,0xD3826FEC,0xEEE2465C,0x5CC29A4C,0x61A2B3FC,0x2602C92C,0x1B62E09C,
      0xF9D2E0CF,0xC4B2C97F,0x8312B3AF,0xBE729A1F,0x0C52460F,0x31326FBF,0x7692156F,0x4BF23CDF,
      0xC9A2AB0E,0xF4C282BE,0xB362F86E,0x8E02D1DE,0x3C220DCE,0x0142247E,0x46E25EAE,0x7B82771E,
      0xB1E6B092,0x8C869922,0xCB26E3F2,0xF646CA42,0x44661652,0x79063FE2,0x3EA64532,0x03C66C82,
      0x8196FB53,0xBCF6D2E3,0xFB56A833,0xC6368183,0x74165D93,0x49767423,0x0ED60EF3,0x33B62743,
      0xD1062710,0xEC660EA0,0xABC67470,0x96A65DC0,0x248681D0,0x19E6A860,0x5E46D2B0,0x6326FB00,
      0xE1766CD1,0xDC164561,0x9BB63FB1,0xA6D61601,0x14F6CA11,0x2996E3A1,0x6E369971,0x5356B0C1,
      0x70279F96,0x4D47B626,0x0AE7CCF6,0x3787E546,0x85A73956,0xB8C710E6,0xFF676A36,0xC2074386,
      0x4057D457,0x7D37FDE7,0x3A978737,0x07F7AE87,0xB5D77297,0x88B75B27,0xCF1721F7,0xF2770847,
      0x10C70814,0x2DA721A4,0x6A075B74,0x576772C4,0xE547AED4,0xD8278764,0x9F87FDB4,0xA2E7D404,
      0x20B743D5,0x1DD76A65,0x5A7710B5,0x67173905,0xD537E515,0xE857CCA5,0xAFF7B675,0x92979FC5,
      0xE915E8DB,0xD475C16B,0x93D5BBBB,0xAEB5920B,0x1C954E1B,0x21F567AB,0x66551D7B,0x5B3534CB,
      0xD965A31A,0xE4058AAA,0xA3A5F07A,0x9EC5D9CA,0x2CE505DA,0x11852C6A,0x562556BA,0x6B457F0A,
      0x89F57F59,0xB49556E9,0xF3352C39,0xCE550589,0x7C75D999,0x4115F029,0x06B58AF9,0x3BD5A349,
      0xB9853498,0x84E51D28,0xC34567F8,0xFE254E48,0x4C059258,0x7165BBE8,0x36C5C138,0x0BA5E888,
      0x28D4C7DF,0x15B4EE6F,0x521494BF,0x6F74BD0F,0xDD54611F,0xE03448AF,0xA794327F,0x9AF41BCF,
      0x18A48C1E,0x25C4A5AE,0x6264DF7E,0x5F04F6CE,0xED242ADE,0xD044036E,0x97E479BE,0xAA84500E,
      0x4834505D,0x755479ED,0x32F4033D,0x0F942A8D,0xBDB4F69D,0x80D4DF2D,0xC774A5FD,0xFA148C4D,
      0x78441B9C,0x4524322C,0x028448FC,0x3FE4614C,0x8DC4BD5C,0xB0A494EC,0xF704EE3C,0xCA64C78C },

    { 0x00000000,0xCB5CD3A5,0x4DC8A10B,0x869472AE,0x9B914216,0x50CD91B3,0xD659E31D,0x1D0530B8,
      0xEC53826D,0x270F51C8,0xA19B2366,0x6AC7F0C3,0x77C2C07B,0xBC9E13DE,0x3A0A6170,0xF156B2D5,
      0x03D6029B,0xC88AD13E,0x4E1EA390,0x85427035,0x9847408D,0x531B9328,0xD58FE186,0x1ED33223,
      0xEF8580F6,0x24D95353,0xA24D21FD,0x6911F258,0x7414C2E0,0xBF481145,0x39DC63EB,0xF280B04E,
      0x07AC0536,0xCCF0D693,0x4A64A43D,0x81387798,0x9C3D4720,0x57619485,0xD1F5E62B,0x1AA9358E,
      0xEBFF875B,0x20A354FE,0xA6372650,0x6D6BF5F5,0x706EC54D,0xBB3216E8,0x3DA66446,0xF6FAB7E3,
      0x047A07AD,0xCF26D408,0x49B2A6A6,0x82EE7503,0x9FEB45BB,0x54B7961E,0xD223E4B0,0x197F3715,
      0xE82985C0,0x23755665,0xA5E124CB,0x6EBDF76E,0x73B8C7D6,0xB8E41473,0x3E7066DD,0xF52CB578,
      0x0F580A6C,0xC404D9C9,0x4290AB67,0x89CC78C2,0x94C9487A,0x5F959BDF,0xD901E971,0x125D3AD4,
      0xE30B8801,0x28575BA4,0xAEC3290A,0x659FFAAF,0x789ACA17,0xB3C619B2,0x35526B1C,0xFE0EB8B9,
      0x0C8E08F7,0xC7D2DB52,0x4146A9FC,0x8A1A7A59,0x971F4AE1,0x5C439944,0xDAD7EBEA,0x118B384F,
      0xE0DD8A9A,0x2B81593F,0xAD152B91,0x6649F834,0x7B4CC88C,0xB0101B29,0x36846987,0xFDD8BA22,
      0x08F40F5A,0xC3A8DCFF,0x453CAE51,0x8E607DF4,0x93654D4C,0x58399EE9,0xDEADEC47,0x15F13FE2,
      0xE4A78D37,0x2FFB5E92,0xA96F2C3C,0x6233FF99,0x7F36CF21,0xB46A1C84,0x32FE6E2A,0xF9A2BD8F,
      0x0B220DC1,0xC07EDE64,0x46EAACCA,0x8DB67F6F,0x90B34FD7,0x5BEF9C72,0xDD7BEEDC,0x16273D79,
      0xE7718FAC,0x2C2D5C09,0xAAB92EA7,0x61E5FD02,0x7CE0CDBA,0xB7BC1E1F,0x31286CB1,0xFA74BF14,
      0x1EB014D8,0xD5ECC77D,0x5378B5D3,0x98246676,0x852156CE,0x4E7D856B,0xC8E9F7C5,0x03B52460,
      0xF2E396B5,0x39BF4510,0xBF2B37BE,0x7477E41B,0x6972D4A3,0xA22E0706,0x24BA75A8,0xEFE6A60D,
      0x1D661643,0xD63AC5E6,0x50AEB748,0x9BF264ED,0x86F75455,0x4DAB87F0,0xCB3FF55E,0x006326FB,
      0xF135942E,0x3A69478B,0xBCFD3525,0x77A1E680,0x6AA4D638,0xA1F8059D,0x276C7733,0xEC30A496,
      0x191C11EE,0xD240C24B,0x54D4B0E5,0x9F886340,0x828D53F8,0x49D1805D,0xCF45F2F3,0x04192156,
      0xF54F9383,0x3E134026,0xB8873288,0x73DBE12D,0x6EDED195,0xA5820230,0x2316709E,0xE84AA33B,
      0x1ACA1375,0xD196C0D0,0x5702B27E,0x9C5E61DB,0x815B5163,0x4A0782C6,0xCC93F068,0x07CF23CD,
      0xF6999118,0x3DC542BD,0xBB513013,0x700DE3B6,0x6D08D30E,0xA65400AB,0x20C07205,0xEB9CA1A0,
      0x11E81EB4,0xDAB4CD11,0x5C20BFBF,0x977C6C1A,0x8A795CA2,0x41258F07,0xC7B1FDA9,0x0CED2E0C,
      0xFDBB9CD9,0x36E74F7C,0xB0733DD2,0x7B2FEE77,0x662ADECF,0xAD760D6A,0x2BE27FC4,0xE0BEAC61,
      0x123E1C2F,0xD962CF8A,0x5FF6BD24,0x94AA6E81,0x89AF5E39,0x42F38D9C,0xC467FF32,0x0F3B2C97,
      0xFE6D9E42,0x35314DE7,0xB3A53F49,0x78F9ECEC,0x65FCDC54,0xAEA00FF1,0x28347D5F,0xE368AEFA,
      0x16441B82,0xDD18C827,0x5B8CBA89,0x90D0692C,0x8DD55994,0x46898A31,0xC01DF89F,0x0B412B3A,
      0xFA1799EF,0x314B4A4A,0xB7DF38E4,0x7C83EB41,0x6186DBF9,0xAADA085C,0x2C4E7AF2,0xE712A957,
      0x15921919,0xDECECABC,0x585AB812,0x93066BB7,0x8E035B0F,0x455F88AA,0xC3CBFA04,0x089729A1,
      0xF9C19B74,0x329D48D1,0xB4093A7F,0x7F55E9DA,0x6250D962,0xA90C0AC7,0x2F987869,0xE4C4ABCC },

    { 0x00000000,0xA6770BB4,0x979F1129,0x31E81A9D,0xF44F2413,0x52382FA7,0x63D0353A,0xC5A73E8E,
      0x33EF4E67,0x959845D3,0xA4705F4E,0x020754FA,0xC7A06A74,0x61D761C0,0x503F7B5D,0xF64870E9,
      0x67DE9CCE,0xC1A9977A,0xF0418DE7,0x56368653,0x9391B8DD,0x35E6B369,0x040EA9F4,0xA279A240,
      0x5431D2A9,0xF246D91D,0xC3AEC380,0x65D9C834,0xA07EF6BA,0x0609FD0E,0x37E1E793,0x9196EC27,
      0xCFBD399C,0x69CA3228,0x582228B5,0xFE552301,0x3BF21D8F,0x9D85163B,0xAC6D0CA6,0x0A1A0712,
      0xFC5277FB,0x5A257C4F,0x6BCD66D2,0xCDBA6D66,0x081D53E8,0xAE6A585C,0x9F8242C1,0x39F54975,
      0xA863A552,0x0E14AEE6,0x3FFCB47B,0x998BBFCF,0x5C2C8141,0xFA5B8AF5,0xCBB39068,0x6DC49BDC,
      0x9B8CEB35,0x3DFBE081,0x0C13FA1C,0xAA64F1A8,0x6FC3CF26,0xC9B4C492,0xF85CDE0F,0x5E2BD5BB,
      0x440B7579,0xE27C7ECD,0xD3946450,0x75E36FE4,0xB044516A,0x16335ADE,0x27DB4043,0x81AC4BF7,
      0x77E43B1E,0xD19330AA,0xE07B2A37,0x460C2183,0x83AB1F0D,0x25DC14B9,0x14340E24,0xB2430590,
      0x23D5E9B7,0x85A2E203,0xB44AF89E,0x123DF32A,0xD79ACDA4,0x71EDC610,0x4005DC8D,0xE672D739,
      0x103AA7D0,0xB64DAC64,0x87A5B6F9,0x21D2BD4D,0xE47583C3,0x42028877,0x73EA92EA,0xD59D995E,
      0x8BB64CE5,0x2DC14751,0x1C295DCC,0xBA5E5678,0x7FF968F6,0xD98E6342,0xE86679DF,0x4E11726B,
      0xB8590282,0x1E2E0936,0x2FC613AB,0x89B1181F,0x4C162691,0xEA612D25,0xDB8937B8,0x7DFE3C0C,
      0xEC68D02B,0x4A1FDB9F,0x7BF7C102,0xDD80CAB6,0x1827F438,0xBE50FF8C,0x8FB8E511,0x29CFEEA5,
      0xDF879E4C,0x79F095F8,0x48188F65,0xEE6F84D1,0x2BC8BA5F,0x8DBFB1EB,0xBC57AB76,0x1A20A0C2,
      0x8816EAF2,0x2E61E146,0x1F89FBDB,0xB9FEF06F,0x7C59CEE1,0xDA2EC555,0xEBC6DFC8,0x4DB1D47C,
      0xBBF9A495,0x1D8EAF21,0x2C66B5BC,0x8A11BE08,0x4FB68086,0xE9C18B32,0xD82991AF,0x7E5E9A1B,
      0xEFC8763C,0x49BF7D88,0x78576715,0xDE206CA1,0x1B87522F,0xBDF0599B,0x8C184306,0x2A6F48B2,
      0xDC27385B,0x7A5033EF,0x4BB82972,0xEDCF22C6,0x28681C48,0x8E1F17FC,0xBFF70D61,0x198006D5,
      0x47ABD36E,0xE1DCD8DA,0xD034C247,0x7643C9F3,0xB3E4F77D,0x1593FCC9,0x247BE654,0x820CEDE0,
      0x74449D09,0xD23396BD,0xE3DB8C20,0x45AC8794,0x800BB91A,0x267CB2AE,0x1794A833,0xB1E3A387,
      0x20754FA0,0x86024414,0xB7EA5E89,0x119D553D,0xD43A6BB3,0x724D6007,0x43A57A9A,0xE5D2712E,
      0x139A01C7,0xB5ED0A73,0x840510EE,0x22721B5A,0xE7D525D4,0x41A22E60,0x704A34FD,0xD63D3F49,
      0xCC1D9F8B,0x6A6A943F,0x5B828EA2,0xFDF58516,0x3852BB98,0x9E25B02C,0xAFCDAAB1,0x09BAA105,
      0xFFF2D1EC,0x5985DA58,0x686DC0C5,0xCE1ACB71,0x0BBDF5FF,0xADCAFE4B,0x9C22E4D6,0x3A55EF62,
      0xABC30345,0x0DB408F1,0x3C5C126C,0x9A2B19D8,0x5F8C2756,0xF9FB2CE2,0xC813367F,0x6E643DCB,
      0x982C4D22,0x3E5B4696,0x0FB35C0B,0xA9C457BF,0x6C636931,0xCA146285,0xFBFC7818,0x5D8B73AC,
      0x03A0A617,0xA5D7ADA3,0x943FB73E,0x3248BC8A,0xF7EF8204,0x519889B0,0x6070932D,0xC6079899,
      0x304FE870,0x9638E3C4,0xA7D0F959,0x01A7F2ED,0xC400CC63,0x6277C7D7,0x539FDD4A,0xF5E8D6FE,
      0x647E3AD9,0xC209316D,0xF3E12BF0,0x55962044,0x90311ECA,0x3646157E,0x07AE0FE3,0xA1D90457,
      0x579174BE,0xF1E67F0A,0xC00E6597,0x66796E23,0xA3DE50AD,0x05A95B19,0x34414184,0x92364A30 },

    { 0x00000000,0xCCAA009E,0x4225077D,0x8E8F07E3,0x844A0EFA,0x48E00E64,0xC66F0987,0x0AC50919,
      0xD3E51BB5,0x1F4F1B2B,0x91C01CC8,0x5D6A1C56,0x57AF154F,0x9B0515D1,0x158A1232,0xD92012AC,
      0x7CBB312B,0xB01131B5,0x3E9E3656,0xF23436C8,0xF8F13FD1,0x345B3F4F,0xBAD438AC,0x767E3832,
      0xAF5E2A9E,0x63F42A00,0xED7B2DE3,0x21D12D7D,0x2B142464,0xE7BE24FA,0x69312319,0xA59B2387,
      0xF9766256,0x35DC62C8,0xBB53652B,0x77F965B5,0x7D3C6CAC,0xB1966C32,0x3F196BD1,0xF3B36B4F,
      0x2A9379E3,0xE639797D,0x68B67E9E,0xA41C7E00,0xAED97719,0x62737787,0xECFC7064,0x205670FA,
      0x85CD537D,0x496753E3,0xC7E85400,0x0B42549E,0x01875D87,0xCD2D5D19,0x43A25AFA,0x8F085A64,
      0x562848C8,0x9A824856,0x140D4FB5,0xD8A74F2B,0xD2624632,0x1EC846AC,0x9047414F,0x5CED41D1,
      0x299DC2ED,0xE537C273,0x6BB8C590,0xA712C50E,0xADD7CC17,0x617DCC89,0xEFF2CB6A,0x2358CBF4,
      0xFA78D958,0x36D2D9C6,0xB85DDE25,0x74F7DEBB,0x7E32D7A2,0xB298D73C,0x3C17D0DF,0xF0BDD041,
      0x5526F3C6,0x998CF358,0x1703F4BB,0xDBA9F425,0xD16CFD3C,0x1DC6FDA2,0x9349FA41,0x5FE3FADF,
      0x86C3E873,0x4A69E8ED,0xC4E6EF0E,0x084CEF90,0x0289E689,0xCE23E617,0x40ACE1F4,0x8C06E16A,
      0xD0EBA0BB,0x1C41A025,0x92CEA7C6,0x5E64A758,0x54A1AE41,0x980BAEDF,0x1684A93C,0xDA2EA9A2,
      0x030EBB0E,0xCFA4BB90,0x412BBC73,0x8D81BCED,0x8744B5F4,0x4BEEB56A,0xC561B289,0x09CBB217,
      0xAC509190,0x60FA910E,0xEE7596ED,0x22DF9673,0x281A9F6A,0xE4B09FF4,0x6A3F9817,0xA6959889,
      0x7FB58A25,0xB31F8ABB,0x3D908D58,0xF13A8DC6,0xFBFF84DF,0x37558441,0xB9DA83A2,0x7570833C,
      0x533B85DA,0x9F918544,0x111E82A7,0xDDB48239,0xD7718B20,0x1BDB8BBE,0x95548C5D,0x59FE8CC3,
      0x80DE9E6F,0x4C749EF1,0xC2FB9912,0x0E51998C,0x04949095,0xC83E900B,0x46B197E8,0x8A1B9776,
      0x2F80B4F1,0xE32AB46F,0x6DA5B38C,0xA10FB312,0xABCABA0B,0x6760BA95,0xE9EFBD76,0x2545BDE8,
      0xFC65AF44,0x30CFAFDA,0xBE40A839,0x72EAA8A7,0x782FA1BE,0xB485A120,0x3A0AA6C3,0xF6A0A65D,
      0xAA4DE78C,0x66E7E712,0xE868E0F1,0x24C2E06F,0x2E07E976,0xE2ADE9E8,0x6C22EE0B,0xA088EE95,
      0x79A8FC39,0xB502FCA7,0x3B8DFB44,0xF727FBDA,0xFDE2F2C3,0x3148F25D,0xBFC7F5BE,0x736DF520,
      0xD6F6D6A7,0x1A5CD639,0x94D3D1DA,0x5879D144,0x52BCD85D,0x9E16D8C3,0x1099DF20,0xDC33DFBE,
      0x0513CD12,0xC9B9CD8C,0x4736CA6F,0x8B9CCAF1,0x8159C3E8,0x4DF3C376,0xC37CC495,0x0FD6C40B,
      0x7AA64737,0xB60C47A9,0x3883404A,0xF42940D4,0xFEEC49CD,0x32464953,0xBCC94EB0,0x70634E2E,
      0xA9435C82,0x65E95C1C,0xEB665BFF,0x27CC5B61,0x2D095278,0xE1A352E6,0x6F2C5505,0xA386559B,
      0x061D761C,0xCAB77682,0x44387161,0x889271FF,0x825778E6,0x4EFD7878,0xC0727F9B,0x0CD87F05,
      0xD5F86DA9,0x19526D37,0x97DD6AD4,0x5B776A4A,0x51B26353,0x9D1863CD,0x1397642E,0xDF3D64B0,
      0x83D02561,0x4F7A25FF,0xC1F5221C,0x0D5F2282,0x079A2B9B,0xCB302B05,0x45BF2CE6,0x89152C78,
      0x50353ED4,0x9C9F3E4A,0x121039A9,0xDEBA3937,0xD47F302E,0x18D530B0,0x965A3753,0x5AF037CD,
      0xFF6B144A,0x33C114D4,0xBD4E1337,0x71E413A9,0x7B211AB0,0xB78B1A2E,0x39041DCD,0xF5AE1D53,
      0x2C8E0FFF,0xE0240F61,0x6EAB0882,0xA201081C,0xA8C40105,0x646E019B,0xEAE10678,0x264B06E6 }
  };

  inline uint32_t swap(uint32_t x)
  {
#if defined(__GNUC__) || defined(__clang__)
    return __builtin_bswap32(x);
#endif
#ifdef MSC_VER
    return _byteswap_ulong(x);
#endif

    return (x >> 24) |
          ((x >>  8) & 0x0000FF00) |
          ((x <<  8) & 0x00FF0000) |
           (x << 24);
  }
}


/// add arbitrary number of bytes
void CRC32::add(const void* data, size_t numBytes)
{
  uint32_t* current = (uint32_t*) data;
  uint32_t crc = ~m_hash;

  // process eight bytes at once
  while (numBytes >= 8)
  {
#if defined(__BYTE_ORDER) && (__BYTE_ORDER != 0) && (__BYTE_ORDER == __BIG_ENDIAN)
    uint32_t one = *current++ ^ swap(crc);
    uint32_t two = *current++;
    crc  = crc32Lookup[7][ one>>24        ] ^
           crc32Lookup[6][(one>>16) & 0xFF] ^
           crc32Lookup[5][(one>> 8) & 0xFF] ^
           crc32Lookup[4][ one      & 0xFF] ^
           crc32Lookup[3][ two>>24        ] ^
           crc32Lookup[2][(two>>16) & 0xFF] ^
           crc32Lookup[1][(two>> 8) & 0xFF] ^
           crc32Lookup[0][ two      & 0xFF];
#else
    uint32_t one = *current++ ^ crc;
    uint32_t two = *current++;
    crc  = crc32Lookup[7][ one      & 0xFF] ^
           crc32Lookup[6][(one>> 8) & 0xFF] ^
           crc32Lookup[5][(one>>16) & 0xFF] ^
           crc32Lookup[4][ one>>24        ] ^
           crc32Lookup[3][ two      & 0xFF] ^
           crc32Lookup[2][(two>> 8) & 0xFF] ^
           crc32Lookup[1][(two>>16) & 0xFF] ^
           crc32Lookup[0][ two>>24        ];
#endif
    numBytes -= 8;
  }

  unsigned char* currentChar = (unsigned char*) current;
  // remaining 1 to 7 bytes (standard CRC table-based algorithm)
  while (numBytes--)
    crc = (crc >> 8) ^ crc32Lookup[0][(crc & 0xFF) ^ *currentChar++];

  m_hash = ~crc;
}


/// return latest hash as 8 hex characters
std::string CRC32::getHash()
{
  // convert hash to string
  static const char dec2hex[16+1] = "0123456789abcdef";

  char hashBuffer[8+1];

  hashBuffer[0] = dec2hex[ m_hash >> 28      ];
  hashBuffer[1] = dec2hex[(m_hash >> 24) & 15];
  hashBuffer[2] = dec2hex[(m_hash >> 20) & 15];
  hashBuffer[3] = dec2hex[(m_hash >> 16) & 15];
  hashBuffer[4] = dec2hex[(m_hash >> 12) & 15];
  hashBuffer[5] = dec2hex[(m_hash >>  8) & 15];
  hashBuffer[6] = dec2hex[(m_hash >>  4) & 15];
  hashBuffer[7] = dec2hex[ m_hash        & 15];
  // zero-terminated string
  hashBuffer[8] = 0;

  // convert to std::string
  return hashBuffer;
}


/// return latest hash as bytes
void CRC32::getHash(unsigned char buffer[CRC32::HashBytes])
{
  buffer[0] = (m_hash >> 24) & 0xFF;
  buffer[1] = (m_hash >> 16) & 0xFF;
  buffer[2] = (m_hash >>  8) & 0xFF;
  buffer[3] =  m_hash        & 0xFF;
}


/// compute CRC32 of a memory block
std::string CRC32::operator()(const void* data, size_t numBytes)
{
  reset();
  add(data, numBytes);
  return getHash();
}


/// compute CRC32 of a string, excluding final zero
std::string CRC32::operator()(const std::string& text)
{
  reset();
  add(text.c_str(), text.size());
  return getHash();
}
// //////////////////////////////////////////////////////////
// digest.cpp
// Copyright (c) 2014,2015 Stephan Brumme. All rights reserved.
// see http://create.stephan-brumme.com/disclaimer.html
//

// g++ -O3 digest.cpp crc32.cpp md5.cpp sha1.cpp sha256.cpp keccak.cpp sha3.cpp -o digest

#include "crc32.h"
#include "md5.h"
#include "sha1.h"
#include "sha256.h"
#include "keccak.h"
#include "sha3.h"

#include <iostream>
#include <fstream>


int main(int argc, char** argv)
{
  // syntax check
  if (argc < 2 || argc > 3)
  {
    std::cout << "./digest filename [--crc|--md5|--sha1|--sha256|--keccak|--sha3]" << std::endl;
    return 1;
  }

  // parameters
  std::string filename  = argv[1];
  std::string algorithm = argc == 3 ? argv[2] : "";
  bool computeCrc32     = algorithm.empty() || algorithm == "--crc";
  bool computeMd5       = algorithm.empty() || algorithm == "--md5";
  bool computeSha1      = algorithm.empty() || algorithm == "--sha1";
  bool computeSha2      = algorithm.empty() || algorithm == "--sha2" || algorithm == "--sha256";
  bool computeKeccak    = algorithm.empty() || algorithm == "--keccak";
  bool computeSha3      = algorithm.empty() || algorithm == "--sha3";

  CRC32  digestCrc32;
  MD5    digestMd5;
  SHA1   digestSha1;
  SHA256 digestSha2;
  Keccak digestKeccak(Keccak::Keccak256);
  SHA3   digestSha3  (SHA3  ::Bits256);

  // each cycle processes about 1 MByte (divisible by 144 => improves Keccak/SHA3 performance)
  const size_t BufferSize = 144*7*1024;
  char* buffer = new char[BufferSize];

  // select input source: either file or standard-in
  std::ifstream file;
  std::istream* input = NULL;
  // accept std::cin, syntax will be: "./digest - --sha3 < data"
  if (filename == "-")
  {
    input = &std::cin;
  }
  else
  {
    // open file
    file.open(filename.c_str(), std::ios::in | std::ios::binary);
    if (!file)
    {
      std::cerr << "Can't open '" << filename << "'" << std::endl;
      return 2;
    }

    input = &file;
  }

  // process file
  while (*input)
  {
    input->read(buffer, BufferSize);
    std::size_t numBytesRead = size_t(input->gcount());

    if (computeCrc32)
      digestCrc32 .add(buffer, numBytesRead);
    if (computeMd5)
      digestMd5   .add(buffer, numBytesRead);
    if (computeSha1)
      digestSha1  .add(buffer, numBytesRead);
    if (computeSha2)
      digestSha2  .add(buffer, numBytesRead);
    if (computeKeccak)
      digestKeccak.add(buffer, numBytesRead);
    if (computeSha3)
      digestSha3  .add(buffer, numBytesRead);
  }

  // clean up
  file.close();
  delete[] buffer;

  // show results
  if (computeCrc32)
    std::cout << "CRC32:      " << digestCrc32 .getHash() << std::endl;
  if (computeMd5)
    std::cout << "MD5:        " << digestMd5   .getHash() << std::endl;
  if (computeSha1)
    std::cout << "SHA1:       " << digestSha1  .getHash() << std::endl;
  if (computeSha2)
    std::cout << "SHA2/256:   " << digestSha2  .getHash() << std::endl;
  if (computeKeccak)
    std::cout << "Keccak/256: " << digestKeccak.getHash() << std::endl;
  if (computeSha3)
    std::cout << "SHA3/256:   " << digestSha3  .getHash() << std::endl;

  return 0;
}
// //////////////////////////////////////////////////////////
// keccak.cpp
// Copyright (c) 2014,2015 Stephan Brumme. All rights reserved.
// see http://create.stephan-brumme.com/disclaimer.html
//

#include "keccak.h"

// big endian architectures need #define __BYTE_ORDER __BIG_ENDIAN
#ifndef _MSC_VER
#include <endian.h>
#endif


/// same as reset()
Keccak::Keccak(Bits bits)
: m_blockSize(200 - 2 * (bits / 8)),
  m_bits(bits)
{
  reset();
}


/// restart
void Keccak::reset()
{
  for (size_t i = 0; i < StateSize; i++)
    m_hash[i] = 0;

  m_numBytes   = 0;
  m_bufferSize = 0;
}


/// constants and local helper functions
namespace
{
  const unsigned int KeccakRounds = 24;
  const uint64_t XorMasks[KeccakRounds] =
  {
    0x0000000000000001ULL, 0x0000000000008082ULL, 0x800000000000808aULL,
    0x8000000080008000ULL, 0x000000000000808bULL, 0x0000000080000001ULL,
    0x8000000080008081ULL, 0x8000000000008009ULL, 0x000000000000008aULL,
    0x0000000000000088ULL, 0x0000000080008009ULL, 0x000000008000000aULL,
    0x000000008000808bULL, 0x800000000000008bULL, 0x8000000000008089ULL,
    0x8000000000008003ULL, 0x8000000000008002ULL, 0x8000000000000080ULL,
    0x000000000000800aULL, 0x800000008000000aULL, 0x8000000080008081ULL,
    0x8000000000008080ULL, 0x0000000080000001ULL, 0x8000000080008008ULL
  };

  /// rotate left and wrap around to the right
  inline uint64_t rotateLeft(uint64_t x, uint8_t numBits)
  {
    return (x << numBits) | (x >> (64 - numBits));
  }

  /// convert litte vs big endian
  inline uint64_t swap(uint64_t x)
  {
#if defined(__GNUC__) || defined(__clang__)
    return __builtin_bswap64(x);
#endif
#ifdef _MSC_VER
    return _byteswap_uint64(x);
#endif

    return  (x >> 56) |
           ((x >> 40) & 0x000000000000FF00ULL) |
           ((x >> 24) & 0x0000000000FF0000ULL) |
           ((x >>  8) & 0x00000000FF000000ULL) |
           ((x <<  8) & 0x000000FF00000000ULL) |
           ((x << 24) & 0x0000FF0000000000ULL) |
           ((x << 40) & 0x00FF000000000000ULL) |
            (x << 56);
  }


  /// return x % 5 for 0 <= x <= 9
  unsigned int mod5(unsigned int x)
  {
    if (x < 5)
      return x;

    return x - 5;
  }
}


/// process a full block
void Keccak::processBlock(const void* data)
{
#if defined(__BYTE_ORDER) && (__BYTE_ORDER != 0) && (__BYTE_ORDER == __BIG_ENDIAN)
#define LITTLEENDIAN(x) swap(x)
#else
#define LITTLEENDIAN(x) (x)
#endif

  const uint64_t* data64 = (const uint64_t*) data;
  // mix data into state
  for (unsigned int i = 0; i < m_blockSize / 8; i++)
    m_hash[i] ^= LITTLEENDIAN(data64[i]);

  // re-compute state
  for (unsigned int round = 0; round < KeccakRounds; round++)
  {
    // Theta
    uint64_t coefficients[5];
    for (unsigned int i = 0; i < 5; i++)
      coefficients[i] = m_hash[i] ^ m_hash[i + 5] ^ m_hash[i + 10] ^ m_hash[i + 15] ^ m_hash[i + 20];

    for (unsigned int i = 0; i < 5; i++)
    {
      uint64_t one = coefficients[mod5(i + 4)] ^ rotateLeft(coefficients[mod5(i + 1)], 1);
      m_hash[i     ] ^= one;
      m_hash[i +  5] ^= one;
      m_hash[i + 10] ^= one;
      m_hash[i + 15] ^= one;
      m_hash[i + 20] ^= one;
    }

    // temporary
    uint64_t one;

    // Rho Pi
    uint64_t last = m_hash[1];
    one = m_hash[10]; m_hash[10] = rotateLeft(last,  1); last = one;
    one = m_hash[ 7]; m_hash[ 7] = rotateLeft(last,  3); last = one;
    one = m_hash[11]; m_hash[11] = rotateLeft(last,  6); last = one;
    one = m_hash[17]; m_hash[17] = rotateLeft(last, 10); last = one;
    one = m_hash[18]; m_hash[18] = rotateLeft(last, 15); last = one;
    one = m_hash[ 3]; m_hash[ 3] = rotateLeft(last, 21); last = one;
    one = m_hash[ 5]; m_hash[ 5] = rotateLeft(last, 28); last = one;
    one = m_hash[16]; m_hash[16] = rotateLeft(last, 36); last = one;
    one = m_hash[ 8]; m_hash[ 8] = rotateLeft(last, 45); last = one;
    one = m_hash[21]; m_hash[21] = rotateLeft(last, 55); last = one;
    one = m_hash[24]; m_hash[24] = rotateLeft(last,  2); last = one;
    one = m_hash[ 4]; m_hash[ 4] = rotateLeft(last, 14); last = one;
    one = m_hash[15]; m_hash[15] = rotateLeft(last, 27); last = one;
    one = m_hash[23]; m_hash[23] = rotateLeft(last, 41); last = one;
    one = m_hash[19]; m_hash[19] = rotateLeft(last, 56); last = one;
    one = m_hash[13]; m_hash[13] = rotateLeft(last,  8); last = one;
    one = m_hash[12]; m_hash[12] = rotateLeft(last, 25); last = one;
    one = m_hash[ 2]; m_hash[ 2] = rotateLeft(last, 43); last = one;
    one = m_hash[20]; m_hash[20] = rotateLeft(last, 62); last = one;
    one = m_hash[14]; m_hash[14] = rotateLeft(last, 18); last = one;
    one = m_hash[22]; m_hash[22] = rotateLeft(last, 39); last = one;
    one = m_hash[ 9]; m_hash[ 9] = rotateLeft(last, 61); last = one;
    one = m_hash[ 6]; m_hash[ 6] = rotateLeft(last, 20); last = one;
                      m_hash[ 1] = rotateLeft(last, 44);

    // Chi
    for (unsigned int j = 0; j < 25; j += 5)
    {
      // temporaries
      uint64_t one = m_hash[j];
      uint64_t two = m_hash[j + 1];

      m_hash[j]     ^= m_hash[j + 2] & ~two;
      m_hash[j + 1] ^= m_hash[j + 3] & ~m_hash[j + 2];
      m_hash[j + 2] ^= m_hash[j + 4] & ~m_hash[j + 3];
      m_hash[j + 3] ^=      one      & ~m_hash[j + 4];
      m_hash[j + 4] ^=      two      & ~one;
    }

    // Iota
    m_hash[0] ^= XorMasks[round];
  }
}


/// add arbitrary number of bytes
void Keccak::add(const void* data, size_t numBytes)
{
  const uint8_t* current = (const uint8_t*) data;

  if (m_bufferSize > 0)
  {
    while (numBytes > 0 && m_bufferSize < m_blockSize)
    {
      m_buffer[m_bufferSize++] = *current++;
      numBytes--;
    }
  }

  // full buffer
  if (m_bufferSize == m_blockSize)
  {
    processBlock((void*)m_buffer);
    m_numBytes  += m_blockSize;
    m_bufferSize = 0;
  }

  // no more data ?
  if (numBytes == 0)
    return;

  // process full blocks
  while (numBytes >= m_blockSize)
  {
    processBlock(current);
    current    += m_blockSize;
    m_numBytes += m_blockSize;
    numBytes   -= m_blockSize;
  }

  // keep remaining bytes in buffer
  while (numBytes > 0)
  {
    m_buffer[m_bufferSize++] = *current++;
    numBytes--;
  }
}


/// process everything left in the internal buffer
void Keccak::processBuffer()
{
  unsigned int blockSize = 200 - 2 * (m_bits / 8);

  // add padding
  size_t offset = m_bufferSize;
  // add a "1" byte
  m_buffer[offset++] = 1;
  // fill with zeros
  while (offset < blockSize)
    m_buffer[offset++] = 0;

  // and add a single set bit
  m_buffer[blockSize - 1] |= 0x80;

  processBlock(m_buffer);
}


/// return latest hash as 16 hex characters
std::string Keccak::getHash()
{
  // process remaining bytes
  processBuffer();

  // convert hash to string
  static const char dec2hex[16 + 1] = "0123456789abcdef";

  // number of significant elements in hash (uint64_t)
  unsigned int hashLength = m_bits / 64;

  std::string result;
  for (unsigned int i = 0; i < hashLength; i++)
    for (unsigned int j = 0; j < 8; j++) // 64 bits => 8 bytes
    {
      // convert a byte to hex
      unsigned char oneByte = (unsigned char) (m_hash[i] >> (8 * j));
      result += dec2hex[oneByte >> 4];
      result += dec2hex[oneByte & 15];
    }

  // Keccak224's last entry in m_hash provides only 32 bits instead of 64 bits
  unsigned int remainder = m_bits - hashLength * 64;
  unsigned int processed = 0;
  while (processed < remainder)
  {
    // convert a byte to hex
    unsigned char oneByte = (unsigned char) (m_hash[hashLength] >> processed);
    result += dec2hex[oneByte >> 4];
    result += dec2hex[oneByte & 15];

    processed += 8;
  }

  return result;
}


/// compute Keccak hash of a memory block
std::string Keccak::operator()(const void* data, size_t numBytes)
{
  reset();
  add(data, numBytes);
  return getHash();
}


/// compute Keccak hash of a string, excluding final zero
std::string Keccak::operator()(const std::string& text)
{
  reset();
  add(text.c_str(), text.size());
  return getHash();
}
// //////////////////////////////////////////////////////////
// md5.cpp
// Copyright (c) 2014,2015 Stephan Brumme. All rights reserved.
// see http://create.stephan-brumme.com/disclaimer.html
//

#include "md5.h"

#ifndef _MSC_VER
#include <endian.h>
#endif


/// same as reset()
MD5::MD5()
{
  reset();
}


/// restart
void MD5::reset()
{
  m_numBytes   = 0;
  m_bufferSize = 0;

  // according to RFC 1321
  m_hash[0] = 0x67452301;
  m_hash[1] = 0xefcdab89;
  m_hash[2] = 0x98badcfe;
  m_hash[3] = 0x10325476;
}


namespace
{
  // mix functions for processBlock()
  inline uint32_t f1(uint32_t b, uint32_t c, uint32_t d)
  {
    return d ^ (b & (c ^ d)); // original: f = (b & c) | ((~b) & d);
  }

  inline uint32_t f2(uint32_t b, uint32_t c, uint32_t d)
  {
    return c ^ (d & (b ^ c)); // original: f = (b & d) | (c & (~d));
  }

  inline uint32_t f3(uint32_t b, uint32_t c, uint32_t d)
  {
    return b ^ c ^ d;
  }

  inline uint32_t f4(uint32_t b, uint32_t c, uint32_t d)
  {
    return c ^ (b | ~d);
  }

  inline uint32_t rotate(uint32_t a, uint32_t c)
  {
    return (a << c) | (a >> (32 - c));
  }

#if defined(__BYTE_ORDER) && (__BYTE_ORDER != 0) && (__BYTE_ORDER == __BIG_ENDIAN)
  inline uint32_t swap(uint32_t x)
  {
#if defined(__GNUC__) || defined(__clang__)
    return __builtin_bswap32(x);
#endif
#ifdef MSC_VER
    return _byteswap_ulong(x);
#endif

    return (x >> 24) |
          ((x >>  8) & 0x0000FF00) |
          ((x <<  8) & 0x00FF0000) |
           (x << 24);
  }
#endif
}


/// process 64 bytes
void MD5::processBlock(const void* data)
{
  // get last hash
  uint32_t a = m_hash[0];
  uint32_t b = m_hash[1];
  uint32_t c = m_hash[2];
  uint32_t d = m_hash[3];

  // data represented as 16x 32-bit words
  const uint32_t* words = (uint32_t*) data;

  // computations are little endian, swap data if necessary
#if defined(__BYTE_ORDER) && (__BYTE_ORDER != 0) && (__BYTE_ORDER == __BIG_ENDIAN)
#define LITTLEENDIAN(x) swap(x)
#else
#define LITTLEENDIAN(x) (x)
#endif

  // first round
  uint32_t word0  = LITTLEENDIAN(words[ 0]);
  a = rotate(a + f1(b,c,d) + word0  + 0xd76aa478,  7) + b;
  uint32_t word1  = LITTLEENDIAN(words[ 1]);
  d = rotate(d + f1(a,b,c) + word1  + 0xe8c7b756, 12) + a;
  uint32_t word2  = LITTLEENDIAN(words[ 2]);
  c = rotate(c + f1(d,a,b) + word2  + 0x242070db, 17) + d;
  uint32_t word3  = LITTLEENDIAN(words[ 3]);
  b = rotate(b + f1(c,d,a) + word3  + 0xc1bdceee, 22) + c;

  uint32_t word4  = LITTLEENDIAN(words[ 4]);
  a = rotate(a + f1(b,c,d) + word4  + 0xf57c0faf,  7) + b;
  uint32_t word5  = LITTLEENDIAN(words[ 5]);
  d = rotate(d + f1(a,b,c) + word5  + 0x4787c62a, 12) + a;
  uint32_t word6  = LITTLEENDIAN(words[ 6]);
  c = rotate(c + f1(d,a,b) + word6  + 0xa8304613, 17) + d;
  uint32_t word7  = LITTLEENDIAN(words[ 7]);
  b = rotate(b + f1(c,d,a) + word7  + 0xfd469501, 22) + c;

  uint32_t word8  = LITTLEENDIAN(words[ 8]);
  a = rotate(a + f1(b,c,d) + word8  + 0x698098d8,  7) + b;
  uint32_t word9  = LITTLEENDIAN(words[ 9]);
  d = rotate(d + f1(a,b,c) + word9  + 0x8b44f7af, 12) + a;
  uint32_t word10 = LITTLEENDIAN(words[10]);
  c = rotate(c + f1(d,a,b) + word10 + 0xffff5bb1, 17) + d;
  uint32_t word11 = LITTLEENDIAN(words[11]);
  b = rotate(b + f1(c,d,a) + word11 + 0x895cd7be, 22) + c;

  uint32_t word12 = LITTLEENDIAN(words[12]);
  a = rotate(a + f1(b,c,d) + word12 + 0x6b901122,  7) + b;
  uint32_t word13 = LITTLEENDIAN(words[13]);
  d = rotate(d + f1(a,b,c) + word13 + 0xfd987193, 12) + a;
  uint32_t word14 = LITTLEENDIAN(words[14]);
  c = rotate(c + f1(d,a,b) + word14 + 0xa679438e, 17) + d;
  uint32_t word15 = LITTLEENDIAN(words[15]);
  b = rotate(b + f1(c,d,a) + word15 + 0x49b40821, 22) + c;

  // second round
  a = rotate(a + f2(b,c,d) + word1  + 0xf61e2562,  5) + b;
  d = rotate(d + f2(a,b,c) + word6  + 0xc040b340,  9) + a;
  c = rotate(c + f2(d,a,b) + word11 + 0x265e5a51, 14) + d;
  b = rotate(b + f2(c,d,a) + word0  + 0xe9b6c7aa, 20) + c;

  a = rotate(a + f2(b,c,d) + word5  + 0xd62f105d,  5) + b;
  d = rotate(d + f2(a,b,c) + word10 + 0x02441453,  9) + a;
  c = rotate(c + f2(d,a,b) + word15 + 0xd8a1e681, 14) + d;
  b = rotate(b + f2(c,d,a) + word4  + 0xe7d3fbc8, 20) + c;

  a = rotate(a + f2(b,c,d) + word9  + 0x21e1cde6,  5) + b;
  d = rotate(d + f2(a,b,c) + word14 + 0xc33707d6,  9) + a;
  c = rotate(c + f2(d,a,b) + word3  + 0xf4d50d87, 14) + d;
  b = rotate(b + f2(c,d,a) + word8  + 0x455a14ed, 20) + c;

  a = rotate(a + f2(b,c,d) + word13 + 0xa9e3e905,  5) + b;
  d = rotate(d + f2(a,b,c) + word2  + 0xfcefa3f8,  9) + a;
  c = rotate(c + f2(d,a,b) + word7  + 0x676f02d9, 14) + d;
  b = rotate(b + f2(c,d,a) + word12 + 0x8d2a4c8a, 20) + c;

  // third round
  a = rotate(a + f3(b,c,d) + word5  + 0xfffa3942,  4) + b;
  d = rotate(d + f3(a,b,c) + word8  + 0x8771f681, 11) + a;
  c = rotate(c + f3(d,a,b) + word11 + 0x6d9d6122, 16) + d;
  b = rotate(b + f3(c,d,a) + word14 + 0xfde5380c, 23) + c;

  a = rotate(a + f3(b,c,d) + word1  + 0xa4beea44,  4) + b;
  d = rotate(d + f3(a,b,c) + word4  + 0x4bdecfa9, 11) + a;
  c = rotate(c + f3(d,a,b) + word7  + 0xf6bb4b60, 16) + d;
  b = rotate(b + f3(c,d,a) + word10 + 0xbebfbc70, 23) + c;

  a = rotate(a + f3(b,c,d) + word13 + 0x289b7ec6,  4) + b;
  d = rotate(d + f3(a,b,c) + word0  + 0xeaa127fa, 11) + a;
  c = rotate(c + f3(d,a,b) + word3  + 0xd4ef3085, 16) + d;
  b = rotate(b + f3(c,d,a) + word6  + 0x04881d05, 23) + c;

  a = rotate(a + f3(b,c,d) + word9  + 0xd9d4d039,  4) + b;
  d = rotate(d + f3(a,b,c) + word12 + 0xe6db99e5, 11) + a;
  c = rotate(c + f3(d,a,b) + word15 + 0x1fa27cf8, 16) + d;
  b = rotate(b + f3(c,d,a) + word2  + 0xc4ac5665, 23) + c;

  // fourth round
  a = rotate(a + f4(b,c,d) + word0  + 0xf4292244,  6) + b;
  d = rotate(d + f4(a,b,c) + word7  + 0x432aff97, 10) + a;
  c = rotate(c + f4(d,a,b) + word14 + 0xab9423a7, 15) + d;
  b = rotate(b + f4(c,d,a) + word5  + 0xfc93a039, 21) + c;

  a = rotate(a + f4(b,c,d) + word12 + 0x655b59c3,  6) + b;
  d = rotate(d + f4(a,b,c) + word3  + 0x8f0ccc92, 10) + a;
  c = rotate(c + f4(d,a,b) + word10 + 0xffeff47d, 15) + d;
  b = rotate(b + f4(c,d,a) + word1  + 0x85845dd1, 21) + c;

  a = rotate(a + f4(b,c,d) + word8  + 0x6fa87e4f,  6) + b;
  d = rotate(d + f4(a,b,c) + word15 + 0xfe2ce6e0, 10) + a;
  c = rotate(c + f4(d,a,b) + word6  + 0xa3014314, 15) + d;
  b = rotate(b + f4(c,d,a) + word13 + 0x4e0811a1, 21) + c;

  a = rotate(a + f4(b,c,d) + word4  + 0xf7537e82,  6) + b;
  d = rotate(d + f4(a,b,c) + word11 + 0xbd3af235, 10) + a;
  c = rotate(c + f4(d,a,b) + word2  + 0x2ad7d2bb, 15) + d;
  b = rotate(b + f4(c,d,a) + word9  + 0xeb86d391, 21) + c;

  // update hash
  m_hash[0] += a;
  m_hash[1] += b;
  m_hash[2] += c;
  m_hash[3] += d;
}


/// add arbitrary number of bytes
void MD5::add(const void* data, size_t numBytes)
{
  const uint8_t* current = (const uint8_t*) data;

  if (m_bufferSize > 0)
  {
    while (numBytes > 0 && m_bufferSize < BlockSize)
    {
      m_buffer[m_bufferSize++] = *current++;
      numBytes--;
    }
  }

  // full buffer
  if (m_bufferSize == BlockSize)
  {
    processBlock(m_buffer);
    m_numBytes  += BlockSize;
    m_bufferSize = 0;
  }

  // no more data ?
  if (numBytes == 0)
    return;

  // process full blocks
  while (numBytes >= BlockSize)
  {
    processBlock(current);
    current    += BlockSize;
    m_numBytes += BlockSize;
    numBytes   -= BlockSize;
  }

  // keep remaining bytes in buffer
  while (numBytes > 0)
  {
    m_buffer[m_bufferSize++] = *current++;
    numBytes--;
  }
}


/// process final block, less than 64 bytes
void MD5::processBuffer()
{
  // the input bytes are considered as bits strings, where the first bit is the most significant bit of the byte

  // - append "1" bit to message
  // - append "0" bits until message length in bit mod 512 is 448
  // - append length as 64 bit integer

  // number of bits
  size_t paddedLength = m_bufferSize * 8;

  // plus one bit set to 1 (always appended)
  paddedLength++;

  // number of bits must be (numBits % 512) = 448
  size_t lower11Bits = paddedLength & 511;
  if (lower11Bits <= 448)
    paddedLength +=       448 - lower11Bits;
  else
    paddedLength += 512 + 448 - lower11Bits;
  // convert from bits to bytes
  paddedLength /= 8;

  // only needed if additional data flows over into a second block
  unsigned char extra[BlockSize];

  // append a "1" bit, 128 => binary 10000000
  if (m_bufferSize < BlockSize)
    m_buffer[m_bufferSize] = 128;
  else
    extra[0] = 128;

  size_t i;
  for (i = m_bufferSize + 1; i < BlockSize; i++)
    m_buffer[i] = 0;
  for (; i < paddedLength; i++)
    extra[i - BlockSize] = 0;

  // add message length in bits as 64 bit number
  uint64_t msgBits = 8 * (m_numBytes + m_bufferSize);
  // find right position
  unsigned char* addLength;
  if (paddedLength < BlockSize)
    addLength = m_buffer + paddedLength;
  else
    addLength = extra + paddedLength - BlockSize;

  // must be little endian
  *addLength++ = msgBits & 0xFF; msgBits >>= 8;
  *addLength++ = msgBits & 0xFF; msgBits >>= 8;
  *addLength++ = msgBits & 0xFF; msgBits >>= 8;
  *addLength++ = msgBits & 0xFF; msgBits >>= 8;
  *addLength++ = msgBits & 0xFF; msgBits >>= 8;
  *addLength++ = msgBits & 0xFF; msgBits >>= 8;
  *addLength++ = msgBits & 0xFF; msgBits >>= 8;
  *addLength++ = msgBits & 0xFF;

  // process blocks
  processBlock(m_buffer);
  // flowed over into a second block ?
  if (paddedLength > BlockSize)
    processBlock(extra);
}


/// return latest hash as 32 hex characters
std::string MD5::getHash()
{
  // compute hash (as raw bytes)
  unsigned char rawHash[HashBytes];
  getHash(rawHash);

  // convert to hex string
  std::string result;
  result.reserve(2 * HashBytes);
  for (int i = 0; i < HashBytes; i++)
  {
    static const char dec2hex[16+1] = "0123456789abcdef";
    result += dec2hex[(rawHash[i] >> 4) & 15];
    result += dec2hex[ rawHash[i]       & 15];
  }

  return result;
}


/// return latest hash as bytes
void MD5::getHash(unsigned char buffer[MD5::HashBytes])
{
  // save old hash if buffer is partially filled
  uint32_t oldHash[HashValues];
  for (int i = 0; i < HashValues; i++)
    oldHash[i] = m_hash[i];

  // process remaining bytes
  processBuffer();

  unsigned char* current = buffer;
  for (int i = 0; i < HashValues; i++)
  {
    *current++ =  m_hash[i]        & 0xFF;
    *current++ = (m_hash[i] >>  8) & 0xFF;
    *current++ = (m_hash[i] >> 16) & 0xFF;
    *current++ = (m_hash[i] >> 24) & 0xFF;

    // restore old hash
    m_hash[i] = oldHash[i];
  }
}


/// compute MD5 of a memory block
std::string MD5::operator()(const void* data, size_t numBytes)
{
  reset();
  add(data, numBytes);
  return getHash();
}


/// compute MD5 of a string, excluding final zero
std::string MD5::operator()(const std::string& text)
{
  reset();
  add(text.c_str(), text.size());
  return getHash();
}
// //////////////////////////////////////////////////////////
// sha1.cpp
// Copyright (c) 2014,2015 Stephan Brumme. All rights reserved.
// see http://create.stephan-brumme.com/disclaimer.html
//

#include "sha1.h"

// big endian architectures need #define __BYTE_ORDER __BIG_ENDIAN
#ifndef _MSC_VER
#include <endian.h>
#endif


/// same as reset()
SHA1::SHA1()
{
  reset();
}


/// restart
void SHA1::reset()
{
  m_numBytes   = 0;
  m_bufferSize = 0;

  // according to RFC 1321
  m_hash[0] = 0x67452301;
  m_hash[1] = 0xefcdab89;
  m_hash[2] = 0x98badcfe;
  m_hash[3] = 0x10325476;
  m_hash[4] = 0xc3d2e1f0;
}


namespace
{
  // mix functions for processBlock()
  inline uint32_t f1(uint32_t b, uint32_t c, uint32_t d)
  {
    return d ^ (b & (c ^ d)); // original: f = (b & c) | ((~b) & d);
  }

  inline uint32_t f2(uint32_t b, uint32_t c, uint32_t d)
  {
    return b ^ c ^ d;
  }

  inline uint32_t f3(uint32_t b, uint32_t c, uint32_t d)
  {
    return (b & c) | (b & d) | (c & d);
  }

  inline uint32_t rotate(uint32_t a, uint32_t c)
  {
    return (a << c) | (a >> (32 - c));
  }

  inline uint32_t swap(uint32_t x)
  {
#if defined(__GNUC__) || defined(__clang__)
    return __builtin_bswap32(x);
#endif
#ifdef MSC_VER
    return _byteswap_ulong(x);
#endif

    return (x >> 24) |
          ((x >>  8) & 0x0000FF00) |
          ((x <<  8) & 0x00FF0000) |
           (x << 24);
  }
}


/// process 64 bytes
void SHA1::processBlock(const void* data)
{
  // get last hash
  uint32_t a = m_hash[0];
  uint32_t b = m_hash[1];
  uint32_t c = m_hash[2];
  uint32_t d = m_hash[3];
  uint32_t e = m_hash[4];

  // data represented as 16x 32-bit words
  const uint32_t* input = (uint32_t*) data;
  // convert to big endian
  uint32_t words[80];
  for (int i = 0; i < 16; i++)
#if defined(__BYTE_ORDER) && (__BYTE_ORDER != 0) && (__BYTE_ORDER == __BIG_ENDIAN)
    words[i] = input[i];
#else
    words[i] = swap(input[i]);
#endif

  // extend to 80 words
  for (int i = 16; i < 80; i++)
    words[i] = rotate(words[i-3] ^ words[i-8] ^ words[i-14] ^ words[i-16], 1);

  // first round
  for (int i = 0; i < 4; i++)
  {
    int offset = 5*i;
    e += rotate(a,5) + f1(b,c,d) + words[offset  ] + 0x5a827999; b = rotate(b,30);
    d += rotate(e,5) + f1(a,b,c) + words[offset+1] + 0x5a827999; a = rotate(a,30);
    c += rotate(d,5) + f1(e,a,b) + words[offset+2] + 0x5a827999; e = rotate(e,30);
    b += rotate(c,5) + f1(d,e,a) + words[offset+3] + 0x5a827999; d = rotate(d,30);
    a += rotate(b,5) + f1(c,d,e) + words[offset+4] + 0x5a827999; c = rotate(c,30);
  }

  // second round
  for (int i = 4; i < 8; i++)
  {
    int offset = 5*i;
    e += rotate(a,5) + f2(b,c,d) + words[offset  ] + 0x6ed9eba1; b = rotate(b,30);
    d += rotate(e,5) + f2(a,b,c) + words[offset+1] + 0x6ed9eba1; a = rotate(a,30);
    c += rotate(d,5) + f2(e,a,b) + words[offset+2] + 0x6ed9eba1; e = rotate(e,30);
    b += rotate(c,5) + f2(d,e,a) + words[offset+3] + 0x6ed9eba1; d = rotate(d,30);
    a += rotate(b,5) + f2(c,d,e) + words[offset+4] + 0x6ed9eba1; c = rotate(c,30);
  }

  // third round
  for (int i = 8; i < 12; i++)
  {
    int offset = 5*i;
    e += rotate(a,5) + f3(b,c,d) + words[offset  ] + 0x8f1bbcdc; b = rotate(b,30);
    d += rotate(e,5) + f3(a,b,c) + words[offset+1] + 0x8f1bbcdc; a = rotate(a,30);
    c += rotate(d,5) + f3(e,a,b) + words[offset+2] + 0x8f1bbcdc; e = rotate(e,30);
    b += rotate(c,5) + f3(d,e,a) + words[offset+3] + 0x8f1bbcdc; d = rotate(d,30);
    a += rotate(b,5) + f3(c,d,e) + words[offset+4] + 0x8f1bbcdc; c = rotate(c,30);
  }

  // fourth round
  for (int i = 12; i < 16; i++)
  {
    int offset = 5*i;
    e += rotate(a,5) + f2(b,c,d) + words[offset  ] + 0xca62c1d6; b = rotate(b,30);
    d += rotate(e,5) + f2(a,b,c) + words[offset+1] + 0xca62c1d6; a = rotate(a,30);
    c += rotate(d,5) + f2(e,a,b) + words[offset+2] + 0xca62c1d6; e = rotate(e,30);
    b += rotate(c,5) + f2(d,e,a) + words[offset+3] + 0xca62c1d6; d = rotate(d,30);
    a += rotate(b,5) + f2(c,d,e) + words[offset+4] + 0xca62c1d6; c = rotate(c,30);
  }

  // update hash
  m_hash[0] += a;
  m_hash[1] += b;
  m_hash[2] += c;
  m_hash[3] += d;
  m_hash[4] += e;
}


/// add arbitrary number of bytes
void SHA1::add(const void* data, size_t numBytes)
{
  const uint8_t* current = (const uint8_t*) data;

  if (m_bufferSize > 0)
  {
    while (numBytes > 0 && m_bufferSize < BlockSize)
    {
      m_buffer[m_bufferSize++] = *current++;
      numBytes--;
    }
  }

  // full buffer
  if (m_bufferSize == BlockSize)
  {
    processBlock((void*)m_buffer);
    m_numBytes  += BlockSize;
    m_bufferSize = 0;
  }

  // no more data ?
  if (numBytes == 0)
    return;

  // process full blocks
  while (numBytes >= BlockSize)
  {
    processBlock(current);
    current    += BlockSize;
    m_numBytes += BlockSize;
    numBytes   -= BlockSize;
  }

  // keep remaining bytes in buffer
  while (numBytes > 0)
  {
    m_buffer[m_bufferSize++] = *current++;
    numBytes--;
  }
}


/// process final block, less than 64 bytes
void SHA1::processBuffer()
{
  // the input bytes are considered as bits strings, where the first bit is the most significant bit of the byte

  // - append "1" bit to message
  // - append "0" bits until message length in bit mod 512 is 448
  // - append length as 64 bit integer

  // number of bits
  size_t paddedLength = m_bufferSize * 8;

  // plus one bit set to 1 (always appended)
  paddedLength++;

  // number of bits must be (numBits % 512) = 448
  size_t lower11Bits = paddedLength & 511;
  if (lower11Bits <= 448)
    paddedLength +=       448 - lower11Bits;
  else
    paddedLength += 512 + 448 - lower11Bits;
  // convert from bits to bytes
  paddedLength /= 8;

  // only needed if additional data flows over into a second block
  unsigned char extra[BlockSize];

  // append a "1" bit, 128 => binary 10000000
  if (m_bufferSize < BlockSize)
    m_buffer[m_bufferSize] = 128;
  else
    extra[0] = 128;

  size_t i;
  for (i = m_bufferSize + 1; i < BlockSize; i++)
    m_buffer[i] = 0;
  for (; i < paddedLength; i++)
    extra[i - BlockSize] = 0;

  // add message length in bits as 64 bit number
  uint64_t msgBits = 8 * (m_numBytes + m_bufferSize);
  // find right position
  unsigned char* addLength;
  if (paddedLength < BlockSize)
    addLength = m_buffer + paddedLength;
  else
    addLength = extra + paddedLength - BlockSize;

  // must be big endian
  *addLength++ = (unsigned char)((msgBits >> 56) & 0xFF);
  *addLength++ = (unsigned char)((msgBits >> 48) & 0xFF);
  *addLength++ = (unsigned char)((msgBits >> 40) & 0xFF);
  *addLength++ = (unsigned char)((msgBits >> 32) & 0xFF);
  *addLength++ = (unsigned char)((msgBits >> 24) & 0xFF);
  *addLength++ = (unsigned char)((msgBits >> 16) & 0xFF);
  *addLength++ = (unsigned char)((msgBits >>  8) & 0xFF);
  *addLength   = (unsigned char)( msgBits        & 0xFF);

  // process blocks
  processBlock(m_buffer);
  // flowed over into a second block ?
  if (paddedLength > BlockSize)
    processBlock(extra);
}


/// return latest hash as 40 hex characters
std::string SHA1::getHash()
{
  // compute hash (as raw bytes)
  unsigned char rawHash[HashBytes];
  getHash(rawHash);

  // convert to hex string
  std::string result;
  result.reserve(2 * HashBytes);
  for (int i = 0; i < HashBytes; i++)
  {
    static const char dec2hex[16+1] = "0123456789abcdef";
    result += dec2hex[(rawHash[i] >> 4) & 15];
    result += dec2hex[ rawHash[i]       & 15];
  }

  return result;
}


/// return latest hash as bytes
void SHA1::getHash(unsigned char buffer[SHA1::HashBytes])
{
  // save old hash if buffer is partially filled
  uint32_t oldHash[HashValues];
  for (int i = 0; i < HashValues; i++)
    oldHash[i] = m_hash[i];

  // process remaining bytes
  processBuffer();

  unsigned char* current = buffer;
  for (int i = 0; i < HashValues; i++)
  {
    *current++ = (m_hash[i] >> 24) & 0xFF;
    *current++ = (m_hash[i] >> 16) & 0xFF;
    *current++ = (m_hash[i] >>  8) & 0xFF;
    *current++ =  m_hash[i]        & 0xFF;

    // restore old hash
    m_hash[i] = oldHash[i];
  }
}


/// compute SHA1 of a memory block
std::string SHA1::operator()(const void* data, size_t numBytes)
{
  reset();
  add(data, numBytes);
  return getHash();
}


/// compute SHA1 of a string, excluding final zero
std::string SHA1::operator()(const std::string& text)
{
  reset();
  add(text.c_str(), text.size());
  return getHash();
}
// //////////////////////////////////////////////////////////
// sha256.cpp
// Copyright (c) 2014,2015 Stephan Brumme. All rights reserved.
// see http://create.stephan-brumme.com/disclaimer.html
//

#include "sha256.h"

// big endian architectures need #define __BYTE_ORDER __BIG_ENDIAN
#ifndef _MSC_VER
#include <endian.h>
#endif


/// same as reset()
SHA256::SHA256()
{
  reset();
}


/// restart
void SHA256::reset()
{
  m_numBytes   = 0;
  m_bufferSize = 0;

  // according to RFC 1321
  m_hash[0] = 0x6a09e667;
  m_hash[1] = 0xbb67ae85;
  m_hash[2] = 0x3c6ef372;
  m_hash[3] = 0xa54ff53a;
  m_hash[4] = 0x510e527f;
  m_hash[5] = 0x9b05688c;
  m_hash[6] = 0x1f83d9ab;
  m_hash[7] = 0x5be0cd19;
}


namespace
{
  inline uint32_t rotate(uint32_t a, uint32_t c)
  {
    return (a >> c) | (a << (32 - c));
  }

  inline uint32_t swap(uint32_t x)
  {
#if defined(__GNUC__) || defined(__clang__)
    return __builtin_bswap32(x);
#endif
#ifdef MSC_VER
    return _byteswap_ulong(x);
#endif

    return (x >> 24) |
          ((x >>  8) & 0x0000FF00) |
          ((x <<  8) & 0x00FF0000) |
           (x << 24);
  }

  // mix functions for processBlock()
  inline uint32_t f1(uint32_t e, uint32_t f, uint32_t g)
  {
    uint32_t term1 = rotate(e, 6) ^ rotate(e, 11) ^ rotate(e, 25);
    uint32_t term2 = (e & f) ^ (~e & g); //(g ^ (e & (f ^ g)))
    return term1 + term2;
  }

  inline uint32_t f2(uint32_t a, uint32_t b, uint32_t c)
  {
    uint32_t term1 = rotate(a, 2) ^ rotate(a, 13) ^ rotate(a, 22);
    uint32_t term2 = ((a | b) & c) | (a & b); //(a & (b ^ c)) ^ (b & c);
    return term1 + term2;
  }
}


/// process 64 bytes
void SHA256::processBlock(const void* data)
{
  // get last hash
  uint32_t a = m_hash[0];
  uint32_t b = m_hash[1];
  uint32_t c = m_hash[2];
  uint32_t d = m_hash[3];
  uint32_t e = m_hash[4];
  uint32_t f = m_hash[5];
  uint32_t g = m_hash[6];
  uint32_t h = m_hash[7];

  // data represented as 16x 32-bit words
  const uint32_t* input = (uint32_t*) data;
  // convert to big endian
  uint32_t words[64];
  int i;
  for (i = 0; i < 16; i++)
#if defined(__BYTE_ORDER) && (__BYTE_ORDER != 0) && (__BYTE_ORDER == __BIG_ENDIAN)
    words[i] =      input[i];
#else
    words[i] = swap(input[i]);
#endif

  uint32_t x,y; // temporaries

  // first round
  x = h + f1(e,f,g) + 0x428a2f98 + words[ 0]; y = f2(a,b,c); d += x; h = x + y;
  x = g + f1(d,e,f) + 0x71374491 + words[ 1]; y = f2(h,a,b); c += x; g = x + y;
  x = f + f1(c,d,e) + 0xb5c0fbcf + words[ 2]; y = f2(g,h,a); b += x; f = x + y;
  x = e + f1(b,c,d) + 0xe9b5dba5 + words[ 3]; y = f2(f,g,h); a += x; e = x + y;
  x = d + f1(a,b,c) + 0x3956c25b + words[ 4]; y = f2(e,f,g); h += x; d = x + y;
  x = c + f1(h,a,b) + 0x59f111f1 + words[ 5]; y = f2(d,e,f); g += x; c = x + y;
  x = b + f1(g,h,a) + 0x923f82a4 + words[ 6]; y = f2(c,d,e); f += x; b = x + y;
  x = a + f1(f,g,h) + 0xab1c5ed5 + words[ 7]; y = f2(b,c,d); e += x; a = x + y;

  // secound round
  x = h + f1(e,f,g) + 0xd807aa98 + words[ 8]; y = f2(a,b,c); d += x; h = x + y;
  x = g + f1(d,e,f) + 0x12835b01 + words[ 9]; y = f2(h,a,b); c += x; g = x + y;
  x = f + f1(c,d,e) + 0x243185be + words[10]; y = f2(g,h,a); b += x; f = x + y;
  x = e + f1(b,c,d) + 0x550c7dc3 + words[11]; y = f2(f,g,h); a += x; e = x + y;
  x = d + f1(a,b,c) + 0x72be5d74 + words[12]; y = f2(e,f,g); h += x; d = x + y;
  x = c + f1(h,a,b) + 0x80deb1fe + words[13]; y = f2(d,e,f); g += x; c = x + y;
  x = b + f1(g,h,a) + 0x9bdc06a7 + words[14]; y = f2(c,d,e); f += x; b = x + y;
  x = a + f1(f,g,h) + 0xc19bf174 + words[15]; y = f2(b,c,d); e += x; a = x + y;

  // extend to 24 words
  for (; i < 24; i++)
    words[i] = words[i-16] +
               (rotate(words[i-15],  7) ^ rotate(words[i-15], 18) ^ (words[i-15] >>  3)) +
               words[i-7] +
               (rotate(words[i- 2], 17) ^ rotate(words[i- 2], 19) ^ (words[i- 2] >> 10));

  // third round
  x = h + f1(e,f,g) + 0xe49b69c1 + words[16]; y = f2(a,b,c); d += x; h = x + y;
  x = g + f1(d,e,f) + 0xefbe4786 + words[17]; y = f2(h,a,b); c += x; g = x + y;
  x = f + f1(c,d,e) + 0x0fc19dc6 + words[18]; y = f2(g,h,a); b += x; f = x + y;
  x = e + f1(b,c,d) + 0x240ca1cc + words[19]; y = f2(f,g,h); a += x; e = x + y;
  x = d + f1(a,b,c) + 0x2de92c6f + words[20]; y = f2(e,f,g); h += x; d = x + y;
  x = c + f1(h,a,b) + 0x4a7484aa + words[21]; y = f2(d,e,f); g += x; c = x + y;
  x = b + f1(g,h,a) + 0x5cb0a9dc + words[22]; y = f2(c,d,e); f += x; b = x + y;
  x = a + f1(f,g,h) + 0x76f988da + words[23]; y = f2(b,c,d); e += x; a = x + y;

  // extend to 32 words
  for (; i < 32; i++)
    words[i] = words[i-16] +
               (rotate(words[i-15],  7) ^ rotate(words[i-15], 18) ^ (words[i-15] >>  3)) +
               words[i-7] +
               (rotate(words[i- 2], 17) ^ rotate(words[i- 2], 19) ^ (words[i- 2] >> 10));

  // fourth round
  x = h + f1(e,f,g) + 0x983e5152 + words[24]; y = f2(a,b,c); d += x; h = x + y;
  x = g + f1(d,e,f) + 0xa831c66d + words[25]; y = f2(h,a,b); c += x; g = x + y;
  x = f + f1(c,d,e) + 0xb00327c8 + words[26]; y = f2(g,h,a); b += x; f = x + y;
  x = e + f1(b,c,d) + 0xbf597fc7 + words[27]; y = f2(f,g,h); a += x; e = x + y;
  x = d + f1(a,b,c) + 0xc6e00bf3 + words[28]; y = f2(e,f,g); h += x; d = x + y;
  x = c + f1(h,a,b) + 0xd5a79147 + words[29]; y = f2(d,e,f); g += x; c = x + y;
  x = b + f1(g,h,a) + 0x06ca6351 + words[30]; y = f2(c,d,e); f += x; b = x + y;
  x = a + f1(f,g,h) + 0x14292967 + words[31]; y = f2(b,c,d); e += x; a = x + y;

  // extend to 40 words
  for (; i < 40; i++)
    words[i] = words[i-16] +
               (rotate(words[i-15],  7) ^ rotate(words[i-15], 18) ^ (words[i-15] >>  3)) +
               words[i-7] +
               (rotate(words[i- 2], 17) ^ rotate(words[i- 2], 19) ^ (words[i- 2] >> 10));

  // fifth round
  x = h + f1(e,f,g) + 0x27b70a85 + words[32]; y = f2(a,b,c); d += x; h = x + y;
  x = g + f1(d,e,f) + 0x2e1b2138 + words[33]; y = f2(h,a,b); c += x; g = x + y;
  x = f + f1(c,d,e) + 0x4d2c6dfc + words[34]; y = f2(g,h,a); b += x; f = x + y;
  x = e + f1(b,c,d) + 0x53380d13 + words[35]; y = f2(f,g,h); a += x; e = x + y;
  x = d + f1(a,b,c) + 0x650a7354 + words[36]; y = f2(e,f,g); h += x; d = x + y;
  x = c + f1(h,a,b) + 0x766a0abb + words[37]; y = f2(d,e,f); g += x; c = x + y;
  x = b + f1(g,h,a) + 0x81c2c92e + words[38]; y = f2(c,d,e); f += x; b = x + y;
  x = a + f1(f,g,h) + 0x92722c85 + words[39]; y = f2(b,c,d); e += x; a = x + y;

  // extend to 48 words
  for (; i < 48; i++)
    words[i] = words[i-16] +
               (rotate(words[i-15],  7) ^ rotate(words[i-15], 18) ^ (words[i-15] >>  3)) +
               words[i-7] +
               (rotate(words[i- 2], 17) ^ rotate(words[i- 2], 19) ^ (words[i- 2] >> 10));

  // sixth round
  x = h + f1(e,f,g) + 0xa2bfe8a1 + words[40]; y = f2(a,b,c); d += x; h = x + y;
  x = g + f1(d,e,f) + 0xa81a664b + words[41]; y = f2(h,a,b); c += x; g = x + y;
  x = f + f1(c,d,e) + 0xc24b8b70 + words[42]; y = f2(g,h,a); b += x; f = x + y;
  x = e + f1(b,c,d) + 0xc76c51a3 + words[43]; y = f2(f,g,h); a += x; e = x + y;
  x = d + f1(a,b,c) + 0xd192e819 + words[44]; y = f2(e,f,g); h += x; d = x + y;
  x = c + f1(h,a,b) + 0xd6990624 + words[45]; y = f2(d,e,f); g += x; c = x + y;
  x = b + f1(g,h,a) + 0xf40e3585 + words[46]; y = f2(c,d,e); f += x; b = x + y;
  x = a + f1(f,g,h) + 0x106aa070 + words[47]; y = f2(b,c,d); e += x; a = x + y;

  // extend to 56 words
  for (; i < 56; i++)
    words[i] = words[i-16] +
               (rotate(words[i-15],  7) ^ rotate(words[i-15], 18) ^ (words[i-15] >>  3)) +
               words[i-7] +
               (rotate(words[i- 2], 17) ^ rotate(words[i- 2], 19) ^ (words[i- 2] >> 10));

  // seventh round
  x = h + f1(e,f,g) + 0x19a4c116 + words[48]; y = f2(a,b,c); d += x; h = x + y;
  x = g + f1(d,e,f) + 0x1e376c08 + words[49]; y = f2(h,a,b); c += x; g = x + y;
  x = f + f1(c,d,e) + 0x2748774c + words[50]; y = f2(g,h,a); b += x; f = x + y;
  x = e + f1(b,c,d) + 0x34b0bcb5 + words[51]; y = f2(f,g,h); a += x; e = x + y;
  x = d + f1(a,b,c) + 0x391c0cb3 + words[52]; y = f2(e,f,g); h += x; d = x + y;
  x = c + f1(h,a,b) + 0x4ed8aa4a + words[53]; y = f2(d,e,f); g += x; c = x + y;
  x = b + f1(g,h,a) + 0x5b9cca4f + words[54]; y = f2(c,d,e); f += x; b = x + y;
  x = a + f1(f,g,h) + 0x682e6ff3 + words[55]; y = f2(b,c,d); e += x; a = x + y;

  // extend to 64 words
  for (; i < 64; i++)
    words[i] = words[i-16] +
               (rotate(words[i-15],  7) ^ rotate(words[i-15], 18) ^ (words[i-15] >>  3)) +
               words[i-7] +
               (rotate(words[i- 2], 17) ^ rotate(words[i- 2], 19) ^ (words[i- 2] >> 10));

  // eigth round
  x = h + f1(e,f,g) + 0x748f82ee + words[56]; y = f2(a,b,c); d += x; h = x + y;
  x = g + f1(d,e,f) + 0x78a5636f + words[57]; y = f2(h,a,b); c += x; g = x + y;
  x = f + f1(c,d,e) + 0x84c87814 + words[58]; y = f2(g,h,a); b += x; f = x + y;
  x = e + f1(b,c,d) + 0x8cc70208 + words[59]; y = f2(f,g,h); a += x; e = x + y;
  x = d + f1(a,b,c) + 0x90befffa + words[60]; y = f2(e,f,g); h += x; d = x + y;
  x = c + f1(h,a,b) + 0xa4506ceb + words[61]; y = f2(d,e,f); g += x; c = x + y;
  x = b + f1(g,h,a) + 0xbef9a3f7 + words[62]; y = f2(c,d,e); f += x; b = x + y;
  x = a + f1(f,g,h) + 0xc67178f2 + words[63]; y = f2(b,c,d); e += x; a = x + y;

  // update hash
  m_hash[0] += a;
  m_hash[1] += b;
  m_hash[2] += c;
  m_hash[3] += d;
  m_hash[4] += e;
  m_hash[5] += f;
  m_hash[6] += g;
  m_hash[7] += h;
}


/// add arbitrary number of bytes
void SHA256::add(const void* data, size_t numBytes)
{
  const uint8_t* current = (const uint8_t*) data;

  if (m_bufferSize > 0)
  {
    while (numBytes > 0 && m_bufferSize < BlockSize)
    {
      m_buffer[m_bufferSize++] = *current++;
      numBytes--;
    }
  }

  // full buffer
  if (m_bufferSize == BlockSize)
  {
    processBlock(m_buffer);
    m_numBytes  += BlockSize;
    m_bufferSize = 0;
  }

  // no more data ?
  if (numBytes == 0)
    return;

  // process full blocks
  while (numBytes >= BlockSize)
  {
    processBlock(current);
    current    += BlockSize;
    m_numBytes += BlockSize;
    numBytes   -= BlockSize;
  }

  // keep remaining bytes in buffer
  while (numBytes > 0)
  {
    m_buffer[m_bufferSize++] = *current++;
    numBytes--;
  }
}


/// process final block, less than 64 bytes
void SHA256::processBuffer()
{
  // the input bytes are considered as bits strings, where the first bit is the most significant bit of the byte

  // - append "1" bit to message
  // - append "0" bits until message length in bit mod 512 is 448
  // - append length as 64 bit integer

  // number of bits
  size_t paddedLength = m_bufferSize * 8;

  // plus one bit set to 1 (always appended)
  paddedLength++;

  // number of bits must be (numBits % 512) = 448
  size_t lower11Bits = paddedLength & 511;
  if (lower11Bits <= 448)
    paddedLength +=       448 - lower11Bits;
  else
    paddedLength += 512 + 448 - lower11Bits;
  // convert from bits to bytes
  paddedLength /= 8;

  // only needed if additional data flows over into a second block
  unsigned char extra[BlockSize];

  // append a "1" bit, 128 => binary 10000000
  if (m_bufferSize < BlockSize)
    m_buffer[m_bufferSize] = 128;
  else
    extra[0] = 128;

  size_t i;
  for (i = m_bufferSize + 1; i < BlockSize; i++)
    m_buffer[i] = 0;
  for (; i < paddedLength; i++)
    extra[i - BlockSize] = 0;

  // add message length in bits as 64 bit number
  uint64_t msgBits = 8 * (m_numBytes + m_bufferSize);
  // find right position
  unsigned char* addLength;
  if (paddedLength < BlockSize)
    addLength = m_buffer + paddedLength;
  else
    addLength = extra + paddedLength - BlockSize;

  // must be big endian
  *addLength++ = (unsigned char)((msgBits >> 56) & 0xFF);
  *addLength++ = (unsigned char)((msgBits >> 48) & 0xFF);
  *addLength++ = (unsigned char)((msgBits >> 40) & 0xFF);
  *addLength++ = (unsigned char)((msgBits >> 32) & 0xFF);
  *addLength++ = (unsigned char)((msgBits >> 24) & 0xFF);
  *addLength++ = (unsigned char)((msgBits >> 16) & 0xFF);
  *addLength++ = (unsigned char)((msgBits >>  8) & 0xFF);
  *addLength   = (unsigned char)( msgBits        & 0xFF);

  // process blocks
  processBlock(m_buffer);
  // flowed over into a second block ?
  if (paddedLength > BlockSize)
    processBlock(extra);
}


/// return latest hash as 64 hex characters
std::string SHA256::getHash()
{
  // compute hash (as raw bytes)
  unsigned char rawHash[HashBytes];
  getHash(rawHash);

  // convert to hex string
  std::string result;
  result.reserve(2 * HashBytes);
  for (int i = 0; i < HashBytes; i++)
  {
    static const char dec2hex[16+1] = "0123456789abcdef";
    result += dec2hex[(rawHash[i] >> 4) & 15];
    result += dec2hex[ rawHash[i]       & 15];
  }

  return result;
}


/// return latest hash as bytes
void SHA256::getHash(unsigned char buffer[SHA256::HashBytes])
{
  // save old hash if buffer is partially filled
  uint32_t oldHash[HashValues];
  for (int i = 0; i < HashValues; i++)
    oldHash[i] = m_hash[i];

  // process remaining bytes
  processBuffer();

  unsigned char* current = buffer;
  for (int i = 0; i < HashValues; i++)
  {
    *current++ = (m_hash[i] >> 24) & 0xFF;
    *current++ = (m_hash[i] >> 16) & 0xFF;
    *current++ = (m_hash[i] >>  8) & 0xFF;
    *current++ =  m_hash[i]        & 0xFF;

    // restore old hash
    m_hash[i] = oldHash[i];
  }
}


/// compute SHA256 of a memory block
std::string SHA256::operator()(const void* data, size_t numBytes)
{
  reset();
  add(data, numBytes);
  return getHash();
}


/// compute SHA256 of a string, excluding final zero
std::string SHA256::operator()(const std::string& text)
{
  reset();
  add(text.c_str(), text.size());
  return getHash();
}
// //////////////////////////////////////////////////////////
// sha3.cpp
// Copyright (c) 2014,2015 Stephan Brumme. All rights reserved.
// see http://create.stephan-brumme.com/disclaimer.html
//

#include "sha3.h"

// big endian architectures need #define __BYTE_ORDER __BIG_ENDIAN
#ifndef _MSC_VER
#include <endian.h>
#endif


/// same as reset()
SHA3::SHA3(Bits bits)
: m_blockSize(200 - 2 * (bits / 8)),
  m_bits(bits)
{
  reset();
}


/// restart
void SHA3::reset()
{
  for (size_t i = 0; i < StateSize; i++)
    m_hash[i] = 0;

  m_numBytes   = 0;
  m_bufferSize = 0;
}


/// constants and local helper functions
namespace
{
  const unsigned int Rounds = 24;
  const uint64_t XorMasks[Rounds] =
  {
    0x0000000000000001ULL, 0x0000000000008082ULL, 0x800000000000808aULL,
    0x8000000080008000ULL, 0x000000000000808bULL, 0x0000000080000001ULL,
    0x8000000080008081ULL, 0x8000000000008009ULL, 0x000000000000008aULL,
    0x0000000000000088ULL, 0x0000000080008009ULL, 0x000000008000000aULL,
    0x000000008000808bULL, 0x800000000000008bULL, 0x8000000000008089ULL,
    0x8000000000008003ULL, 0x8000000000008002ULL, 0x8000000000000080ULL,
    0x000000000000800aULL, 0x800000008000000aULL, 0x8000000080008081ULL,
    0x8000000000008080ULL, 0x0000000080000001ULL, 0x8000000080008008ULL
  };

  /// rotate left and wrap around to the right
  inline uint64_t rotateLeft(uint64_t x, uint8_t numBits)
  {
    return (x << numBits) | (x >> (64 - numBits));
  }

  /// convert litte vs big endian
  inline uint64_t swap(uint64_t x)
  {
#if defined(__GNUC__) || defined(__clang__)
    return __builtin_bswap64(x);
#endif
#ifdef _MSC_VER
    return _byteswap_uint64(x);
#endif

    return  (x >> 56) |
           ((x >> 40) & 0x000000000000FF00ULL) |
           ((x >> 24) & 0x0000000000FF0000ULL) |
           ((x >>  8) & 0x00000000FF000000ULL) |
           ((x <<  8) & 0x000000FF00000000ULL) |
           ((x << 24) & 0x0000FF0000000000ULL) |
           ((x << 40) & 0x00FF000000000000ULL) |
            (x << 56);
  }


  /// return x % 5 for 0 <= x <= 9
  unsigned int mod5(unsigned int x)
  {
    if (x < 5)
      return x;

    return x - 5;
  }
}


/// process a full block
void SHA3::processBlock(const void* data)
{
#if defined(__BYTE_ORDER) && (__BYTE_ORDER != 0) && (__BYTE_ORDER == __BIG_ENDIAN)
#define LITTLEENDIAN(x) swap(x)
#else
#define LITTLEENDIAN(x) (x)
#endif

  const uint64_t* data64 = (const uint64_t*) data;
  // mix data into state
  for (unsigned int i = 0; i < m_blockSize / 8; i++)
    m_hash[i] ^= LITTLEENDIAN(data64[i]);

  // re-compute state
  for (unsigned int round = 0; round < Rounds; round++)
  {
    // Theta
    uint64_t coefficients[5];
    for (unsigned int i = 0; i < 5; i++)
      coefficients[i] = m_hash[i] ^ m_hash[i + 5] ^ m_hash[i + 10] ^ m_hash[i + 15] ^ m_hash[i + 20];

    for (unsigned int i = 0; i < 5; i++)
    {
      uint64_t one = coefficients[mod5(i + 4)] ^ rotateLeft(coefficients[mod5(i + 1)], 1);
      m_hash[i     ] ^= one;
      m_hash[i +  5] ^= one;
      m_hash[i + 10] ^= one;
      m_hash[i + 15] ^= one;
      m_hash[i + 20] ^= one;
    }

    // temporary
    uint64_t one;

    // Rho Pi
    uint64_t last = m_hash[1];
    one = m_hash[10]; m_hash[10] = rotateLeft(last,  1); last = one;
    one = m_hash[ 7]; m_hash[ 7] = rotateLeft(last,  3); last = one;
    one = m_hash[11]; m_hash[11] = rotateLeft(last,  6); last = one;
    one = m_hash[17]; m_hash[17] = rotateLeft(last, 10); last = one;
    one = m_hash[18]; m_hash[18] = rotateLeft(last, 15); last = one;
    one = m_hash[ 3]; m_hash[ 3] = rotateLeft(last, 21); last = one;
    one = m_hash[ 5]; m_hash[ 5] = rotateLeft(last, 28); last = one;
    one = m_hash[16]; m_hash[16] = rotateLeft(last, 36); last = one;
    one = m_hash[ 8]; m_hash[ 8] = rotateLeft(last, 45); last = one;
    one = m_hash[21]; m_hash[21] = rotateLeft(last, 55); last = one;
    one = m_hash[24]; m_hash[24] = rotateLeft(last,  2); last = one;
    one = m_hash[ 4]; m_hash[ 4] = rotateLeft(last, 14); last = one;
    one = m_hash[15]; m_hash[15] = rotateLeft(last, 27); last = one;
    one = m_hash[23]; m_hash[23] = rotateLeft(last, 41); last = one;
    one = m_hash[19]; m_hash[19] = rotateLeft(last, 56); last = one;
    one = m_hash[13]; m_hash[13] = rotateLeft(last,  8); last = one;
    one = m_hash[12]; m_hash[12] = rotateLeft(last, 25); last = one;
    one = m_hash[ 2]; m_hash[ 2] = rotateLeft(last, 43); last = one;
    one = m_hash[20]; m_hash[20] = rotateLeft(last, 62); last = one;
    one = m_hash[14]; m_hash[14] = rotateLeft(last, 18); last = one;
    one = m_hash[22]; m_hash[22] = rotateLeft(last, 39); last = one;
    one = m_hash[ 9]; m_hash[ 9] = rotateLeft(last, 61); last = one;
    one = m_hash[ 6]; m_hash[ 6] = rotateLeft(last, 20); last = one;
                      m_hash[ 1] = rotateLeft(last, 44);

    // Chi
    for (unsigned int j = 0; j < 25; j += 5)
    {
      // temporaries
      uint64_t one = m_hash[j];
      uint64_t two = m_hash[j + 1];

      m_hash[j]     ^= m_hash[j + 2] & ~two;
      m_hash[j + 1] ^= m_hash[j + 3] & ~m_hash[j + 2];
      m_hash[j + 2] ^= m_hash[j + 4] & ~m_hash[j + 3];
      m_hash[j + 3] ^=      one      & ~m_hash[j + 4];
      m_hash[j + 4] ^=      two      & ~one;
    }

    // Iota
    m_hash[0] ^= XorMasks[round];
  }
}


/// add arbitrary number of bytes
void SHA3::add(const void* data, size_t numBytes)
{
  const uint8_t* current = (const uint8_t*) data;

  // copy data to buffer
  if (m_bufferSize > 0)
  {
    while (numBytes > 0 && m_bufferSize < m_blockSize)
    {
      m_buffer[m_bufferSize++] = *current++;
      numBytes--;
    }
  }

  // full buffer
  if (m_bufferSize == m_blockSize)
  {
    processBlock((void*)m_buffer);
    m_numBytes  += m_blockSize;
    m_bufferSize = 0;
  }

  // no more data ?
  if (numBytes == 0)
    return;

  // process full blocks
  while (numBytes >= m_blockSize)
  {
    processBlock(current);
    current    += m_blockSize;
    m_numBytes += m_blockSize;
    numBytes   -= m_blockSize;
  }

  // keep remaining bytes in buffer
  while (numBytes > 0)
  {
    m_buffer[m_bufferSize++] = *current++;
    numBytes--;
  }
}


/// process everything left in the internal buffer
void SHA3::processBuffer()
{
  // add padding
  size_t offset = m_bufferSize;
  // add a "1" byte
  m_buffer[offset++] = 0x06;
  // fill with zeros
  while (offset < m_blockSize)
    m_buffer[offset++] = 0;

  // and add a single set bit
  m_buffer[offset - 1] |= 0x80;

  processBlock(m_buffer);
}


/// return latest hash as 16 hex characters
std::string SHA3::getHash()
{
  // process remaining bytes
  processBuffer();

  // convert hash to string
  static const char dec2hex[16 + 1] = "0123456789abcdef";

  // number of significant elements in hash (uint64_t)
  unsigned int hashLength = m_bits / 64;

  std::string result;
  result.reserve(m_bits / 4);
  for (unsigned int i = 0; i < hashLength; i++)
    for (unsigned int j = 0; j < 8; j++) // 64 bits => 8 bytes
    {
      // convert a byte to hex
      unsigned char oneByte = (unsigned char) (m_hash[i] >> (8 * j));
      result += dec2hex[oneByte >> 4];
      result += dec2hex[oneByte & 15];
    }

  // SHA3-224's last entry in m_hash provides only 32 bits instead of 64 bits
  unsigned int remainder = m_bits - hashLength * 64;
  unsigned int processed = 0;
  while (processed < remainder)
  {
    // convert a byte to hex
    unsigned char oneByte = (unsigned char) (m_hash[hashLength] >> processed);
    result += dec2hex[oneByte >> 4];
    result += dec2hex[oneByte & 15];

    processed += 8;
  }

  return result;
}


/// compute SHA3 of a memory block
std::string SHA3::operator()(const void* data, size_t numBytes)
{
  reset();
  add(data, numBytes);
  return getHash();
}


/// compute SHA3 of a string, excluding final zero
std::string SHA3::operator()(const std::string& text)
{
  reset();
  add(text.c_str(), text.size());
  return getHash();
}
// //////////////////////////////////////////////////////////
// tests.cpp
// Copyright (c) 2015 Stephan Brumme. All rights reserved.
// see http://create.stephan-brumme.com/disclaimer.html
//

// simple test suite for hash-library
// g++ tests.cpp ../crc32.cpp ../md5.cpp ../sha1.cpp ../sha256.cpp ../sha3.cpp -o tests && ./tests

#include "../crc32.h"
#include "../md5.h"
#include "../sha1.h"
#include "../sha256.h"
#include "../sha3.h"

#include "../hmac.h"

#include <string>
#include <vector>

#include <iostream>


struct TestSet
{
  const char* input;
  const char* crc32b;
  const char* md5;
  const char* sha1;
  const char* sha256;
  const char* sha3_256;
};

const size_t NumTests = 100;
TestSet testset[NumTests] =
{ // generated by PHP script, SHA3 vectors from https://raw.githubusercontent.com/gvanas/KeccakCodePackage/master/TestVectors/ShortMsgKAT_SHA3-256.txt
  /*
    $lines = file("ShortMsgKAT_SHA3-256.txt");
    for ($i = 1; $i <= 100; $i++)
    {
      $hex  = trim(strtolower(substr($lines[8 * 4 * $i + 3], 6)));
      $sha3 = trim(strtolower(substr($lines[8 * 4 * $i + 4], 5)));

      $msg = hex2bin($hex);
      echo "{ \"$hex\", \"".
           hash("crc32b", $msg).'", "'.
           hash("md5",    $msg).'", "'.
           hash("sha1",   $msg).'", "'.
           hash("sha256", $msg).'", "'.
           "$sha3\" }, // $i\n";
    }
  */

  { "cc", "40d06116", "a2e970f170961ce879190d64982c94ec", "a6f57425137e9aa54537f0b3f5364ce165aedb0a", "1dd8312636f6a0bf3d21fa2855e63072507453e93a5ced4301b364e91c9d87d6", "677035391cd3701293d385f037ba32796252bb7ce180b00b582dd9b20aaad7f0" }, // 1
  { "41fb", "82d4472f", "70d3e9af7232e67b6b6f3e71f7399438", "a6a5d330d9928b452ca7e34e946c52ea4f6eaa15", "0f8fa28112230a7a0b3cabcb64d37bd38f5023b1391e38f89a9b29f32b0aefbc", "39f31b6e653dfcd9caed2602fd87f61b6254f581312fb6eeec4d7148fa2e72aa" }, // 2
  { "1f877c", "c54a0ec4", "f7ac37ba79246d6a36b49c0993791110", "d17212f7dbfa31d10b68d480bc91cd3e1596be86", "ab0213910396c8d94cbf3b6c97de1fc97fc55cea4b6b6cc25ea4b71e7e7bc28c", "bc22345e4bd3f792a341cf18ac0789f1c9c966712a501b19d1b6632ccd408ec5" }, // 3
  { "c1ecfdfc", "5a545e7c", "af9116916ca42299e557e55cfa3e1591", "dc148b935ff1614ba17bdbad6e5392179e412f0d", "7df4925396138971f4a733680107ce202c5c5991dbc8737ad07eb4da85a06f85", "c5859be82560cc8789133f7c834a6ee628e351e504e601e8059a0667ff62c124" }, // 4
  { "21f134ac57", "d086fa95", "29057856dd5548ac8c1cca4b27489449", "404be2d420abc459707149bb79c8065aded00e7e", "a0ba0190c23bf1140cf5bf5a07e1140df55389792283bb6a8b5867a539ac7931", "55bd9224af4eed0d121149e37ff4d7dd5be24bd9fbe56e0171e87db7a6f4e06d" }, // 5
  { "c6f50bb74e29", "cdff1654", "d175ad6887766bf159f1bde8e514465a", "6685c62b13f7fc0703fd246c050a19cce98fcd97", "e2c0a1c005c4aa91ad89e509b603c5c0f474a18df291e5ca378725a9ad76fb09", "ae0cbc757d4ab088e172abfd8746289950f92d38a25295658dbf744b5635af04" }, // 6
  { "119713cc83eeef", "54465641", "27e281ab44bce27391bc7cee7b0f3437", "1fcd96a8c76f4d884c744bf840507acfe646ff76", "96e043b747fa1737d63d83b898987d3e70c816175a50333077ce4e7602255975", "e340c9a44373efcc212f3cb66a047ac34c87ff1c58c4a14b16a2bfc34698bb1d" }, // 7
  { "4a4f202484512526", "696ab8df", "90ea55f66c4b5239df52b05349455037", "928a171eacc5698811ef2992712458a9fa043955", "1b1c9bf7e050805714c81c03a05a6961e924bbaca37cb5b9998cb46bb2be4fa5", "ba4fb009d57a5ceb85fc64d54e5c55a55854b41cc47ad15294bc41f32165dfba" }, // 8
  { "1f66ab4185ed9b6375", "c0b622ae", "164a8c44008d14028fae0cf7b9d566aa", "8b81a9a58e987edb923fe6118ca6099cb71ad55a", "0eb3c0f5f345bd6cf98cf870886abc1817a0c5dde08d62f870a6b4a006979ee3", "b9886ef905c8bdd272eda8298865e0769869f1c964460d1aa9d7a0c687707ccd" }, // 9
  { "eed7422227613b6f53c9", "2029782c", "e57498c9318a515fcd8980dc319aa10a", "261830dfe450e4d58e5315cb0cb9d31c725cc406", "9758c2ee9d9782c6a3e60b394b16837689ab6f13c4157d45fc6ee7597a59448f", "fab8f88d3191e21a725b21c63a02cad3fa7c450ef8584b94cfa382f393422455" }, // 10
  { "eaeed5cdffd89dece455f1", "42fcfb29", "5e49b16a26a63aef2912956918f6a919", "c0507f76cea3e4d46edf256d49fe0ccf0ec2145a", "0a5f39f0e909a63bc93a76a21e94d62a0451d9f8123ecc5a59e5bd240b2850b0", "9363acd3f48bb91a8998aa0e8df75c971770a16a71e7d2334409734cd7d0a9ee" }, // 11
  { "5be43c90f22902e4fe8ed2d3", "4fbb1441", "e907bfc096655d56d3799b422f0ddd16", "f089f569228795551af51bbff935ac0e6b625c78", "c6057a042954e08be906ff710b042dbf6352f8b958b8ade708439063710bb5e2", "16932f6f65deaad5780e25ab410c66b0e4198eba9f4ed1a25ee24f7879faefe2" }, // 12
  { "a746273228122f381c3b46e4f1", "ad022e12", "ae0549cbb3704b5d2d1f18dbbc159de4", "2b269ce05fc8392c0333f8d1aec8ce32ed969e32", "7c48389c069dedf88be6534d34dfc20c109ce40788b96ddebc1e9209c0ca49de", "1c28100e0ef50671c7ea3e024fa3ba9da2ebddb4de264c3a2426c36ad3f91c61" }, // 13
  { "3c5871cd619c69a63b540eb5a625", "1ca57d8b", "c4d0ef66c3ddc1f3ee998de21e6834ec", "88b2b64f3ada91ed6cd29e80b8c67e2cd6ff555a", "82af41b707f8336fadc9fdbfc00b50d11a27b46e1e022ed4865896dca259377d", "8183be4875fab7ec5f99ed94f5f900cf1d6b953d8f71e1e7cc008687980e613a" }, // 14
  { "fa22874bcc068879e8ef11a69f0722", "0e69af1c", "3af22d0558d6cb039e164bb47bc48265", "46234cafafbce55281c87102559f47450976bb08", "f479cdfa3488c4d8e44c8e10167a54cbc1142a7a75bb5a0ee6aa647a93a65d0f", "3b1a6d21fe44691dac4eb7c593a6d8523cb606e63cf00e94d711a574248daca5" }, // 15
  { "52a608ab21ccdd8a4457a57ede782176", "1ccb278f", "72d4071b78731c61b61076067f3ef40b", "2d64a7c42ce0cb8dae2617effd031b5fe328eef6", "7ae441ed62ba0263f194386043ac4ba452bc593a5a9ad001da5c70ddc533abb1", "2c7e7cb356fdc68ec8927e499d2a6bae2b781817919c829ebbe8225baed46967" }, // 16
  { "82e192e4043ddcd12ecf52969d0f807eed", "4e448a12", "e880a1c8344c01c1aede282f4a0c6930", "f4c49546bb55bfadddb0e8f0c14add76039250ce", "b06558895e83f861bcdc2556f7e6377468341b352745caf2605df544275e9949", "c7b12eff692d842110cc39ac60616707acb3f9b0f1cb361b94577efc529ca26c" }, // 17
  { "75683dcb556140c522543bb6e9098b21a21e", "4b50b9e1", "9b92909591db3d4957047c6bb3c06880", "bb479acce571cec0775532af7c7b19c2a719456d", "7da11d5a5c7e39d51d7509bd8f5819f7110a3f7aecaf314cf7d6a5943e70ac66", "493ebaebc04776f4e067555afa09b58c850fdf1b0e22d4bf006ce41c091dc762" }, // 18
  { "06e4efe45035e61faaf4287b4d8d1f12ca97e5", "45cad288", "b1f1c44c82ba049a4f540e0206cdd045", "82c2585cbecc9ade3bd64895a84a85bb97952e43", "0b9e07de6287032320423371a8ee66e149ae208e248587443e122c9f8cc600fb", "1d01f3120ecfbdd28dce44317666cf864f52391b9eca3843db45667c2e0a98ad" }, // 19
  { "e26193989d06568fe688e75540aea06747d9f851", "1a5edc0e", "9e0e0f99c95fa883fc65e74bc94149e5", "bdfd2785148f71a6ac5790d3e65cb7638a3efdc6", "e88d019b09a378a39bd5bfa33215c358303c7f13004ce3a12650aa70d01b8ca0", "2c1e61e5d45203f27b86f1293a80bab34192daf42b8623b12005b2fb1c18acb1" }, // 20
  { "d8dc8fdefbdce9d44e4cbafe78447bae3b5436102a", "2803f7c6", "2c6e363d11a7a5d810dce54d3e28c409", "3ac65fbaceb1591da5b96bfa50c825e7e7c61a20", "fdfa03e288a4af6d325049bfc4b76e9c8178321d484ae88fb1025d26bef78679", "ad0e3f29767067e929d1cecd95582df8f2a9beb92eaa27eeb315f620365a9244" }, // 21
  { "57085fd7e14216ab102d8317b0cb338a786d5fc32d8f", "64ba010b", "92ca1e70af2d4926eaca1acb0a7204da", "88ba72d3f7331c8235bfac25f0af1fce30534676", "a05e71cd70727ee68b029f36bdd7838dc3c69bbdb956c21b68dfa439421af5f9", "2b4eb5de20e86074cabb55bfa63a5c8c6ae15679302061845b9cf233e17c906b" }, // 22
  { "a05404df5dbb57697e2c16fa29defac8ab3560d6126fa0", "53948692", "1ca08b8e52e2d6956504aeeb4175d98c", "1c3329ab472a203c11a74936c786177462822bd8", "7ea63cd84b9f0b9ce4daf224835d06e029a4601eeb5a37496799a3d84ed42f8d", "6ae04c6c6f3651f1f64c0ad69733990b41747c93f87acb813bb25bb1fc0eff07" }, // 23
  { "aecbb02759f7433d6fcb06963c74061cd83b5b3ffa6f13c6", "5e55297b", "f9715ac28f13a90a4dfb017aee4dd9b1", "76538ebb720710421b935ce23fbe37543e090cb6", "19045e899afc4a35967ca5c7970a5b0ddc99f70f69716dcf62c46825be0aa457", "40f9f55bc55da466bc3dc1f89835a64094572de73d64ed6646a1d3b667be70a9" }, // 24
  { "aafdc9243d3d4a096558a360cc27c8d862f0be73db5e88aa55", "f7f32407", "6d71d851e6fc1cc3a44be9c16e546cb9", "e294d8908f122b8d7ccfc1223058636eb276d405", "4c8487b6a2561455e1535c1462722c1042fe2f478ead5a6f65f39bad004cab59", "c64becf7b75fc885d5853924f2b7d37abcefd3da126bb817697e1a09152b1ebe" }, // 25
  { "7bc84867f6f9e9fdc3e1046cae3a52c77ed485860ee260e30b15", "edbb117c", "8a104d5ba0f66e66042486f7e106fe87", "a1a306755332086effbf26d6c20af9b50e415285", "8c41fa0b07f82b9cd0026de7e38059680f69f2d20f426596e88b4d800aa638b2", "57d46a6bc8fab33601538dad27f98c66443032cc3912434c28eb88d0af44c52c" }, // 26
  { "fac523575a99ec48279a7a459e98ff901918a475034327efb55843", "39f0e9db", "7de1128f904f39f92f1c51989c94aaf8", "a58b983e90870a964296a164bd02b62ffff7e12f", "a84dbb8acfe2c5ab82c2ed371040a3221f7cde534baf134e24534a3b5105da69", "7c956503d5b4dbb764ff8e66fa74ce0f9132da90ea3543f669c9dd08e413e33c" }, // 27
  { "0f8b2d8fcfd9d68cffc17ccfb117709b53d26462a3f346fb7c79b85e", "6b2ad7a1", "d41bdd74f0dbbcb034ff01402a163736", "ae41363098fe07213fec440bb03be81aab0fb7f0", "afecd3e65dcb52c4c8625471842d007575e4cb33942ac4e6377014cce668ba4f", "6de164a9626d5a4f54d854ac158994f35a8e362ecc753f55182790934a2e0d06" }, // 28
  { "a963c3e895ff5a0be4824400518d81412f875fa50521e26e85eac90c04", "51e5475b", "bff43c6ee76dffa8850237aa11ec11b9", "ca408361c45d44c71e90fb6b4c69955d08c58ecd", "7ac86f1239e32eedaeaa8ed184445c8b017e9124a5d283cf4393fd80ad3996f0", "b760312bd1b279fc672479d21c5ed349e5fe96f08940237b4515452721c49a16" }, // 29
  { "03a18688b10cc0edf83adf0a84808a9718383c4070c6c4f295098699ac2c", "0807648c", "268c59a326b83e17f42bd7500c916290", "a9b323ca196695d80ce6cfb26ca9a8b77e51b008", "5e9c68da67265b87ded2f3b2a93744f5b7ec832419916aadf0ea78b63ef97432", "94fc255de4ef19c0da4b09b2e2fac21f20048b46f17c30685abe40d5c743f375" }, // 30
  { "84fb51b517df6c5accb5d022f8f28da09b10232d42320ffc32dbecc3835b29", "dddccc2a", "6b393afb85a556ff1b38ceef3ba946c6", "cda4605fb1409be66738df89f20f3da5e6609056", "9929cf1e6fac383f3a2fa322af8d125753bcf9c28ededb9e63a45da0cf5c5984", "39a4a0ffc4603698ae0a4f3d24b1bc42ac7a2d7d923e7a5d602453e82d5323c5" }, // 31
  { "9f2fcc7c90de090d6b87cd7e9718c1ea6cb21118fc2d5de9f97e5db6ac1e9c10", "c90368f7", "b4b5b22fea8d7a60d07859b46b03b810", "5eb1836714dd13760ec23a8187c3c64086dcc3f8", "ace84f09d49226d391e3704ff36b0cb5a61c0a0727e6bc5a7188e5c273a740db", "2f1a5f7159e34ea19cddc70ebf9b81f1a66db40615d7ead3cc1f1b954d82a3af" }, // 32
  { "de8f1b3faa4b7040ed4563c3b8e598253178e87e4d0df75e4ff2f2dedd5a0be046", "e43f6c2b", "c09b81300dfe5d57cd53b29971ef55ca", "2299eef7f22c57e489c29155e632b10d6ad28761", "072d632c7b4d6cf25f3c18336d572d22759d5a78e5cf9ee5f3d844f2b6345cb3", "1c57fe0e38cd3a124eaa6cd87f70a079bccc073a341e8c0eb1976fb3a3f7b774" }, // 33
  { "62f154ec394d0bc757d045c798c8b87a00e0655d0481a7d2d9fb58d93aedc676b5a0", "2aa78ff5", "c1b47551dbd87287e3786d29f0ead5c2", "b53c51b62b98bb6a897bdf2e4de297ee6f80d64f", "2d503f6f3432d37088b1890299259db30d158665604ea63e82cc43548412bd35", "a905603b186ef4f2d5b2d1bcfda504c68ed5eb9b0c7b7ea2a001575f5aa69e68" }, // 34
  { "b2dcfe9ff19e2b23ce7da2a4207d3e5ec7c6112a8a22aec9675a886378e14e5bfbad4e", "d9c9c459", "39a82f09125434582385b8b09ef042d8", "303ea353679f64e0e7ea72f308908091b3f798b6", "c4a3feb41cd26f040c26f0b0ca12f8e3d55f0bb39771ee087c5086118e098146", "fffd39f7c451788eb0316f429ea0a7c0ac8091657aca28f1560ed5775e8c4c12" }, // 35
  { "47f5697ac8c31409c0868827347a613a3562041c633cf1f1f86865a576e02835ed2c2492", "5b1508f1", "cdb044f567cde9d20b264add4edf6a56", "499279bf8d5c7ac1f0ae11de2a7a774bd949ad17", "cb9e4c92d9cf019f4c3156ab791350ad8e42e502f7f2eb64e47466aebbffd283", "6f55becd168e0939ba2fa090257b1727fc66491a44493279a5beacb9e3435324" }, // 36
  { "512a6d292e67ecb2fe486bfe92660953a75484ff4c4f2eca2b0af0edcdd4339c6b2ee4e542", "9c7afee9", "a3f7368cbeb89e1ed9564c147bc62ccf", "1aff151f3d6e3c71a2cfb9cd0170a1f907aa2e28", "5f4b5f2cebc6e5c7d8939273d3c63597efb8e7414b7373dfa4060041252f07ef", "84649bffcd48527b9288e8da5f52fbab2604dc5a91c4b0b87d477dbd7b40b6ae" }, // 37
  { "973cf2b4dcf0bfa872b41194cb05bb4e16760a1840d8343301802576197ec19e2a1493d8f4fb", "2466a23c", "91a3389423f3aad784cfa032e8511fac", "a950d6ce4683c8e9c97db7ec3ca8770ae1d78410", "6bcd52fae737be4465e3688ce0620b668d1b3b926bf12265bdcf215e22bee702", "d4055b4e3e2aea1c67cc99fd409d574e53e1e296cf9eef73c472ab92a6cb6609" }, // 38
  { "80beebcd2e3f8a9451d4499961c9731ae667cdc24ea020ce3b9aa4bbc0a7f79e30a934467da4b0", "9869fe61", "4e9f41ef61570fb59c1905c127a1dbb6", "d46154473fd626ed75429dedcb6d18c14b84bf09", "61c7b8427e946955efc51dcbe85c33f770f35c9f87cca931a220435cd5cb52c4", "5694ca2f3b9962226a87163ab38325bcdc898a732dfeb2c36db4eb88616b8741" }, // 39
  { "7abaa12ec2a7347674e444140ae0fb659d08e1c66decd8d6eae925fa451d65f3c0308e29446b8ed3", "30ec2a35", "59b97d4bb9621edd21508e983d1e0162", "50aa4e5b0d5aa3fe38a7b6539060a393f132e754", "7e9d4111cc710b6b24290fcab6934ad08cd4b239c1a0cbdde71f685f0a1e6fd9", "8cf287ad03ab4a74086620cfa4cce74f48fa5cdb15ec02b1f721736a4f849e60" }, // 40
  { "c88dee9927679b8af422abcbacf283b904ff31e1cac58c7819809f65d5807d46723b20f67ba610c2b7", "5a9f457c", "dd004f029f857a4e9acfdc516191dd0e", "baf9d3c7d2b18f36ac2981c7f071e63bbbfd3493", "2668d27f283bce5f7919d490d721aea6bbd0348332a2cde536dd4bc1912c55ad", "c5d5af22a4df9acd0c056fa30d8e240b679a20d4d2630260f779ff815ca82d7d" }, // 41
  { "01e43fe350fcec450ec9b102053e6b5d56e09896e0ddd9074fe138e6038210270c834ce6eadc2bb86bf6", "44d76f15", "28b66ebe60836815e0050c6dae6cb383", "a0a7388255f447285f5419ff96aad6f1818d6de0", "c60b5602cb8a1a23ec67b6c57ab41152ea1360a532b146a8e3195b2c23b32b48", "0ac75279adff65660464550a283fecd4e0610d88f35574c3d7ac5d22262a2fe8" }, // 42
  { "337023370a48b62ee43546f17c4ef2bf8d7ecd1d49f90bab604b839c2e6e5bd21540d29ba27ab8e309a4b7", "aef8f701", "66191acef6407facd6776248be2b2814", "deac10320e720100261ec67889ae36a13688c4e2", "612af005d7f47d3d7cd0e8cdcca4571139fef602e82e64e7e027189e5b1b8700", "81917ae290dbba17289a8a67e5c2e8b12d3dde0efe9f990198a1763ff4f3dda7" }, // 43
  { "6892540f964c8c74bd2db02c0ad884510cb38afd4438af31fc912756f3efec6b32b58ebc38fc2a6b913596a8", "a1739060", "72f332cb3d1ee64f1956eea0f9f65b64", "42b6406d40071927e77a0d7749de78a7f426b290", "42633916521313c491f53a8aed2de5647bd21befb8423e31397e3ba76e7cc43a", "138e75e72fddd927e591315af8d3aba280efa36230a3309a97bcde5a78c31589" }, // 44
  { "f5961dfd2b1ffffda4ffbf30560c165bfedab8ce0be525845deb8dc61004b7db38467205f5dcfb34a2acfe96c0", "2ad774c3", "e729ab5e0ed1eda842771b4cab4f7e24", "3e1b964d0dd2c054862c038488b8ab0f1c38f13b", "bb15e052c6167318eb92530ee2a6a38bbbb03888b27ccf17402dd91336742e7c", "21bcdad3fef3e5b859cb0912a2991efa661bad812747292ef0f79a8fcc6b4e98" }, // 45
  { "ca061a2eb6ceed8881ce2057172d869d73a1951e63d57261384b80ceb5451e77b06cf0f5a0ea15ca907ee1c27eba", "b0ecc329", "6886c2fe3bd64c5d7e0a92dd9d3de9c1", "75f7e1712c432f990d5d47bb410bc0ed1f01d340", "1debaf5b88a075e43a0ec8765fa3830b3e08655162b28ce9a9357c4424869fa5", "8d6fd9c559b0b4948f91337916084c0082a16a0755b0a00811096e973e48b3c8" }, // 46
  { "1743a77251d69242750c4f1140532cd3c33f9b5ccdf7514e8584d4a5f9fbd730bcf84d0d4726364b9bf95ab251d9bb", "26ce2541", "48a07b1571b3de06d65a88e95ca57b50", "2c2bb28f64a17b4054376a503bb9c57f1e142bf4", "de11c81dd4609233c6a2d73a3ac06a20e312e6e1c0f5d351bc72b3d5c40961a0", "1dd23ae7aadd61e712bdd82bd60a70dd9d66c9fd79dbfd8669e3eaabf7901cdc" }, // 47
  { "d8faba1f5194c4db5f176fabfff856924ef627a37cd08cf55608bba8f1e324d7c7f157298eabc4dce7d89ce5162499f9", "8ebccf97", "3dea64ea9ed114752e867afd704a9762", "b8be5ea10dee2d8190d82dd47b94d6a8019baec8", "ecd5464831f5a8b034f07b3ef7b96d096751d76425d0771bbfaeed9894721ccf", "34f8607ec10c092c1ba0b6565ce6197062c4e1a35a8e8c723e48a2d2416c3790" }, // 48
  { "be9684be70340860373c9c482ba517e899fc81baaa12e5c6d7727975d1d41ba8bef788cdb5cf4606c9c1c7f61aed59f97d", "46a4b59a", "83c390e922be9d42cf14d8df71bf3541", "7a6281ec0b58c82a80b1ee18e8bbf22e6d84df60", "171300d37d33b2f8942ed26aa86c67346fc0c9710c6e59a83472c4dafc033aef", "19a8577fc90fae5d6a6b2e0c1ff155515502cfa1757029c09bebbfa263d9a363" }, // 49
  { "7e15d2b9ea74ca60f66c8dfab377d9198b7b16deb6a1ba0ea3c7ee2042f89d3786e779cf053c77785aa9e692f821f14a7f51", "f5661d98", "730487d5390fd8a72bcde0109529f614", "6e17b4575af829c6ee18e24fb6eae024a9baaf49", "7863f2acd39baee07b57e2e65a391dc828c05de45821e52e3b908b43a9ad9705", "9d9dbb4ce7d01d009e72a66051acc16805e49f598cbe430c5d4c22a881a64b3f" }, // 50
  { "9a219be43713bd578015e9fda66c0f2d83cac563b776ab9f38f3e4f7ef229cb443304fba401efb2bdbd7ece939102298651c86", "97779492", "2c2ac042030f8f1645df0e9575bd2d41", "29309a4a739f0e6ac4ef1fd38871c9a02a326d10", "ee0924a0f948eba8bc731c0489da61d6665829fc2e6ea1b5378964f5a77dd7dc", "13f0d951b64481135466cfccbe52418cc1d03fb16b5b696c35d724f6f55cbb6d" }, // 51
  { "c8f2b693bd0d75ef99caebdc22adf4088a95a3542f637203e283bbc3268780e787d68d28cc3897452f6a22aa8573ccebf245972a", "2d2ad237", "d72991ae45a2f1deaf888c4e9886d3fe", "88970ef3bb5191e6927a639dc105835e1b98aaba", "f7f7c47d804f0d9455426e236676d6e9ddd91bf99e40e23220ca911d99d88ada", "fb2fe7b00b75c42305cf31de14d98f904e8c46dc57bb6f94c282ca8c13dc45db" }, // 52
  { "ec0f99711016c6a2a07ad80d16427506ce6f441059fd269442baaa28c6ca037b22eeac49d5d894c0bf66219f2c08e9d0e8ab21de52", "69f4b6eb", "590fcad19889b907e3d6bbdf991edc93", "a63c6fd614d977f015fcc29936dfbffc9e8f2d33", "ee99da04f780abe64d2c1ee1170e7f678c50683a7b9303a84678c6ebdf9b9a7f", "d54cbf7d5c80ae11a0d0bad4e95ab18b5f07c970621f3936447a48eef818d06e" }, // 53
  { "0dc45181337ca32a8222fe7a3bf42fc9f89744259cff653504d6051fe84b1a7ffd20cb47d4696ce212a686bb9be9a8ab1c697b6d6a33", "27569834", "e087a2fb0e175b748d68833fbddad14e", "01c8e2d5274a8daf51bb207eee328c33b49592f1", "860c4d344cd31e574e20ae9a54ed146f690823930e43947e89adfeda3da669de", "ff050a45adeef4cfc7d964102ba877c80320a37794893e6865965ec2547cd4c9" }, // 54
  { "de286ba4206e8b005714f80fb1cdfaebde91d29f84603e4a3ebc04686f99a46c9e880b96c574825582e8812a26e5a857ffc6579f63742f", "43ab2765", "1c4f5048955f692961be8682e7226025", "e81bed804597822ac47ca7a507976972eece5c60", "99a9fa276e7471535a13e41abdb1dd5c1013ed1f4d57a4c7b9433455d3cdc705", "1bc1bcc70f638958db1006af37b02ebd8954ec59b3acbad12eacedbc5b21e908" }, // 55
  { "eebcc18057252cbf3f9c070f1a73213356d5d4bc19ac2a411ec8cdeee7a571e2e20eaf61fd0c33a0ffeb297ddb77a97f0a415347db66bcaf", "4d3ce864", "6d0557d282d4ddbfa3f0607030db59ac", "d493f943e6d7e52989990f1bb88c835e9a14ab59", "c8d39c9dabb62cb284be55658b05412b50ff3eda8ac98ae6bc616f466aeb2650", "f7bde239ad087aa7dabe42cc4d3c49380a026cd239a7faaf34a2233469a44a4d" }, // 56
  { "416b5cdc9fe951bd361bd7abfc120a5054758eba88fdd68fd84e39d3b09ac25497d36b43cbe7b85a6a3cebda8db4e5549c3ee51bb6fcb6ac1e", "a49c059d", "2a51205e846de5953d7e1c6900fc574c", "24a9ea1d842750fb805a8e1985d7cfaeca799fa0", "03f7b846ea8f9e26760eeaa30eae500646819842d6af87ca64275b865aaf43f7", "ef845aac2aaf0a793108204ff380e0a30f2558e7acde4531ab22f8ec79e26a69" }, // 57
  { "5c5faf66f32e0f8311c32e8da8284a4ed60891a5a7e50fb2956b3cbaa79fc66ca376460e100415401fc2b8518c64502f187ea14bfc9503759705", "63822070", "2d4d21e2117980b30ee1827876ae37f7", "45ec45c12ae8056e31df5578659ac18b077e0337", "463a6a7d0765f0a520f4dff288c4caa7c4c0ce3080e3703cd47122a7ee8b9434", "26db514e01e034c678b636d40ba367da2f37f67078bb576ff2b8559b3517484d" }, // 58
  { "7167e1e02be1a7ca69d788666f823ae4eef39271f3c26a5cf7cee05bca83161066dc2e217b330df821103799df6d74810eed363adc4ab99f36046a", "a2c861c5", "8d04f5ae0093555f98532d29e062138c", "ea91f748c7a9137eda2a82d7e8e9dbe54d574949", "c82776eca46928e0d5b3d1c43db40953cce11013cb3528fec5b882fc5b286fc8", "5dbd4b558463196211465c1fc32401fc2d8e41ebc5e6badd1d8f7c4f090f728f" }, // 59
  { "2fda311dbba27321c5329510fae6948f03210b76d43e7448d1689a063877b6d14c4f6d0eaa96c150051371f7dd8a4119f7da5c483cc3e6723c01fb7d", "0bf07be9", "0d84254eb21804f52cc6155c736bfe2b", "905fac724e298c9849ae82c0c0d3a494a8060085", "55d4462e8486ebc14e2f5ba7f573330faf3a0d56bdf7701ee2820aba265d7ac0", "355c79fd6e6fa88ed402b6979fde1ed805498abeb101f4231b5d64d1439d552d" }, // 60
  { "95d1474a5aab5d2422aca6e481187833a6212bd2d0f91451a67dd786dfc91dfed51b35f47e1deb8a8ab4b9cb67b70179cc26f553ae7b569969ce151b8d", "cb5e3049", "dca6b7cded7224dc17e8c7e506f4e011", "b17fb3167bc83a7375ff6ddcd5f0b552ad9ddc41", "4d78228bf419b23d867082d8d5c066a4aee56a9bb54224d3b5cbd2c04364d99c", "3d9c9bf09d88211c7e0056112d073ee85d00acaa4da7a668fa017b3273cd4d4b" }, // 61
  { "c71bd7941f41df044a2927a8ff55b4b467c33d089f0988aa253d294addbdb32530c0d4208b10d9959823f0c0f0734684006df79f7099870f6bf53211a88d", "4eabb06f", "fa630a5284e5180afa75d6ba9a0ff421", "5792719abbd47647358eb65529abd4136d501af5", "48d4ed4341aafba1f02bbf72eeaf2bf5991c04ea3c643d7665f0130fffdc9165", "67980d28e2e658e7a24a2593a28167a13d907d06f47729d47ca4fe1772f8b3df" }, // 62
  { "f57c64006d9ea761892e145c99df1b24640883da79d9ed5262859dcda8c3c32e05b03d984f1ab4a230242ab6b78d368dc5aaa1e6d3498d53371e84b0c1d4ba", "8ffc4b50", "90d5671bdc15f8f96c3745f6f6020a8e", "632ee5446b709013fba8123b67e49dc7bdcc4c4f", "ce122fb56c82bf0cf7953b837e2f00cb0546f5b5d91f7af3480f659ed6152390", "a8df6b76df41994f7593f1a81967e77ee180e31183d1c4a569db854e61e99b05" }, // 63
  { "e926ae8b0af6e53176dbffcc2a6b88c6bd765f939d3d178a9bde9ef3aa131c61e31c1e42cdfaf4b4dcde579a37e150efbef5555b4c1cb40439d835a724e2fae7", "ded134c1", "f8885d6cda92c999dc4bee554df7dd2c", "6c4664cb736cd563f74f52cea42e33d6d617f153", "f4a1a02e8e35822107cc08b5b21b661c058e2825f3c7cb2a3b6d40f3ae89211b", "27a6441ee939b46e2c378d7afeb0e891c47a28120e488eff0ab71af08788ceb3" }, // 64
  { "16e8b3d8f988e9bb04de9c96f2627811c973ce4a5296b4772ca3eefeb80a652bdf21f50df79f32db23f9f73d393b2d57d9a0297f7a2f2e79cfda39fa393df1ac00", "e891cf16", "09ceb3a6fa3e2d38467a6969d43f6587", "6ba94f05cfa29501ff47ae917e18763e063229da", "16b1449186ef6d27ddf9f8ddfe23c59e51a953833c7df2e8c6a7528403f3ba68", "c4bb067383002db44ca773918bb74104b604a583e12b06be56c270f8b43512f2" }, // 65
  { "fc424eeb27c18a11c01f39c555d8b78a805b88dba1dc2a42ed5e2c0ec737ff68b2456d80eb85e11714fa3f8eabfb906d3c17964cb4f5e76b29c1765db03d91be37fc", "82e3941f", "09f55194b57e25646de7c5e4a8635f5e", "1e2895343ba31a9e32730f8156c68369e3f4132c", "9d91ce1295f7acca7bdb2e2ff0794e5e2917509fe03bbcfb34bc8dd7e536b8fb", "ae773915ca642d80413330c9e0ee9bd06653c0023c5c0277100f3b1526eaa51d" }, // 66
  { "abe3472b54e72734bdba7d9158736464251c4f21b33fbbc92d7fac9a35c4e3322ff01d2380cbaa4ef8fb07d21a2128b7b9f5b6d9f34e13f39c7ffc2e72e47888599ba5", "e73f9991", "d561fc54a4d61467f7d72ea037bb9332", "ea1c325d0e91a757e2106792943361d47ce99bee", "f1737040e38e73ab3b4085ec8e1acf1e055a1ed8411e6cf867d0a5dca56a3364", "1cf9d6ce9cb658556b76cd7eba3e51393699ad500b1ab3f56172748db7f59667" }, // 67
  { "36f9f0a65f2ca498d739b944d6eff3da5ebba57e7d9c41598a2b0e4380f3cf4b479ec2348d015ffe6256273511154afcf3b4b4bf09d6c4744fdd0f62d75079d440706b05", "ae719e56", "313c5846da0836226ecbf50c324fb7c5", "0082b9a8ab38b32ac364e5f1a656cfe98ef9c931", "df0cd17c3fd3885653849bc8be8cad1f2171755e05176d448dc466fdb94ce780", "8d60e889e2b1020dad4b523301f5f6bbab6c781af276085af6765546fcfb95ac" }, // 68
  { "abc87763cae1ca98bd8c5b82caba54ac83286f87e9610128ae4de68ac95df5e329c360717bd349f26b872528492ca7c94c2c1e1ef56b74dbb65c2ac351981fdb31d06c77a4", "6c4cd72d", "53bfe40050067274fe7482d2a3b7986b", "328136f32226dc14f7e9dee5ba67863b669cb0d7", "6fe7f18c476330654ad42917435a5dd906c1c35f863cb2a8147a9fa10aa19c91", "dd4ff4b530552f48af9a7530a6464819ed1a5b733084f709e41daf1acb35ecfd" }, // 69
  { "94f7ca8e1a54234c6d53cc734bb3d3150c8ba8c5f880eab8d25fed13793a9701ebe320509286fd8e422e931d99c98da4df7e70ae447bab8cffd92382d8a77760a259fc4fbd72", "c957294b", "58a4f59c5a014d0d19f4b0807d3883db", "45905089a697d8542c78e1d206a0d87430fc0789", "54fe7d51e0cd082a42a4972acfdf8c59406c89ef95b79d659a84a0d07d121069", "7ac8d4bb53fc434dd8712daefeb474668f541418e6f617dba523d8392eb0766e" }, // 70
  { "13bd2811f6ed2b6f04ff3895aceed7bef8dcd45eb121791bc194a0f806206bffc3b9281c2b308b1a729ce008119dd3066e9378acdcc50a98a82e20738800b6cddbe5fe9694ad6d", "22bd0ff5", "bc3db75037ec1773fb11045a256001bd", "c29ad52ef807b4f73f3ec0b20999a996b3e462cd", "6feab1c9d115cc82efe3631535e964c3eeb5c3dad4c38d837717f8f10a3357b1", "f7b0e15a63232a2b800b23b311d357617ddfd1293e1ffe3f772692ade3427152" }, // 71
  { "1eed9cba179a009ec2ec5508773dd305477ca117e6d569e66b5f64c6bc64801ce25a8424ce4a26d575b8a6fb10ead3fd1992edddeec2ebe7150dc98f63adc3237ef57b91397aa8a7", "0ab24bd5", "9022f5cdff2c1f55ac3f5270f8d43484", "8b78f85b603c4b896cac77b41edee07c56d14058", "046155a4d0e52a53fc745278ded12590875fde9b66fa4e40a6638c1504f6d435", "b3d05af7e8c406a7c2709223791d3f5f4b3129329993220053a36293ac2b0e06" }, // 72
  { "ba5b67b5ec3a3ffae2c19dd8176a2ef75c0cd903725d45c9cb7009a900c0b0ca7a2967a95ae68269a6dbf8466c7b6844a1d608ac661f7eff00538e323db5f2c644b78b2d48de1a08aa", "8368ecf5", "92c203258dfb11755b1a6f3d15095f45", "e0a01e53a373265566a422f5209346605eca2252", "450effce3b3be76285be139ad8c15cdb36d847a70122e7754cc50da7b4f262e6", "6c47e2ea4ba29e17792defc4b707754c4664bde15168a5100bf881ec7c02b258" }, // 73
  { "0efa26ac5673167dcacab860932ed612f65ff49b80fa9ae65465e5542cb62075df1c5ae54fba4db807be25b070033efa223bdd5b1d3c94c6e1909c02b620d4b1b3a6c9fed24d70749604", "f5fc8790", "c125928b6cdf8b88f30efaacef4acba0", "732dbb9df2f07abc0ba482376a401acb1652fd1a", "88f8922134a0dfd8cf733e69a67f79695c157a12f004e0f41f47dbe25e929f11", "82a66bed668dcc14af12c14c976ce650049e9d1d9969b83d1dd3b6f1c07d252b" }, // 74
  { "bbfd933d1fd7bf594ac7f435277dc17d8d5a5b8e4d13d96d2f64e771abbd51a5a8aea741beccbddb177bcea05243ebd003cfdeae877cca4da94605b67691919d8b033f77d384ca01593c1b", "07c73070", "2ce5ec25b22239c42ad1e1fd4a38e7f8", "1196665356621ac4b74f7cb453a695ff51fe13a0", "6abd3225cde2afc0da502567790af919681ae1bee565192a06e5e34df7cdfe4e", "2f21d07d7b10683b9ac7a63e9fcc70cf9f887cb905f9bff5332551288b288524" }, // 75
  { "90078999fd3c35b8afbf4066cbde335891365f0fc75c1286cdd88fa51fab94f9b8def7c9ac582a5dbcd95817afb7d1b48f63704e19c2baa4df347f48d4a6d603013c23f1e9611d595ebac37c", "905d3872", "fa79da4e5b2df87ce3cc98ab763fd19c", "16b3a27baeeecb4c4c66c7f235fbd4f6c5839145", "0cbd201eca6a8fabf81c7377047a4a86f6dff090d665381fd884c6b5836b0902", "80202f01e7140db4fee490dcc50afafdf6a48ca33d362c7875b8e8db9c9d0655" }, // 76
  { "64105eca863515c20e7cfbaa0a0b8809046164f374d691cdbd6508aaabc1819f9ac84b52bafc1b0fe7cddbc554b608c01c8904c669d8db316a0953a4c68ece324ec5a49ffdb59a1bd6a292aa0e", "7e11cb91", "b9c451f86bc03e42fca7d2400609b188", "61d6f9fccf0a8c486dfa7df4417dc4d0c4e59149", "e30a878fdab9b75fc3d1f8ca1ea9c754817de4a471aa8e2abd6a7526e36274c5", "b2330a189047e3117479a2f20b3407a7d119e4ad431fe06ff1ff2a106f2ab3a2" }, // 77
  { "d4654be288b9f3b711c2d02015978a8cc57471d5680a092aa534f7372c71ceaab725a383c4fcf4d8deaa57fca3ce056f312961eccf9b86f14981ba5bed6ab5b4498e1f6c82c6cae6fc14845b3c8a", "dcdff841", "4551bc9250abb5607cca78ca71137a3f", "a95f70deef0c1733a02e6297a67aa61f0356e005", "9b163642ad529f4f0ac03b31cc22752599fd3cc3abdca1124cbce15eab11021e", "bb9b9bb685c241f8d63fdbf0dbaabcef7075add7ba405a2fffe7ad5b23e021c7" }, // 78
  { "12d9394888305ac96e65f2bf0e1b18c29c90fe9d714dd59f651f52b88b3008c588435548066ea2fc4c101118c91f32556224a540de6efddbca296ef1fb00341f5b01fecfc146bdb251b3bdad556cd2", "9ccb3cf0", "0dc5922d3935802af173a0825b8793cd", "6a59742f6d780f0161427835f743187e7c4de6c2", "e9d510eb338e4def24410eab6e26845a721aa9feba233d225f18f9a4d165c0f8", "f8316a367aa0316da3562f319d522e81f4a8bd2e2108d2532126f4a903704ba3" }, // 79
  { "871a0d7a5f36c3da1dfce57acd8ab8487c274fad336bc137ebd6ff4658b547c1dcfab65f037aa58f35ef16aff4abe77ba61f65826f7be681b5b6d5a1ea8085e2ae9cd5cf0991878a311b549a6d6af230", "c37eb643", "b14fd7247fb0600a4ee58d7d02c54573", "5ee0c3e4b737f3c6eb0537c6dba47e8e33334a39", "3bbc51465e6ad6c102c41cf61c0a510d191a522e7a8981eef519149d1bca5fe9", "89e3ebd02b229cd759612a5521d867ab2a1594bc0b1fe6a78b7954ccc84caf03" }, // 80
  { "e90b4ffef4d457bc7711ff4aa72231ca25af6b2e206f8bf859d8758b89a7cd36105db2538d06da83bad5f663ba11a5f6f61f236fd5f8d53c5e89f183a3cec615b50c7c681e773d109ff7491b5cc22296c5", "ba83a755", "a7b5bb4aa7b91d2853ec40c62ae71adb", "93e5e5a709b797bbb6e77a7ead3edec6d77d463d", "2ab2197e676517e8e900f69dbbfb6251e5dae049432d18adbdee892f42601e73", "2e7cc875305ea6bb9c2fc770b9d84fd93b96405df9b93307f6b5de26e135724c" }, // 81
  { "e728de62d75856500c4c77a428612cd804f30c3f10d36fb219c5ca0aa30726ab190e5f3f279e0733d77e7267c17be27d21650a9a4d1e32f649627638dbada9702c7ca303269ed14014b2f3cf8b894eac8554", "8bac7df0", "3bed3364dda24e4f121971960ace8cd6", "80ab947730a8b954b0e0108f9add9808ad9d4d4c", "a245a9c8b82fcf89b008b8f68393bdbf70a7750efa9f946a493025f5b929e398", "ecab75f28a728429cb433ec13310d1b850ccf522c38d2fa6dfa489963d6d6ca7" }, // 82
  { "6348f229e7b1df3b770c77544e5166e081850fa1c6c88169db74c76e42eb983facb276ad6a0d1fa7b50d3e3b6fcd799ec97470920a7abed47d288ff883e24ca21c7f8016b93bb9b9e078bdb9703d2b781b616e", "8666f487", "0b5846abc9ec2f73f95a046a98db99e5", "6d8d4d535d9478bfe55bc439bd72aa4ca059994f", "40319d72d16dd3b02e5049b28dd4de6bd6263796085069184ca868912d1a39ea", "021c9459d1451f3da4c07c029a8681945c87c5bebc6c30da1d95c5c49d8ab95c" }, // 83
  { "4b127fde5de733a1680c2790363627e63ac8a3f1b4707d982caea258655d9bf18f89afe54127482ba01e08845594b671306a025c9a5c5b6f93b0a39522dc877437be5c2436cbf300ce7ab6747934fcfc30aeaaf6", "b9b607f0", "8e7c9e38008a99bc26850bdcfa296fd7", "5a991f5a462d57c678f8b1a853d5e63510c0c01f", "9885b7b4d61caee20fcbe9a902496071f3113f34d144929891ee711b12f6d1db", "4642e21622f15b09b9413659680116bf2f96cac2384b8c79f1328d5dd36d7a01" }, // 84
  { "08461f006cff4cc64b752c957287e5a0faabc05c9bff89d23fd902d324c79903b48fcb8f8f4b01f3e4ddb483593d25f000386698f5ade7faade9615fdc50d32785ea51d49894e45baa3dc707e224688c6408b68b11", "07839217", "03e0732d64855293605a4ffea43e2151", "e734c52c2930b653dd5b01e04fde3ad7b9eaa51c", "64278b8ed65d1d1ee032d6289d74f7d5637d0538e7b05bcd099ca7cc8f6263e9", "8daa47c3572157266ad0276d5926aff2872f06b0cd7b974a80d7a6827d41d782" }, // 85
  { "68c8f8849b120e6e0c9969a5866af591a829b92f33cd9a4a3196957a148c49138e1e2f5c7619a6d5edebe995acd81ec8bb9c7b9cfca678d081ea9e25a75d39db04e18d475920ce828b94e72241f24db72546b352a0e4", "d74ac160", "bafd00316db76387bed7c84492d70158", "7e1b8fa40e87f9b12d40a1fcfd66b2ca708540d3", "3a4145a03567aae008db8fed2a58f616dcfa6d345ae38aa27b9e2ead32768a9e", "345365232ce9afc655dce4bac23f43c8acbdf9016d4bc2344be8d396a4919c34" }, // 86
  { "b8d56472954e31fb54e28fca743f84d8dc34891cb564c64b08f7b71636debd64ca1edbdba7fc5c3e40049ce982bba8c7e0703034e331384695e9de76b5104f2fbc4535ecbeebc33bc27f29f18f6f27e8023b0fbb6f563c", "60457106", "65ec6a553b431e4fa351cf2dfc6c1b53", "d887f88a626f98cad59e0a5b2484189bb1accc6b", "c50b8c10e4dbbcd0055d9a81a89f2ac18b709715377eb4048edbc4b497165f5a", "f52e102e57293878c28f29deb47792324fe455a62fa7441aabcc16a9cfc40ffa" }, // 87
  { "0d58ac665fa84342e60cefee31b1a4eacdb092f122dfc68309077aed1f3e528f578859ee9e4cefb4a728e946324927b675cd4f4ac84f64db3dacfe850c1dd18744c74ceccd9fe4dc214085108f404eab6d8f452b5442a47d", "966eb885", "8f37ffb065d2ca3e5e40930455518773", "3103211925d1886b7bfe73c42f24e000ddde8e01", "63deff17e210cd39682f253d819cfb454d6434bb72aa36d3074c808f051043d5", "2b89aa88b1b7f9f8ea461c4c5cae4829125f45f5697deadb8db2e964524c0d91" }, // 88
  { "1755e2d2e5d1c1b0156456b539753ff416651d44698e87002dcf61dcfa2b4e72f264d9ad591df1fdee7b41b2eb00283c5aebb3411323b672eaa145c5125185104f20f335804b02325b6dea65603f349f4d5d8b782dd3469ccd", "a4fb2fb2", "52d15ee0e65cc07d84370f420f3f4ccd", "1baeeea41fcf4bc3cc4178d77475f869369b8a36", "fb76aa04f9f2538c4262e8cd4ca5053ea2e2b082b97a484293fce02d97abe341", "3f3092365982c0b4278055beee9032ff9d1060e03c3b087e1a6197defc707e1a" }, // 89
  { "b180de1a611111ee7584ba2c4b020598cd574ac77e404e853d15a101c6f5a2e5c801d7d85dc95286a1804c870bb9f00fd4dcb03aa8328275158819dcad7253f3e3d237aeaa7979268a5db1c6ce08a9ec7c2579783c8afc1f91a7", "5412b36e", "ae8786808d7ce1a0d9a9226befb0bdca", "ab82cef5607ffa69e218ff71fc0d2d97bf713d03", "4582b15b38b27dca503ef8423b249a7703e987953139129c1468a3ba6b826740", "3c74aae2f340a24178cbab51004cba1aac3d91133c300715ea82c177269c0556" }, // 90
  { "cf3583cbdfd4cbc17063b1e7d90b02f0e6e2ee05f99d77e24e560392535e47e05077157f96813544a17046914f9efb64762a23cf7a49fe52a0a4c01c630cfe8727b81fb99a89ff7cc11dca5173057e0417b8fe7a9efba6d95c555f", "8724d307", "7dd591d07265406cc377020ac6c7e058", "6907d863d797deb8e46bc94ad05b6bef242a15d9", "7a41a251c2de39f9593b9808d89eb31958cec525b31d2e7a373dc29ee33ad9db", "0157c4ba44618ded11e9800afa07a0d5b6c711fc16a576c5edb71c4cc6894f82" }, // 91
  { "072fc02340ef99115bad72f92c01e4c093b9599f6cfc45cb380ee686cb5eb019e806ab9bd55e634ab10aa62a9510cc0672cd3eddb589c7df2b67fcd3329f61b1a4441eca87a33c8f55da4fbbad5cf2b2527b8e983bb31a2fadec7523", "b4e5de52", "218579c794ef71c9da317e227e90d058", "9ba690ac8b7a22662b244fc7f27c8723c3fc649e", "e146431158a7db63496e7fbb4741b820ce288a1758495ea8ef6061adbc36cfb9", "8d53dba107aaacb8422d6667f6778839f8965f8e4c8f4a851284cc91168a9030" }, // 92
  { "76eecf956a52649f877528146de33df249cd800e21830f65e90f0f25ca9d6540fde40603230eca6760f1139c7f268deba2060631eea92b1fff05f93fd5572fbe29579ecd48bc3a8d6c2eb4a6b26e38d6c5fbf2c08044aeea470a8f2f26", "f6ca3db4", "540f04cc19dea131532b643fb63cfae7", "e3b917152cab357dc3585fffc2d95e2337bd9b6f", "05f8979573501c8fb1778a9d38e9cad4ef481e5d6f6bdffb4fc642b5f3ce22c9", "5163f02233e332ad9be32c2346c9fcfe39afa5fbe9bc1cfeb92f4920155b20ec" }, // 93
  { "7adc0b6693e61c269f278e6944a5a2d8300981e40022f839ac644387bfac9086650085c2cdc585fea47b9d2e52d65a2b29a7dc370401ef5d60dd0d21f9e2b90fae919319b14b8c5565b0423cefb827d5f1203302a9d01523498a4db10374", "567891ac", "d859f008f48753ead4e62f52ca11377f", "233920ef506e9c59481d306d89cfccbb2fdbb2d5", "5ba07a5acf0fe4c89df8171896812ffea2b2de5185df097da8bde2635f512f4e", "faaf0e95217ca4b1568751ef2e4cd341d9ec33e16600bf09b92c6f1a6df84d2e" }, // 94
  { "e1fffa9826cce8b86bccefb8794e48c46cdf372013f782eced1e378269b7be2b7bf51374092261ae120e822be685f2e7a83664bcfbe38fe8633f24e633ffe1988e1bc5acf59a587079a57a910bda60060e85b5f5b6f776f0529639d9cce4bd", "c6835842", "05b12d9ac1c9854ebc86f00080321bc4", "f8429fe37ed6a336d46ab0e510d6772f0587d3bb", "65ac6f5061759518913cde199d49ec9e06c19e97c42eb99ab4f835eb8a4ab2e2", "b2c175d9d92aaa9ee72672f995b8dfd2daaf6555a0327a508218a9b447f00be8" }, // 95
  { "69f9abba65592ee01db4dce52dbab90b08fc04193602792ee4daa263033d59081587b09bbe49d0b49c9825d22840b2ff5d9c5155f975f8f2c2e7a90c75d2e4a8040fe39f63bbafb403d9e28cc3b86e04e394a9c9e8065bd3c85fa9f0c7891600", "4c61dddb", "f3642e61b5c0042af24a3571d7c9c239", "267a3f3a6fe13900f2bf1c9c360cdef18a6d9862", "4faef6b1ced3843526e9c93262647450dc7a68cda7e17f611e01bc6737d92c1e", "fb5388122306d37cee790cad1d3cddba8e9a93d5f9d78288b052482739c883fd" }, // 96
  { "38a10a352ca5aedfa8e19c64787d8e9c3a75dbf3b8674bfab29b5dbfc15a63d10fae66cd1a6e6d2452d557967eaad89a4c98449787b0b3164ca5b717a93f24eb0b506ceb70cbbcb8d72b2a72993f909aad92f044e0b5a2c9ac9cb16a0ca2f81f49", "eb65cf3e", "b7d46788d692d387300f5bfaa379ed18", "1594d253f40cabdafbe5eae70b7f6d4d142e9c1c", "9707054caf9ce8f2eb3e4304e3018beee27516bce6bf507d68adf7485b8c002f", "1c2f8d418ff6718b18dd4c756dcc8ed0f4755e8c22497a6cc19f8d7ae7fd2da7" }, // 97
  { "6d8c6e449bc13634f115749c248c17cd148b72157a2c37bf8969ea83b4d6ba8c0ee2711c28ee11495f43049596520ce436004b026b6c1f7292b9c436b055cbb72d530d860d1276a1502a5140e3c3f54a93663e4d20edec32d284e25564f624955b52", "6322e90d", "7d8e166acc1d95fc2f9098b02d431283", "25b53442fd71250f2c9a5c9df5655bfb8ead4b2e", "89e1ee5e7b902293bcb91098a2691cdc2ec0444bfce6c0078e7f2e27c06e9459", "7ea8116e6434c1caa049069dbbd9b6f0e9dc6cdfd6a889343d3b2652803078fc" }, // 98
  { "6efcbcaf451c129dbe00b9cef0c3749d3ee9d41c7bd500ade40cdc65dedbbbadb885a5b14b32a0c0d087825201e303288a733842fa7e599c0c514e078f05c821c7a4498b01c40032e9f1872a1c925fa17ce253e8935e4c3c71282242cb716b2089ccc1", "e7d1d1e5", "ac2ffed693bfcb55c8a717af6c4fa348", "ca4cf03895a389d8e926b9cca06c457db3672cf8", "3dc3e4bbc7e26c406c38c139a2c864bd7dbe71347bfc02f488c6874d90e1a741", "736d888751faac4d8e78b45b95abb15d40d98d8038c7225be0f523d5439ea5b6" }, // 99
  { "433c5303131624c0021d868a30825475e8d0bd3052a022180398f4ca4423b98214b6beaac21c8807a2c33f8c93bd42b092cc1b06cedf3224d5ed1ec29784444f22e08a55aa58542b524b02cd3d5d5f6907afe71c5d7462224a3f9d9e53e7e0846dcbb4ce", "5c444498", "9dc41264137166fe20aebb253ecce43e", "e9c3b6728e90f15a3703d1b9906e8f957ce0d4e5", "19acbb45e086963576fa1847f933f6ed78e777a4a27aca0609969362a72e3abf", "90e10b1ca8d352794d7dbd7bae410bef25f0ec7d080e053f48674237e33ea45f" } // 100
};


// return number of failed hashes
template <typename HashMethod, typename Container>
int check(const Container& input, const std::string& expectedResult)
{
  HashMethod hasher;
  std::string hash = hasher(&input[0], input.size());
  if (hash == expectedResult)
    return 0;

  // error
  std::cerr << "hash failed ! expected \"" << expectedResult << "\" but library computed \"" << hash << "\"" << std::endl;
  return 1;
}


// same as above but convert input from hex to raw bytes first (can contain zeros)
template <typename HashMethod, typename InputContainer, typename KeyContainer>
int checkHmac(const InputContainer& input, const KeyContainer& key, const std::string& expectedResult)
{
  std::string hash = hmac<HashMethod>(&input[0], input.size(), &key[0], key.size());
  if (hash == expectedResult)
    return 0;

  // error
  std::cerr << "hmac hash failed ! expected \"" << expectedResult << "\" but library computed \"" << hash << "\"" << std::endl;
  return 1;
}


// convert from hex to binary
std::vector<unsigned char> hex2bin(const std::string& hex)
{
  std::vector<unsigned char> result;
  for (size_t i = 0; i < hex.size(); i++)
  {
    unsigned char high = hex[i] >= 'a' ? hex[i] - 'a' + 10 : hex[i] - '0';
    i++;
    unsigned char low  = hex[i] >= 'a' ? hex[i] - 'a' + 10 : hex[i] - '0';
    result.push_back(high * 16 + low);
  }
  return result;
}


// here we go !
int main(int argc, char** argv)
{
  int errors = 0;

  // http://csrc.nist.gov/groups/ST/toolkit/documents/Examples/SHA_All.pdf
  // or more compact overview: http://www.di-mgt.com.au/sha_testvectors.html
  std::string empty;
  std::string abc = "abc";
  std::string abc448bits = "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq";
  std::string abc896bits = "abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu";
  std::string million(1000000, 'a');

  std::cout << "test SHA1 ...\n";
  errors += check<SHA1>(empty,      "da39a3ee5e6b4b0d3255bfef95601890afd80709");
  errors += check<SHA1>(abc,        "a9993e364706816aba3e25717850c26c9cd0d89d");
  errors += check<SHA1>(abc448bits, "84983e441c3bd26ebaae4aa1f95129e5e54670f1");
  errors += check<SHA1>(abc896bits, "a49b2446a02c645bf419f995b67091253a04a259");
  errors += check<SHA1>(million,    "34aa973cd4c4daa4f61eeb2bdbad27316534016f");

  std::cout << "test SHA2/256 ...\n";
  errors += check<SHA256>(empty,      "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855");
  errors += check<SHA256>(abc,        "ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad");
  errors += check<SHA256>(abc448bits, "248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1");
  errors += check<SHA256>(abc896bits, "cf5b16a778af8380036ce59e7b0492370b249b11e8f07a51afac45037afee9d1");
  errors += check<SHA256>(million,    "cdc76e5c9914fb9281a1c7e284d73e67f1809a48a497200e046d39ccc7112cd0");

  std::cout << "test SHA3/256 ...\n";
  errors += check<SHA3>(empty,      "a7ffc6f8bf1ed76651c14756a061d662f580ff4de43b49fa82d80a4b80f8434a");
  errors += check<SHA3>(abc,        "3a985da74fe225b2045c172d6bd390bd855f086e3e9d525b46bfe24511431532");
  errors += check<SHA3>(abc448bits, "41c0dba2a9d6240849100376a8235e2c82e1b9998a999e21db32dd97496d3376");
  errors += check<SHA3>(abc896bits, "916f6061fe879741ca6469b43971dfdb28b1a32dc36cb3254e812be27aad1d18");
  errors += check<SHA3>(million,    "5c8875ae474a3634ba4fd55ec85bffd661f32aca75c6d699d0cdcb6c115891c1");

  // next test cases produced an error until February 2015, reported by Gary Singer
  // note: automatic test case 71 failed, too, same bug
  std::cout << "test SHA3/512 ...\n";
  SHA3 sha3_512(SHA3::Bits512);
  std::vector<unsigned char> sha3bug = hex2bin("13bd2811f6ed2b6f04ff3895aceed7bef8dcd45eb121791bc194a0f806206bffc3b9281c2b308b1a729ce008119dd3066e9378acdcc50a98a82e20738800b6cddbe5fe9694ad6d");
  if (sha3_512(sha3bug.data(), sha3bug.size())
      != "def4ab6cda8839729a03e000846604b17f03c5d5d7ec23c483670a13e11573c1e9347a63ec69a5abb21305f9382ecdaaabc6850f92840e86f88f4dabfcd93cc0")
    std::cerr << "SHA3 bug present" << std::endl;

  // check all automatically generated testsets
  std::cout << "generic testsets (CRC32,MD5,SHA1,SHA256,SHA3) ..." << std::endl;
  for (size_t i = 0; i < NumTests; i++)
  {
    errors += check<CRC32 >(hex2bin(testset[i].input), testset[i].crc32b);
    errors += check< MD5  >(hex2bin(testset[i].input), testset[i].md5);
    errors += check< SHA1 >(hex2bin(testset[i].input), testset[i].sha1);
    errors += check<SHA256>(hex2bin(testset[i].input), testset[i].sha256);
    errors += check< SHA3 >(hex2bin(testset[i].input), testset[i].sha3_256);
  }

  // HMAC MD5 and SHA1 test vectors from RFC2202 http://www.ietf.org/rfc/rfc2202.txt
  std::cout << "test HMAC(MD5) ...\n";
  errors += checkHmac< MD5  >(std::string("Hi There"),
                              hex2bin("0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b"),
                              "9294727a3638bb1c13f48ef8158bfc9d");
  errors += checkHmac< SHA1 >(std::string("Hi There"),
                              hex2bin("0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b"),
                              "b617318655057264e28bc0b6fb378c8ef146be00");
  errors += checkHmac< MD5  >(std::string("what do ya want for nothing?"),
                              std::string("Jefe"),
                              "750c783e6ab0b503eaa86e310a5db738");
  errors += checkHmac< SHA1 >(std::string("what do ya want for nothing?"),
                              std::string("Jefe"),
                              "effcdf6ae5eb2fa2d27416d5f184df9c259a7c79");
  errors += checkHmac< MD5  >(hex2bin("dddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd"),
                              hex2bin("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"),
                              "56be34521d144c88dbb8c733f0e8b3f6");
  errors += checkHmac< SHA1 >(hex2bin("dddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd"),
                              hex2bin("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"),
                              "125d7342b9ac11cd91a39af48aa17b4f63f175d3");
  errors += checkHmac< MD5  >(hex2bin("cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd"),
                              hex2bin("0102030405060708090a0b0c0d0e0f10111213141516171819"),
                              "697eaf0aca3a3aea3a75164746ffaa79");
  errors += checkHmac< SHA1 >(hex2bin("cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd"),
                              hex2bin("0102030405060708090a0b0c0d0e0f10111213141516171819"),
                              "4c9007f4026250c6bc8414f9bf50c86c2d7235da");
  // test case 5 skipped
  errors += checkHmac< MD5  >(std::string("Test Using Larger Than Block-Size Key - Hash Key First"),
                              hex2bin("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"),
                              "6b1ab7fe4bd7bf8f0b62e6ce61b9d0cd");
  errors += checkHmac< SHA1 >(std::string("Test Using Larger Than Block-Size Key - Hash Key First"),
                              hex2bin("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"),
                              "aa4ae5e15272d00e95705637ce8a3b55ed402112");
  errors += checkHmac< MD5  >(std::string("Test Using Larger Than Block-Size Key and Larger Than One Block-Size Data"),
                              hex2bin("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"),
                              "6f630fad67cda0ee1fb1f562db3aa53e");
  errors += checkHmac< SHA1 >(std::string("Test Using Larger Than Block-Size Key and Larger Than One Block-Size Data"),
                              hex2bin("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"),
                              "e8e99d0f45237d786d6bbaa7965c7808bbff1a91");

  // HMAC SHA256 test vectors from RFC4231 http://www.ietf.org/rfc/rfc4231.txt
  std::cout << "test HMAC(SHA256) ...\n";
  errors += checkHmac<SHA256>(std::string("Hi There"),
                              hex2bin("0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b"),
                              "b0344c61d8db38535ca8afceaf0bf12b881dc200c9833da726e9376c2e32cff7");
  errors += checkHmac<SHA256>(std::string("what do ya want for nothing?"),
                              std::string("Jefe"),
                              "5bdcc146bf60754e6a042426089575c75a003f089d2739839dec58b964ec3843");
  errors += checkHmac<SHA256>(hex2bin("dddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd"),
                              hex2bin("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"),
                              "773ea91e36800e46854db8ebd09181a72959098b3ef8c122d9635514ced565fe");
  errors += checkHmac<SHA256>(hex2bin("cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd"),
                              hex2bin("0102030405060708090a0b0c0d0e0f10111213141516171819"),
                              "82558a389a443c0ea4cc819899f2083a85f0faa3e578f8077a2e3ff46729665b");
  // test case 5 skipped
  errors += checkHmac<SHA256>(std::string("Test Using Larger Than Block-Size Key - Hash Key First"),
                              hex2bin("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"),
                              "60e431591ee0b67f0d8a26aacbf5b77f8e0bc6213728c5140546040f0ee37f54");
  errors += checkHmac<SHA256>(std::string("This is a test using a larger than block-size key and a larger than block-size data. The key needs to be hashed before being used by the HMAC algorithm."),
                              hex2bin("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"),
                              "9b09ffa71b942fcb27635fbcd5b0e944bfdc63644f0713938a7f51535c3a35e2");

  // summary
  if (errors == 0)
    std::cout << "all tests ok" << std::endl;
  else
    std::cerr << errors << " tests failed" << std::endl;

  return errors;
}
#include "Matterbot.h"
#include "MattermostWebhooks.h"
#include "StdLogger.h"
#include "Message.h"
#include <map>
#include <atomic>
#include <time.h>
#include <iostream>
#include <sstream>
#include <functional>

using namespace lospi;
using namespace std;

class lospi::MatterbotImpl {
public:
	std::wstring serve_command_from_message(const Message &message);
	std::wstring get_help_string() const;
	WebResponse get_default_web_response();
	long websites_served = 0, messages_sent = 0, commands_served = 0;
	std::map<std::wstring, std::shared_ptr<ICommand>> commands;
	std::unique_ptr<ILogger> log;
	std::unique_ptr<MattermostWebhooks> webhooks;
	std::atomic<bool> is_alive;
};

WebResponse MatterbotImpl::get_default_web_response() {
	time_t now = time(0);
	wstring contents(L"<h3>MattermostBot Status</h3>");
	contents.append(L"<p>Web requests served: ");
	contents.append(to_wstring(websites_served));
	contents.append(L"</p><p>Messages posted: ");
	contents.append(to_wstring(messages_sent));
	contents.append(L"</p><p>Commands served: ");
	contents.append(to_wstring(commands_served));
	contents.append(L"</p><h5>Supported commands:</h5><ul>");

	for (auto cmd_pair : commands) {
		contents.append(L"<li>");
		contents.append(cmd_pair.first);
		contents.append(L"</li>");
	}
	contents.append(L"</ul>");

	websites_served++;
	return WebResponse(contents, L"text/html");
}

wstring MatterbotImpl::get_help_string() const {
	wstring help(L"Supported commands\n===\n");
	for (auto cmd_pair : commands) {
		help.append(cmd_pair.second->get_help());
	}
	return help;
}

wstring MatterbotImpl::serve_command_from_message(const Message &message) {
	commands_served++;
	if (!message.token_is_valid()) {
		return L"Invalid token provided for command.";
	}
	wstringstream text_ss(message.get_text());
	wstring trigger_word, command_string, arguments;
	getline(text_ss, trigger_word, L' ');
	getline(text_ss, command_string, L' ');
	getline(text_ss, arguments);
	if (L"help" == command_string)
	{
		auto command_pair = commands.find(arguments);
		if (command_pair == commands.end())
		{
			return get_help_string();
		}
		return command_pair->second->get_help();
	}
	auto command_pair = commands.find(command_string);
	if (command_pair == commands.end())
	{
		return L"Command not found: " + command_string;
	}
	return command_pair->second->handle_command(message.get_team(), message.get_channel(), message.get_user(), arguments);
}


Matterbot::Matterbot(const std::wstring &mattermost_url,
	const std::wstring &incoming_hook_token,
	const std::wstring &outgoing_hook_route,
	const std::wstring &outgoing_hook_token) 
	: impl(make_shared<MatterbotImpl>())
{
	impl->log = make_unique<StdLogger>();
	impl->webhooks = make_unique<MattermostWebhooks>(mattermost_url, incoming_hook_token, outgoing_hook_route, outgoing_hook_token);
	impl->is_alive = true;
	impl->webhooks->register_web_handler(bind(&MatterbotImpl::get_default_web_response, impl));
	//Not sure why this doesn't work:
	//impl->webhooks->register_message_handler(bind(&Matterbot::serve_command_from_message, this));
	auto impl_copy = impl;
	impl->webhooks->register_message_handler([impl_copy](const Message& message) {
		return impl_copy->serve_command_from_message(message);
	});
	impl->webhooks->listen();
}


Matterbot::~Matterbot() { }

void Matterbot::set_logger(std::unique_ptr<ILogger> log) {
	impl->log.swap(log);
}

void Matterbot::register_command(shared_ptr<ICommand> command)
{
	impl->commands[command->get_name()] = command;
}

void Matterbot::unregister_command(shared_ptr<ICommand> command)
{
	impl->commands.erase(command->get_name());
}

void Matterbot::post_message(const std::wstring& message) {
	impl->webhooks->post_message(message);
	impl->messages_sent++;
}

void Matterbot::update_website(const wstring& contents)
{
	impl->webhooks->register_web_handler([contents]() {
		return WebResponse(contents, L"text/html");
	});
}
#include "MattermostWebhooks.h"
#include <codecvt>
#include <cpprest/http_listener.h>
#include <cpprest/uri.h>
#include <future>

using namespace std;
using namespace lospi;
using namespace web;
using namespace web::http;
using namespace web::http::experimental::listener;

namespace {
	wstring_convert<codecvt_utf8_utf16<wchar_t>> converter;

	wstring url_decode(const wstring &input) {
		wstring ret(input);
		replace(ret.begin(), ret.end(), L'+', L' ');
		return uri::decode(ret);
	}

	Message parse_message_from_query_string(const wstring &query_string, const wstring &outgoing_hook_token) {
		auto key_values = uri::split_query(query_string);
		return Message{
			url_decode(key_values[L"token"]) == outgoing_hook_token,
			stol(url_decode(key_values[L"timestamp"])), //?
			url_decode(key_values[L"channel_name"]),
			url_decode(key_values[L"team_domain"]),
			url_decode(key_values[L"text"]),
			url_decode(key_values[L"user_name"]),
			url_decode(key_values[L"trigger_word"])
		};
	}
}

MattermostWebhooks::MattermostWebhooks(const wstring &mattermost_url,
	const wstring &incoming_hook_token,
	const wstring &outgoing_hook_route,
	const wstring &outgoing_hook_token)
	: mattermost_url(mattermost_url),
	outgoing_hook_route(outgoing_hook_route),
	outgoing_hook_token(outgoing_hook_token),
	client(mattermost_url),
	mattermost_post_url(L"hooks/" + incoming_hook_token),
	is_alive(true),
	message_handler([](auto message) {
		wclog << L"[+] Received message: " + message.get_text() << endl;
		return L"Message received.";
	}),
	web_handler([this]() {
		wclog << L"[+] Handled web request." << endl;
		wstring status = is_alive ? L"alive" : L"dead";
		return WebResponse(L"<b>MattermostWebhooks is " + status + L". </b>", L"text/html");
	})
{
}

MattermostWebhooks::~MattermostWebhooks()
{
	die();
	if (listener_thread.joinable()) {
		listener_thread.join();
	}
}

void MattermostWebhooks::post_message(const wstring &message)
{
	json::value body_data;
	body_data[L"text"] = json::value::string(message);
	auto request_task = client.request(methods::POST, mattermost_post_url, body_data);
	try 
	{
		auto response = request_task.get();
		wclog << L"[+] Posted to Incoming Webhook: " << message << endl;
	}
	catch (http_exception e)
	{
		string msg ("There was an issue when POSTing to the Incoming Webhook: ");
		msg.append(e.what());
		throw std::exception(e);
	}
}

void MattermostWebhooks::register_message_handler(const function<wstring(const Message&)> &message_handler) 
{
	this->message_handler = message_handler;
}

void MattermostWebhooks::register_web_handler(const function<WebResponse()> &web_handler)
{
	this->web_handler = web_handler;
}

void MattermostWebhooks::listen() 
{
	listener_thread = thread([this]() {
		wclog << U("[ ] Starting MattermostWebhooks listener.") << endl;
		http_listener listener(outgoing_hook_route);
		try {
			listener.open().wait();
		}
		catch (exception e)
		{
			wclog << L"[-] MattermostWebhooks encountered an exception:" << e.what() << endl;
			cerr << e.what() << endl;
			return;
		}
		listener.support(methods::GET, [this](http_request req) {
			auto web_handler_future = async(launch::async, [this, req]() {
				return web_handler();
			});
			try {
				auto web_handler_result = web_handler_future.get();
				req.reply(status_codes::OK, web_handler_result.get_content(), web_handler_result.get_content_type());
			}
			catch (exception e) 
			{
				req.reply(status_codes::InternalError, e.what());
			}
		});
		listener.support(methods::POST, [this](http_request req) {
			auto body_util = req.extract_string().get();
			auto body = string(body_util.begin(), body_util.end());
			auto body_w = converter.from_bytes(body);
			auto message = parse_message_from_query_string(body_w, outgoing_hook_token);
			req.reply(status_codes::OK);
			try {
				auto command_result = async(launch::async, [this, message]() {
					return message_handler(message);
				});
				post_message(command_result.get());
			}
			catch (exception e)
			{

			}
		});
		wclog << U("[+] MattermostWebhooks listening for Outgoing Webhooks from Mattermost.") << endl;
		while (is_alive) {
			this_thread::sleep_for(chrono::milliseconds(500));
		}
		wclog << L"[ ] MattermostWebhooks going down." << endl;
		listener.close();
	});
}

void MattermostWebhooks::die() 
{
	is_alive.exchange(false);
}
#include "Message.h"

using namespace std;
using namespace lospi;

Message::Message()
{
}

Message::Message(const bool &valid_token, const long &timestamp, const wstring &channel, const wstring &team,
	const wstring &text, const wstring &user, const wstring &trigger_word) :
	valid_token(valid_token), timestamp(timestamp), channel(channel), team(team), text(text), user(user), trigger_word(trigger_word) {
}

bool Message::token_is_valid() const {
	return valid_token;
}

long Message::get_timestamp() const {
	return timestamp;
}

wstring Message::get_channel() const {
	return channel;
}

wstring Message::get_team() const {
	return team;
}

wstring Message::get_text() const {
	return text;
}

wstring Message::get_user() const {
	return user;
}

wstring Message::get_trigger_word() const {
	return trigger_word;
}
#include "StdLogger.h"
#include <iostream>

using namespace lospi;
using namespace std;

void StdLogger::info(const wstring &msg) {
	wclog << msg;
}

void StdLogger::warn(const wstring &msg) {
	wclog << msg;
}

void StdLogger::error(const wstring &msg) {
	wcerr << msg;
}// PreCompiled Header
#include "StdAfx.h"

// Includes all required Crypto++
// Block Cipher Headers
#include "SymmetricCipher.h"

// C Runtime Includes
#include <iostream>
#include <iomanip>

// Crypto++ Includes
// #include "cryptlib.h"
#include "modes.h" // xxx_Mode< >
#include "filters.h" // StringSource and
// StreamTransformation

// Cipher Modes
//
// #define CIPHER_MODE CBC_CTS_Mode
#define CIPHER_MODE CBC_Mode
// #define CIPHER_MODE CFB_FIPS_Mode
// #define CIPHER_MODE CFB_Mode
// #define CIPHER_MODE CTR_Mode
// #define CIPHER_MODE ECB_Mode
// #define CIPHER_MODE OFB_Mode

// Ciphers
//
#define CIPHER AES
// #define CIPHER Blowfish
// #define CIPHER BTEA
// #define CIPHER Camellia
// #define CIPHER CAST128
// #define CIPHER CAST256
// #define CIPHER DES
// #define CIPHER DES_EDE2
// #define CIPHER DES_EDE3
// #define CIPHER DES_XEX3
// #define CIPHER GOST
// #define CIPHER IDEA
// #define CIPHER MARS
// #define CIPHER RC2
// #define CIPHER RC5
// #define CIPHER RC6
// #define CIPHER Rijndael
// #define CIPHER SAFER_K
// #define CIPHER SAFER_SK
// #define CIPHER Serpent
// #define CIPHER SHACAL2
// #define CIPHER SHARK
// #define CIPHER SKIPJACK
// #define CIPHER ThreeWay
// #define CIPHER Twofish
// #define CIPHER XTEA

int main(int argc, char* argv[]) {

   try
   {
      // Key and IV setup
      byte key[ CryptoPP::CIPHER::DEFAULT_KEYLENGTH ],
            iv[ CryptoPP::CIPHER::BLOCKSIZE ];

      ::memset( key, 0x01, CryptoPP::CIPHER::DEFAULT_KEYLENGTH );
      ::memset( iv, 0x01, CryptoPP::CIPHER::BLOCKSIZE );

      // Message M
      std::string PlainText = "Yoda said, Do or Do Not. There is no try.";

      // Cipher Text Sink
      std::string CipherText;

      // Encryptor
      CryptoPP::CIPHER_MODE<CryptoPP::CIPHER>::Encryption
         Encryptor( key, sizeof(key), iv );

      // Encryption
      CryptoPP::StringSource( PlainText, true,
         new CryptoPP::StreamTransformationFilter( Encryptor,
            new CryptoPP::StringSink( CipherText )
         ) // StreamTransformationFilter
      ); // StringSource

      ///////////////////////////////////////
      // DMZ //
      ///////////////////////////////////////

      // Recovered Text Sink
      std::string RecoveredText;

      // Decryptor
      CryptoPP::CIPHER_MODE<CryptoPP::CIPHER>::Decryption
         Decryptor( key, sizeof(key), iv );

      // Decryption
      CryptoPP::StringSource( CipherText, true,
         new CryptoPP::StreamTransformationFilter( Decryptor,
            new CryptoPP::StringSink( RecoveredText )
         ) // StreamTransformationFilter
      ); // StringSource

      //////////////////////////////////////////
      // Output //
      //////////////////////////////////////////

      std::cout << "Algorithm:" << std::endl;
      std::cout << " " << Encryptor.AlgorithmName() << std::endl;
      std::cout << "Minimum Key Size:" << std::endl;
      std::cout << " " << Encryptor.MinKeyLength() << " bytes" << std::endl;
      std::cout << std::endl;

      std::cout << "Plain Text (" << PlainText.length() << " bytes)" << std::endl;
      std::cout << " '" << PlainText << "'" << std::endl;
      std::cout << std::endl;

      std::cout << "Cipher Text Size:" << std::endl;
      std::cout << " " << CipherText.size() << " bytes" << std::endl;
      std::cout << std::endl;

      std::cout << "Recovered Text:" << std::endl;
      std::cout << " '" << RecoveredText << "'" << std::endl;
      std::cout << std::endl;
   }
   catch( CryptoPP::Exception& e)
   {
      std::cerr << e.what() << std::endl;
   }
   
   catch(...)
   {
      std::cerr << "Unknown Error" << std::endl;
   }   

   return 0;
}#include "WebResponse.h"

using namespace lospi;
using namespace std;

WebResponse::WebResponse()
{
}

WebResponse::WebResponse(const wstring &content, const wstring &content_type) : content(content), content_type(content_type)
{
}

wstring WebResponse::get_content_type() const
{
	return content_type;
}

wstring WebResponse::get_content() const
{
	return content;
}
ï»¿#include "BigNum.h"

//Implement BigNum

BigNum::BigNum(uint64_t num):BigNum(std::to_string(num))
{

}

BigNum::BigNum(const std::string aBigNum)
{
	std::string s = aBigNum;
	
	while(!s.empty())
	{
		std::string t;
		t.push_back(s.back());
		nums_.push_back(std::stoi(t));
		s.pop_back();
	}
}

std::string BigNum::toString(uint64_t n) const
{
	std::string s = std::to_string(n);
	
	return s;
}

BigNum BigNum::operator+(BigNum b) const
{
	BigNum tmp(*this);
	tmp += b;
	return tmp;
}

BigNum BigNum::operator+=(BigNum b)
{
	short carry = 0, tmp = 0;
	auto y = (*this).nums_.begin();
	
	for (auto x = b.nums_.begin(); x != b.nums_.end(); ++x)
	{
		tmp = *y + *x + carry;
		if (tmp >= 10)
		{
			*y = tmp % 10;
			carry = 1;
		}
		else
		{
			*y = tmp;
			carry = 0;
		}
		y++;
	}

	// Last carry over
	if (carry)
	{
		(*this).nums_.push_back(carry);
	}

	return *this;
}

BigNum BigNum::operator-(BigNum b) const
{
	BigNum tmp(*this);
	tmp -= b;
	return tmp;
}

BigNum BigNum::operator-=(BigNum b)
{  
	// Should check for greater since only implementing positive numbers
	BigNum zero(0);
	if (*this <= b)
	{
		*this = 0;
		return *this;
	}
	

	short borrow = 0, tmp = 0;
	auto y = (*this).nums_.begin();

	for (auto x = b.nums_.begin(); x != b.nums_.end(); ++x)
	{
		tmp = *y - *x - borrow;
		if (tmp < 0)
		{
			tmp += 10;
			borrow = 1;
		}
		else
		{
			borrow = 0;
		}

  		*y = tmp;
		y++;
	}

	while (borrow && y != (*this).nums_.end())
	{
		tmp = *y - borrow;
		if (tmp < 0)
		{
			tmp += 10;
			borrow = 1;
		}
		else
		{
			borrow = 0;
		}

		*y = tmp;
		y++;
	}

	// Eliminate leading zeros (man this is ugly)
	auto z = (*this).nums_.end();
	int count = 0;
	z--;
	while (*z == 0)
	{
		count++;
		z--;
	}
	for (int i = 0; i < count; i++)
	{
		(*this).nums_.pop_back();
	}
	
	return  *this;
}

bool BigNum::operator==(BigNum b) const
{
	return !(*this != b);
}

bool BigNum::operator!=(BigNum b) const
{
	if ((*this).nums_.size() != b.nums_.size())
		return true;
	
	auto y = (*this).nums_.begin();
	for (auto x = b.nums_.begin(); x != b.nums_.end(); ++x)
	{
		if (*y != *x) return true;
		y++;
	}

	return false;
}

bool BigNum::operator>(BigNum b) const
{
	if ((*this).nums_.size() < b.nums_.size())	return false;
	if ((*this).nums_.size() > b.nums_.size())	return true;

	auto y = (*this).nums_.rbegin();
	for (auto x = b.nums_.rbegin(); x != b.nums_.rend(); ++x)
	{
		if (*y > *x) return true;
		if (*y < *x) return false;
		y++;
	}

	return false;
}

bool BigNum::operator<(BigNum b) const
{
	if ((*this).nums_.size() < b.nums_.size())	return true;
	if ((*this).nums_.size() > b.nums_.size())	return false;

	auto y = (*this).nums_.rbegin();
	for (auto x = b.nums_.rbegin(); x != b.nums_.rend(); ++x)
	{
		if (*y < *x) return true;
		if (*y > *x) return false;
		y++;
	}

	return false;
}

bool BigNum::operator<=(BigNum b) const
{
	if ((*this) < b || (*this) == b) return true;
	return false;
}

bool BigNum::operator>=(BigNum b) const
{
	if ((*this) > b || (*this) == b) return true;
	return false;
}

BigNum BigNum::operator*(BigNum b) const
{
	BigNum tmp(*this);
	tmp *= b;
	return tmp;
}

BigNum BigNum::operator*=(BigNum b)
{
	uint64_t m = 1;
	BigNum borg = *this;

	// Zero not implemented
	BigNum z(0);
	if (b == z) return *this;

	for (auto x = b.nums_.begin(); x != b.nums_.end(); ++x)
	{
		for (uint64_t i = 1; i < (*x * m); i++)
			*this += borg;
		m *= 10;
	}

	return *this;
}

BigNum BigNum::operator/(BigNum b) const
{
	BigNum tmp(*this);
	tmp /= b;
	return tmp;
}

BigNum BigNum::operator/=(BigNum b)
{
	// Zero not implemented
 	BigNum zero(0);
	BigNum one(1);

	if (b == zero || b == one) return *this;

	int i = 0;  // Divider

	while (*this >= b)
	{
		*this -= b;
   		i++;
	}
	BigNum tmp(i);
	*this = tmp;

	return *this;
}

BigNum BigNum::operator%(BigNum b) const
{
	BigNum tmp(*this);
	tmp %= b;
	return tmp;
}

BigNum BigNum::operator%=(BigNum b)
{
	BigNum zero(0);
	BigNum one(1);

	if (b == zero) return zero;

	while (*this >= b) *this -= b;

	return *this;
}

std::ostream & operator<<(std::ostream & os, const BigNum & num)
{
	for (auto it = num.nums_.rbegin(); it != num.nums_.rend(); ++it)
	{
		os << *it;
	}

	return os;
}#include "Matterbot.h"
#include <iostream>
#include <string>
#include "sha1.h"
#include "crypt/md5.h"
#include "crypt/sha256.h"
#include "base64.h"

#include <locale>
#include <codecvt>
#include <string>

#include <vector>

#include <algorithm>

#define ERROR_SUCCESS 0
#define ERROR_FAILURE -1

using namespace std;
using namespace lospi;

void parsestring(std::vector<std::string>&);
void parsestring(std::vector<std::string>& v, std::string s)
{
	std::string delimiter = " ";
	size_t pos = 0;
	std::string token;
	
	while ((pos = s.find(delimiter)) != std::string::npos) {
		v.push_back(s.substr(0, pos));
		s.erase(0, pos + delimiter.length());
	}
	v.push_back(s);
}

class EchoCommand : public ICommand {
public:
	wstring get_name() override {return L"echo";}

	wstring get_help() override {return L"`echo [MESSAGE]`\n===\n`echo` will respond with whatever message you give it.";}

	wstring handle_command(wstring team, wstring channel, wstring user, wstring command_text) override {
		return command_text;
	}

};

class SloganCommand : public ICommand {
public:
	wstring get_name() override {return L"slogan";}

	wstring get_help() override {return L"slogan does nothing.";}

	wstring handle_command(wstring team, wstring channel, wstring user, wstring command_text) override {
		std::wstring s = L"You meat bags had your chance";
		return s;
	}

};

class Sha1Command : public ICommand {
public:
	wstring get_name() override {return L"sha1";}
	wstring get_help() override {return L"sha1 [string].";}
	wstring handle_command(wstring team, wstring channel, wstring user, wstring command_text) override {
		std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter;
		std::string narrow = converter.to_bytes(command_text);
		SHA1 sha1;		
		std::string myHash2 = sha1(narrow);
		std::wstring wide = converter.from_bytes(myHash2);
		return wide;
	}
};

class Sha256Command : public ICommand {
public:
	wstring get_name() override { return L"sha256"; }
	wstring get_help() override { return L"sha256 [string]."; }
	wstring handle_command(wstring team, wstring channel, wstring user, wstring command_text) override {
		std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter;
		std::string narrow = converter.to_bytes(command_text);
		SHA256 sha256;
		std::string myHash2 = sha256(narrow);

		std::wstring wide = converter.from_bytes(myHash2);
		return wide;
	}
};

class Md5Command : public ICommand {
public:
	wstring get_name() override { return L"md5"; }
	wstring get_help() override { return L"md5 [string]."; }
	wstring handle_command(wstring team, wstring channel, wstring user, wstring command_text) override {
		std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter;
		std::string narrow = converter.to_bytes(command_text);
		MD5 md5;
		std::string myHash2 = md5(narrow);
		std::wstring wide = converter.from_bytes(myHash2);
		return wide;
	}
};


class base64encodeCommand : public ICommand {
public:
	wstring get_name() override { return L"encode64"; }
	wstring get_help() override { return L"encode64 [string]."; }
	wstring handle_command(wstring team, wstring channel, wstring user, wstring command_text) override {
		std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter;
		std::string s = converter.to_bytes(command_text);
		std::string encoded = base64_encode(reinterpret_cast<const unsigned char*>(s.c_str()), s.length());
		std::wstring wide = converter.from_bytes(encoded);
		return wide;
	}
};


class base64decodeCommand : public ICommand {
public:
	wstring get_name() override { return L"decode64"; }
	wstring get_help() override { return L"decode64 [string]."; }
	wstring handle_command(wstring team, wstring channel, wstring user, wstring command_text) override {
		std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter;
		std::string s = converter.to_bytes(command_text);
		std::string decoded = base64_decode(s);
		std::wstring wide = converter.from_bytes(decoded);
		return wide;
	}
};


class XORCommand : public ICommand {
public:
	wstring get_name() override { return L"xor"; }
	wstring get_help() override { return L"xor [string]."; }
	wstring handle_command(wstring team, wstring channel, wstring user, wstring command_text) override {
		std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter;
		std::string s = converter.to_bytes(command_text);
		char key = '10';
		for (int i = 0; i < s.length(); i++) {
			s[i] ^= key;
		}
		
		std::wstring wide = converter.from_bytes(s);
		return wide;
	}
};



class jhash : public ICommand {
public:
	wstring get_name() override { return L"hash"; }
	wstring get_help() override { return L"hash [string]."; }
	wstring handle_command(wstring team, wstring channel, wstring user, wstring command_text) override {
		std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter;
		std::string s = converter.to_bytes(command_text);
		
		int go = 0;
		std::vector <std::string> v;
		parsestring(v, s);
		int bits = stoi(v[0]);

		// bit mask
		uint64_t mask = 1;
		mask = !mask;
		mask <<= bits;  

		// t is the string
		std::string t;
		for (int i = 1; i < v.size(); i++) {
			t.append(v[i]); t.append(" "); 
		}

		std::string h;
		// Loop
		while (go++)
		{
			SHA1 sha1;
			h = sha1(t);
			
			h.append(to_string(go));
		

			if (h[0] == '0' && h[1] == '0')
				break;
		}
		
		std::string r; 
		r = std::to_string(go);
		cout << go << endl;
		std::wstring wide = converter.from_bytes(h);
		return wide;
	}
};



class CustomLogger : public ILogger {
	void info(const wstring &msg) override {
		wcout << "INFO: " << msg;
	}
	void warn(const wstring &msg) override {
		wcout << "WARN: " << msg;
	}
	void error(const wstring &msg) override {
		wcerr << "INFO: " << msg;
	}
};

int main() {
	//TODO: Put your own routes and tokens here
	wstring mattermost_url = L"http://chatty.silent.services:8065/",		// URL to the Mattermost/Slack service
		//incoming_hook_token = L"1uuuk88jq7bhpn5tkzfwej636o",
		incoming_hook_token = L"h517g4u3tfbn3reshqtd3w69jh",
		outgoing_hook_route = L"http://192.168.1.36/",			// URL of the box running matterbot
		//outgoing_hook_token = L"n1ttiu6netfkjf4ykus3mypc9y";
		outgoing_hook_token = L"4sa61qjr4fdwmdnx7jzkhq9pyc";
	try {
		Matterbot bot(mattermost_url, incoming_hook_token, outgoing_hook_route, outgoing_hook_token);
		bot.post_message(L"up on in");
		
		//TODO: Add your other commands here
		bot.register_command(make_shared<EchoCommand>());
		bot.register_command(make_shared<SloganCommand>());
		bot.register_command(make_shared<Sha1Command>());
		bot.register_command(make_shared<Sha256Command>());
		bot.register_command(make_shared<Md5Command>());
		bot.register_command(make_shared<base64encodeCommand>());
		bot.register_command(make_shared<base64decodeCommand>());
		bot.register_command(make_shared<XORCommand>());
		bot.register_command(make_shared<jhash>());

		//TODO: optional, you can implement your own logger. Default logger sends to wclog.
		bot.set_logger(make_unique<CustomLogger>());

		// Here's the listen/command loop.
		wstring console;
		wclog << "[ ] Type \'quit\' to quit. Any other input will be sent to the bot." << endl;
		while (getline(wcin, console)) {
			if (L"quit" == console)
			{
				wclog << "[ ] Quitting." << endl;
				return ERROR_SUCCESS;
			}
			if (L"" != console)
			{
				bot.post_message(console);
			}

		}
	}
	catch (exception e)
	{
		wcerr << "[-] Unhandled exception: this is bad" << e.what() << endl;
		return ERROR_FAILURE;
	}
}#include <cstdint>
#include <memory>
#include "defs.hpp"

/*
struct ListNode {
	std::shared_ptr<ListNode> next;
	uint32_t data;
};
*/

// Global List Head
std::shared_ptr<ListNode> head = nullptr;

/**
* add_node: Given a reference to a list head, create and add a new node,
*           containing the data element "value".
*/
void add_node(std::shared_ptr<ListNode>& head, uint32_t value)
{
	//std::shared_ptr<ListNode> node;
	auto node = std::make_shared<ListNode>();
	auto tmp = head;

	node->next = nullptr;
	node->data = value;

	if (!head)
	{
		head = node;
		return;
	}

	while (tmp)
	{
		if (tmp->next == nullptr)
			break;
		tmp = tmp->next;
	}
	tmp->next = node;
}

/**
* get_cout: Given a shared pointer to the head of a linked list, return
*           the number of nodes contained within the list.
*/
uint32_t get_count(std::shared_ptr<ListNode> head)
{
	int i = 0;
	//auto node = std::make_shared<ListNode>();
	auto node = head;

	while (node != nullptr)
	{
		++i;
		node = node->next;
	}

	return i;
}

/**
*  find_value: Given a shared pointer to the head of a linked list, search for the element
*              containing the data element "needle," and either return that element, or an
*			   empty shared_ptr if it cannot be found.
*/
std::shared_ptr<ListNode> find_value(std::shared_ptr<ListNode> head, uint32_t needle)
{
	while (head != nullptr)
	{
		if (head->data == needle)
			return head;

		head = head->next;
	}

	return nullptr;
}


/**
* remove_node: Given a reference to a shared_ptr to the beginning of a list, remove the first element, and
*	           return it. If the list is empty, simply return an empty shared_ptr.
*/
std::shared_ptr<ListNode> remove_node(std::shared_ptr<ListNode>& head)
{
	auto tmp = head;

	if (head == nullptr)
		return nullptr;

	head = head->next;
	tmp->next = nullptr;

	return tmp;
}


/***
* ListNode is an element in a linked list; each element contains a shared_ptr to next,
* or an "empty" shared pointer if there is no next element, and a "data" element, consisting
* of a uint32_t.
***/
int main(int argc, char** argv, char** envp)
{

	test_one();
	test_two();
	test_three();
	return 0;
}#include "defs.hpp"


bool test_one()
{
	std::shared_ptr<ListNode> head = nullptr;

	EXPECT("Count Test - No nodes", (uint32_t)0, get_count(head));
	add_node(head, 10);
	add_node(head, 20);
	
	EXPECT("Count Test - Some nodes", (uint32_t)2, get_count(head));

	for (uint32_t i = 0; i < 10; ++i) {
		add_node(head, i);
		EXPECT("Count Test - Values", i+3, get_count(head));
	}

	return true;
}

bool test_two()
{
	std::shared_ptr<ListNode> head = nullptr;

	for (uint32_t i = 100; i > 30; --i) {
		add_node(head, i);
	}

	{
		auto res = find_value(head, 40);
		EXPECT("Result Test - 1", true, !!res);
		EXPECT("Result Test - 2", res->data, (uint32_t)40);
	}

	{
		auto res = find_value(head, 300);
		EXPECT("Result Test - 3", false, !!res);
	}

	return true;
}

bool test_three()
{
	std::shared_ptr<ListNode> head = nullptr;

	for (uint32_t i = 100; i > 0; --i) {
		add_node(head, i);
	}

	EXPECT("Remove Node Test", (uint32_t)100, get_count(head));

	for (uint32_t i = 100; i > 0; --i) {
		auto res = remove_node(head);
		if(res)
			std::cout << "Removing Node: " << res->data << std::endl;

		EXPECT("Remove Node Test", i-1, get_count(head));
	}

	return true;
}
#include "typeInspection.h"
#include <cstdint>
#include <vector>
#include <string>


void testPrimatives()
{
    PRINT_INFO((signed int)(0));
	PRINT_INFO((bool)(0));
	PRINT_INFO((signed char)(0));
	PRINT_INFO((unsigned char)(0));
	PRINT_INFO((char)(0));
	PRINT_INFO((wchar_t)(0));
	PRINT_INFO((char16_t)(0));
	PRINT_INFO((char32_t)(0));
	PRINT_INFO((int)(0));
	PRINT_INFO((short)(0));
	PRINT_INFO((short int)(0));
	PRINT_INFO((signed short)(0));
	PRINT_INFO((signed short int)(0));
	PRINT_INFO((unsigned short)(0));
	PRINT_INFO((unsigned short int)(0));
	PRINT_INFO((signed)(0));
	PRINT_INFO((signed int)(0));
	PRINT_INFO((unsigned)(0));
	PRINT_INFO((unsigned int)(0));
	PRINT_INFO((long)(0));
	PRINT_INFO((long int)(0));
	PRINT_INFO((signed long)(0));
	PRINT_INFO((signed long int)(0));
	PRINT_INFO((unsigned long)(0));
	PRINT_INFO((unsigned long int)(0));
	PRINT_INFO((long long)(0));
	PRINT_INFO((long long int)(0));
	PRINT_INFO((signed long long)(0));
	PRINT_INFO((signed long long int)(0));
	PRINT_INFO((unsigned long long)(0));
	PRINT_INFO((unsigned long long int)(0));
	PRINT_INFO((float)(0));
	PRINT_INFO((double)(0));
	PRINT_INFO((long double)(0));
	PRINT_INFO((int8_t)(0));
	PRINT_INFO((int16_t)(0));
	PRINT_INFO((int32_t)(0));
	PRINT_INFO((int64_t)(0));
	PRINT_INFO((int_fast8_t)(0));
	PRINT_INFO((int_fast16_t)(0));
	PRINT_INFO((int_fast32_t)(0));
	PRINT_INFO((int_fast64_t)(0));
	PRINT_INFO((int_least8_t)(0));
	PRINT_INFO((int_least16_t)(0));
	PRINT_INFO((int_least32_t)(0));
	PRINT_INFO((int_least64_t)(0));
	PRINT_INFO((intmax_t)(0));
	PRINT_INFO((intptr_t)(0));
	PRINT_INFO((uint8_t)(0));
	PRINT_INFO((uint16_t)(0));
	PRINT_INFO((uint32_t)(0));
	PRINT_INFO((uint64_t)(0));
	PRINT_INFO((uint_fast8_t)(0));
	PRINT_INFO((uint_fast16_t)(0));
	PRINT_INFO((uint_fast32_t)(0));
	PRINT_INFO((uint_fast64_t)(0));
	PRINT_INFO((uint_least8_t)(0));
	PRINT_INFO((uint_least16_t)(0));
	PRINT_INFO((uint_least32_t)(0));
	PRINT_INFO((uint_least64_t)(0));
	PRINT_INFO((uintmax_t)(0));
	PRINT_INFO((uintptr_t)(0));
	PRINT_INFO(std::vector<int>(40));
	PRINT_INFO(testPrimatives);
	
	PRINT_INFO((int *)(0));
	enum color { red, green = 5, blue };
	PRINT_INFO((color)(0));
	PRINT_INFO((wchar_t)(0));
	
	//PRINT_INFO((__int128)(0));
	//PRINT_INFO((false)(0));
	PRINT_INFO((unsigned)(0));	
	PRINT_INFO((false));
	PRINT_INFO((nullptr));
	PRINT_INFO((true));
	//PRINT_INFO((namespace)(0));

	//myType type = { 1,2 };
	//printInfo("myType", type);
	
}

int main()
{
    testPrimatives();
}#include "typeInspection.h"

const std::string unknown_machine::type = "unknown";
const std::string ILP32_machine::type = "ILP32 Win32, 32-bit *nix";
const std::string LP32_machine::type = "LP32 Win16";
const std::string LLP64_machine::type = "LLP64 Win64";
const std::string ILP64_machine::type = "ILP64 64-bit *nix";#include "vectorint.h"
#include <iostream>
#include <algorithm>

int main()
{
	VectorInt numbers;
	numbers.push_back(5);
	numbers.push_back(5);
	numbers.push_back(42);
	numbers.push_back(6);

	for (auto x : numbers)
	{
		std::cout << x << " ";
	}
	std::cout << "\n";

	return 0;
}#include "vectorint.h"
#include <stdexcept>

// -------------------------------------------------- VECTORINT

int & VectorInt::operator[](VectorInt::size_type pos)
{
	return array_[pos];
}

VectorInt::size_type VectorInt::size() const
{
	return size_;
}

VectorInt::iterator VectorInt::begin()
{
	return VectorInt::iterator(this, 0);
}

VectorInt::iterator VectorInt::end()
{
	return VectorInt::iterator(this, size_);
}


void VectorInt::push_back(int x)
{
	if (size_ >= capacity_)
	{
		grow();
	}
	array_[size_] = x;
	size_++;
}

void VectorInt::pop_back()
{
	if (size_ == 0)
		throw std::runtime_error("ARRAY IS EMPTY YOU IDIOT!!!");

	size_--;
}

int VectorInt::back() const
{
	if (size_ == 0)
		throw std::runtime_error("ARRAY IS EMPTY YOU IDIOT!!!");

	return array_[size_ -1];
}

void VectorInt::grow()
{
	
	if (capacity_ == 0)
	{
		capacity_ = 10;
	}
	else
	{
		capacity_ *= 2;
	}

	auto tmp = std::make_unique<int[]>(capacity_);
	for (auto i = 0U; i < size_; ++i)
		tmp[i] = array_[i];
	array_ = std::move(tmp);
}

// -------------------------------------------------- VECTORINTITERATOR
VectorIntIterator::VectorIntIterator(VectorInt* ptr, VectorInt::size_type pos) :container_(ptr), pos_(pos) {}

VectorInt::iterator& VectorIntIterator::operator++()
{
	pos_++;
	return *this;
}

VectorInt::iterator VectorIntIterator::operator++(int)
{
	VectorIntIterator tmp = *this;
	pos_++;
	return tmp;
}

VectorInt::iterator & VectorIntIterator::operator--()
{
	pos_--;
	return *this;
}

VectorInt::iterator VectorIntIterator::operator--(int)
{
	VectorIntIterator tmp = *this;
	pos_--;
	return tmp;
}

VectorInt::reference VectorIntIterator::operator*()
{	
	return (*container_)[pos_];
}

bool VectorIntIterator::operator!=(const VectorInt::iterator & v)
{
	return container_ != v.container_ || pos_ != v.pos_;
}

bool VectorIntIterator::operator==(const VectorInt::iterator & v)
{	
	return !(*this != v);		
	//return container_ == v.container_ && pos_ == v.pos_;
}

#include "Case_Manipulation.h"

////////////////////////////////////////////////////////////////////
//////////////////////////// Stub Code /////////////////////////////
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
////////////////////////// IMPORTANT NOTE //////////////////////////
////////////////////////////////////////////////////////////////////
// You may not utilize and C Standard libraries in this header.
////////////////////////////////////////////////////////////////////

////////////////////////////// FUNC 1 //////////////////////////////
// ARGUMENTS:
//		letter - numerical representation of a single character
// PURPOSE:
//		Change the case of letter if it is in fact an alphabet letter
// RETURN:
//		If letter is a lower-case alphabet letter, return its upper-case
//		If letter is an upper-case alphabet letter, return its lower-case
//		If letter is not an alphabet letter, return letter
unsigned int chg_alpha_case(unsigned int letter)
{
	////////////////////////////////////
	/* INSERT YOUR CODE SOLUTION HERE */
	////////////////////////////////////
	return (letter >= 'A' && letter <= 'Z') ? letter + 32 : (letter >= 'a' && letter <= 'z') ? letter - 32 : letter;	
}


////////////////////////////// FUNC 2 //////////////////////////////
// ARGUMENTS:
//		string_ptr - a pointer to a nul-terminated string
// PURPOSE:
//		Change the case of each alphabet letter in string using chg_alpha_case()
// RETURN:
//		If string_ptr is NULL, return NULL
//		Otherwise, return string_ptr
char * chg_string_case(char * string_ptr)
{
	////////////////////////////////////
	/* INSERT YOUR CODE SOLUTION HERE */
	////////////////////////////////////
	char *p = string_ptr;

	// Empty string
	if (!p) return NULL;

	// Change case, march down string
	while ((*(p++) = chg_alpha_case(*p)) != '\0');

	return string_ptr;	// Return the beginning of the string
}

////////////////////////////// FUNC 3 //////////////////////////////
// ARGUMENTS:
//		string_ptr - a pointer to a nul-terminated string
//		start_here - the index of the nul-terminated string to begin at (see: string_ptr)
// PURPOSE:
//		Starting at index "start_here" utilize chg_string_case() to change the case of...
//			...each alphabet letter in string_ptr
// RETURN:
//		If string_ptr is NULL, return NULL
//		If start_here is outside of the string, return NULL
//		Otherwise, return a pointer to index "start_here"
char * chg_starting_here(char * string_ptr, int start_here)
{
	////////////////////////////////////
	/* INSERT YOUR CODE SOLUTION HERE */
	////////////////////////////////////
	char *p = string_ptr;
	int i = 0;
		
	// Return ((void*)0) if ((void*)0)
	if (!p) return NULL;

	// Strlen
	while (*(p++) != '\0') i++;

	// If start_here is outside of the string, return NULL
	if (i <= start_here) return NULL;

	// Change case at start_here and return pointer
	return chg_string_case(string_ptr + start_here);
}
#include "Case_Manipulation.h"
#include <stdio.h>
#include <string.h>

//#define EXTRA_DEBUG				// Uncomment this for more feedback on array mismatches
#define DEFAULT_VALUE (char)254
#define SAFE_BUFF 128
#define MAX_VALUE ((unsigned int)(1 << ((sizeof(char) * 8) - 1)))
#define RUN_FUNC1_TEST			// unsigned int chg_alpha_case(unsigned int letter);
#define RUN_FUNC2_TEST			// char * chg_string_case(char * string_ptr);
#define RUN_FUNC3_TEST			// char * chg_starting_here(char * string_ptr, int start_here);

struct FUNC_1_TEST
{
	char inputChar;
	char outputChar;
	char expectedChar;
}; /* int chg_alpha_case(int letter) */

struct FUNC_2_TEST
{
	char * inputString;
//	char * outputString;
	char * expectedString;
	int arrayLength;
}; /* char * chg_string_case(char * string_ptr) */

struct FUNC_3_TEST
{
	char * inputString;
	int inputPosition;
	char * expected_ptr;
	char * expectedString;
	int arrayLength;
}; /* char * chg_starting_here(char * string_ptr, int start_here) */

int main(void)
{
	/* GENERAL VARIABLES */
	int i = 0;

	/* FUNCTION 1 TESTING - int chg_alpha_case(int letter) */
	// Test input creation
	struct FUNC_1_TEST func1Test0 = { 0x0, DEFAULT_VALUE, 0x0 };
	struct FUNC_1_TEST func1Test1 = { 0x9, DEFAULT_VALUE, 0x9 };
	struct FUNC_1_TEST func1Test2 = { 0xA, DEFAULT_VALUE, 0xA };
	struct FUNC_1_TEST func1Test3 = { 0x20, DEFAULT_VALUE, 0x20 };
	struct FUNC_1_TEST func1Test4 = { 0x30, DEFAULT_VALUE, 0x30 };
	struct FUNC_1_TEST func1Test5 = { 0x36, DEFAULT_VALUE, 0x36 };
	struct FUNC_1_TEST func1Test6 = { 0x39, DEFAULT_VALUE, 0x39 };
	struct FUNC_1_TEST func1Test7 = { 0x40, DEFAULT_VALUE, 0x40 };
	struct FUNC_1_TEST func1Test8 = { 0x41, DEFAULT_VALUE, 0x61 };
	struct FUNC_1_TEST func1Test9 = { 0x48, DEFAULT_VALUE, 0x68 };
	struct FUNC_1_TEST func1Test10 = { 0x5A, DEFAULT_VALUE, 0x7A };
	struct FUNC_1_TEST func1Test11 = { 0x5B, DEFAULT_VALUE, 0x5B };
	struct FUNC_1_TEST func1Test12 = { 0x60, DEFAULT_VALUE, 0x60 };
	struct FUNC_1_TEST func1Test13 = { 0x61, DEFAULT_VALUE, 0x41 };
	struct FUNC_1_TEST func1Test14 = { 0x6A, DEFAULT_VALUE, 0x4A };
	struct FUNC_1_TEST func1Test15 = { 0x7A, DEFAULT_VALUE, 0x5A };
	struct FUNC_1_TEST func1Test16 = { 0x7B, DEFAULT_VALUE, 0x7B };
	struct FUNC_1_TEST func1Test17 = { 0x7F, DEFAULT_VALUE, 0x7F };
	struct FUNC_1_TEST func1Test18 = { 0x80, DEFAULT_VALUE, 0x80 };
	struct FUNC_1_TEST func1Test19 = { 0xFE, DEFAULT_VALUE, 0xFE };
	struct FUNC_1_TEST func1Test20 = { 0xFF, DEFAULT_VALUE, 0xFF };
	struct FUNC_1_TEST func1Test21 = { MAX_VALUE, DEFAULT_VALUE, MAX_VALUE };

	struct FUNC_1_TEST * func1TestArray[] = { \
		&func1Test0, &func1Test1, &func1Test2, &func1Test3, \
		&func1Test4, &func1Test5, &func1Test6, &func1Test7, \
		&func1Test8, &func1Test9, &func1Test10, &func1Test11, \
		&func1Test12, &func1Test13, &func1Test14, &func1Test15, \
		&func1Test16, &func1Test17, &func1Test18, &func1Test19, \
		&func1Test20, &func1Test21
	};

	int numFunc1Tests = sizeof(func1TestArray) / sizeof((*(func1TestArray)));
	int numFunc1TestsRun = 0;
	int numFunc1TestsPassed = 0;
	struct FUNC_1_TEST * currentTest1 = NULL;

#ifdef RUN_FUNC1_TEST
	// Run and report on test completion
	printf("\n\nRUNNING FUNCTION 1 TESTS:\n");
	for (i = 0; i < numFunc1Tests; i++)
	{
		currentTest1 = (*(func1TestArray + i));
		if (currentTest1)
		{
			printf("    Func1 Test %02d:\t", i);
			currentTest1->outputChar = chg_alpha_case(currentTest1->inputChar);
			numFunc1TestsRun++;

			if (currentTest1->outputChar == currentTest1->expectedChar)
			{
				printf("[*] Success! Values are equal.\n");
				numFunc1TestsPassed++;
			}
			else
			{
				printf("[x] Test Failed! Results are not equal!\n");
				printf("\tInput:\t%c | Expected:\t%c | Received:\t%c\n", currentTest1->inputChar, currentTest1->expectedChar, currentTest1->outputChar);
			}
		}
		else
		{
			fprintf(stderr, "Function 1 Test %d struct pointer variable was NULL?!\n", i);
		}
	}

	// Provide overall score
	printf("END OF FUNCTION 1 TESTS\n");
	if (numFunc1Tests != numFunc1TestsRun)
	{
		fprintf(stderr, "\t***Error: Test Number Mismatch***\n");
	}
	printf("\tFunc1 Tests Run:\t%d\n", numFunc1TestsRun);
	printf("\tFunc1 Tests Passed:\t%d\n", numFunc1TestsPassed);
#endif /* RUN_FUNC1_TEST */


	/* FUNCTION 2 TESTING - char * chg_string_case(char * string_ptr) */
	// Test input creation
	//// Normal input
	char test2string0[] = { "This is just a normal string." };
	char test2output0[] = { "tHIS IS JUST A NORMAL STRING." };
	char test2string1[] = { "This is also merely a normal string." };
	char test2output1[] = { "tHIS IS ALSO MERELY A NORMAL STRING." };
	char test2string2[] = { "tHIS IS JUST A NORMAL STRING." };
	char test2output2[] = { "This is just a normal string." };
	char test2string3[] = { "tHIS IS ALSO MERELY A NORMAL STRING." };
	char test2output3[] = { "This is also merely a normal string." };
	struct FUNC_2_TEST func2Test0 = { test2string0, test2output0, sizeof(test2string0) };
	struct FUNC_2_TEST func2Test1 = { test2string1, test2output1, sizeof(test2string1) };
	struct FUNC_2_TEST func2Test2 = { test2string2, test2output2, sizeof(test2string2) };
	struct FUNC_2_TEST func2Test3 = { test2string3, test2output3, sizeof(test2string3) };
	//// No letters
	char test2string4[] = { "!@#$%^&*()<>?,./;':[]{}-=_+" };
	char test2output4[] = { "!@#$%^&*()<>?,./;':[]{}-=_+" };
	char test2string5[] = { "1234567890" };
	char test2output5[] = { "1234567890" };
	struct FUNC_2_TEST func2Test4 = { test2string4, test2output4, sizeof(test2string4) };
	struct FUNC_2_TEST func2Test5 = { test2string5, test2output5, sizeof(test2string5) };
	//// Non printable characters
	char test2string6[] = { 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA, 0x0 };
	char test2output6[] = { 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA, 0x0 };
	char test2string7[] = { 0xFF, 0xFE, 0xFD, 0xFC, 0xFB, 0xFA, 0xF9, 0xF8, 0x0 };
	char test2output7[] = { 0xFF, 0xFE, 0xFD, 0xFC, 0xFB, 0xFA, 0xF9, 0xF8, 0x0 };
	struct FUNC_2_TEST func2Test6 = { test2string6, test2output6, sizeof(test2string6) };
	struct FUNC_2_TEST func2Test7 = { test2string7, test2output7, sizeof(test2string7) };
	//// Hidden strings
	char test2string8[] = { "This is not the only sentence in this char array. There's another sentence hidden after the nul character." };
	test2string8[49] = 0x0;
	char test2output8[] = { "tHIS IS NOT THE ONLY SENTENCE IN THIS CHAR ARRAY. There's another sentence hidden after the nul character." };
	test2output8[49] = 0x0;
	char test2string9[] = { "tHIS IS NOT THE ONLY SENTENCE IN THIS CHAR ARRAY. There's another sentence hidden after the nul character." };
	test2string9[49] = 0x0;
	char test2output9[] = { "This is not the only sentence in this char array. There's another sentence hidden after the nul character." };
	test2output9[49] = 0x0;
	char test2string10[] = { "One. Two. Three." };
	test2string10[4] = 0x0;
	test2string10[9] = 0x0;
	char test2output10[] = { "oNE. Two. Three." };
	test2output10[4] = 0x0;
	test2output10[9] = 0x0;
	char test2string11[] = { "oNE. Two. Three." };
	test2string11[4] = 0x0;
	test2string11[9] = 0x0;
	char test2output11[] = { "One. Two. Three." };
	test2output11[4] = 0x0;
	test2output11[9] = 0x0;
	struct FUNC_2_TEST func2Test8 = { test2string8, test2output8, sizeof(test2string8) };
	struct FUNC_2_TEST func2Test9 = { test2string9, test2output9, sizeof(test2string9) };
	struct FUNC_2_TEST func2Test10 = { test2string10, test2output10, sizeof(test2string10) };
	struct FUNC_2_TEST func2Test11 = { test2string11, test2output11, sizeof(test2string11) };
	//// Zero length strings
	char test2string12[1] = { 0x0 };
	char test2output12[1] = { 0x0 };
	char test2string13[] = { 0x0, 0x41, 0x42, 0x43, 0x31, 0x32, 0x33, 0x0 };
	char test2output13[] = { 0x0, 0x41, 0x42, 0x43, 0x31, 0x32, 0x33, 0x0 };
	struct FUNC_2_TEST func2Test12 = { test2string12, test2output12, sizeof(test2string12) };
	struct FUNC_2_TEST func2Test13 = { test2string13, test2output13, sizeof(test2string13) };
	//// NOTE: Don't forget a NULL pointer
	struct FUNC_2_TEST func2Test14 = { NULL, NULL, 0 };
	//// Mixed input
	char test2string15[] = { "This string has it all:\n\tPrintable characters, non-printable characters, ______, hidden strings... the works! You shouldn't be changing anything back here!\nStop reading this!" };
	test2string15[73] = 232; // 0
	test2string15[74] = 124; // 1
	test2string15[75] = 253; // 2
	test2string15[76] = 227; // 3
	test2string15[77] = 252; // n
	test2string15[78] = 236; // infinity
	test2string15[108] = 0x0;
	char test2output15[] = { "tHIS STRING HAS IT ALL:\n\tpRINTABLE CHARACTERS, NON-PRINTABLE CHARACTERS, ______, HIDDEN STRINGS... THE WORKS! You shouldn't be changing anything back here!\nStop reading this!" };
	test2output15[73] = 232; // 0
	test2output15[74] = 124; // 1
	test2output15[75] = 253; // 2
	test2output15[76] = 227; // 3
	test2output15[77] = 252; // n
	test2output15[78] = 236; // infinity
	test2output15[108] = 0x0;
//	puts(test2output15); // DEBUGGING
	char test2string16[] = { 0x48, 0x61, 0x72, 0x6B, 0x3F, 0x9, 159, 230, 40, 204, 60, 0x0, 0x53, 0x74, 0x6F, 0x70, 0x21, 0x0 };
	char test2output16[] = { 0x68, 0x41, 0x52, 0x4B, 0x3F, 0x9, 159, 230, 40, 204, 60, 0x0, 0x53, 0x74, 0x6F, 0x70, 0x21, 0x0 };
//	puts(test2string16); // DEBUGGING
	struct FUNC_2_TEST func2Test15 = { test2string15, test2output15, sizeof(test2string15) };
	struct FUNC_2_TEST func2Test16 = { test2string16, test2output16, sizeof(test2string16) };


	struct FUNC_2_TEST * func2TestArray[] = { \
		&func2Test0, &func2Test1, &func2Test2, &func2Test3, \
		&func2Test4, &func2Test5, &func2Test6, &func2Test7, \
		&func2Test8, &func2Test9, &func2Test10, &func2Test11, \
		&func2Test12, &func2Test13, &func2Test14, &func2Test15, \
		&func2Test16
	};

	int numFunc2Tests = sizeof(func2TestArray) / sizeof((*(func2TestArray)));
	int numFunc2TestsRun = 0;
	int numFunc2TestsPassed = 0;
	struct FUNC_2_TEST * currentTest2 = &func2Test0;
	char * tempReturnValue2 = NULL;

#ifdef RUN_FUNC2_TEST
	// Run and report on test completion
	printf("\n\nRUNNING FUNCTION 2 TESTS:\n");
	for (i = 0; i < numFunc2Tests; i++)
	{
		currentTest2 = (*(func2TestArray + i));
		if (currentTest2)
		{
			printf("    Func2 Test %02d:\t", i);
			tempReturnValue2 = chg_string_case(currentTest2->inputString);
			numFunc2TestsRun++;

			if (currentTest2->expectedString != NULL && tempReturnValue2 != NULL)
			{
				if (!(memcmp(currentTest2->expectedString, tempReturnValue2, currentTest2->arrayLength)))
				{
					printf("[*] Success! Arrays are equivalent.\n");
					numFunc2TestsPassed++;
				}
				else
				{
					printf("[x] Test Failed! Array mismatch!\n");
					printf("\tExpected:\t%s\n\tReceived:\t%s\n", currentTest2->expectedString, tempReturnValue2);
				}
			}
			else
			{
				if (currentTest2->expectedString == tempReturnValue2)
				{
					printf("[*] Success! Pointers are equivalent.\n");
					numFunc2TestsPassed++;
				}
				else
				{
					printf("[x] Test Failed! Pointer mismatch!\n");
					printf("\tExpected:\t");
					if (currentTest2->expectedString == NULL)
					{
						printf("NULL\n\t");
					}
					else
					{
						printf("%s\n\t", currentTest2->expectedString);
					}
					printf("Received:\t");
					if (tempReturnValue2 == NULL)
					{
						printf("NULL\n");
					}
					else
					{
						printf("%s\n", tempReturnValue2);
					}
				}
			}
		}
		else
		{
			fprintf(stderr, "Function 2 Test %d struct pointer variable was NULL?!\n", i);
		}
	}

	// Provide overall score
	printf("END OF FUNCTION 2 TESTS\n");
	if (numFunc2Tests != numFunc2TestsRun)
	{
		fprintf(stderr, "\t***Error: Test Number Mismatch***\n");
	}
	printf("\tFunc2 Tests Run:\t%d\n", numFunc2TestsRun);
	printf("\tFunc2 Tests Passed:\t%d\n", numFunc2TestsPassed);
#endif /* RUN_FUNC2_TEST */


	/* FUNCTION 3 TESTING - char * chg_starting_here(char * string_ptr, int start_here) */
	// Test input creation
	//// Normal input
	char test3string0[] = { "This is just a normal string." };
	char test3output0[] = { "This IS JUST A NORMAL STRING." };
	char test3string1[] = { "This is also merely a normal string." };
	char test3output1[] = { "This is ALSO MERELY A NORMAL STRING." };
	char test3string2[] = { "tHIS IS JUST A NORMAL STRING." };
	char test3output2[] = { "tHIS IS JUst a normal string." };
	char test3string3[] = { "tHIS IS ALSO MERELY A NORMAL STRING." };
	char test3output3[] = { "tHIS IS ALSO MERely a normal string." };
	struct FUNC_3_TEST func3Test0 = { test3string0, 4, test3string0 + 4, test3output0, sizeof(test3string0) };
	struct FUNC_3_TEST func3Test1 = { test3string1, 8, test3string1 + 8, test3output1, sizeof(test3string1) };
	struct FUNC_3_TEST func3Test2 = { test3string2, 10, test3string2 + 10, test3output2, sizeof(test3string2) };
	struct FUNC_3_TEST func3Test3 = { test3string3, 16, test3string3 + 16, test3output3, sizeof(test3string3) };
	//// No letters
	char test3string4[] = { "!@#$%^&*()<>?,./;':[]{}-=_+" };
	char test3output4[] = { "!@#$%^&*()<>?,./;':[]{}-=_+" };
	char test3string5[] = { "1234567890" };
	char test3output5[] = { "1234567890" };
	struct FUNC_3_TEST func3Test4 = { test3string4, 0, test3string4, test3output4, sizeof(test3string4) };
	struct FUNC_3_TEST func3Test5 = { test3string5, 0, test3string5, test3output5, sizeof(test3string5) };
	//// Non printable characters
	char test3string6[] = { 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA, 0x0 };
	char test3output6[] = { 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA, 0x0 };
	char test3string7[] = { 0xFF, 0xFE, 0xFD, 0xFC, 0xFB, 0xFA, 0xF9, 0xF8, 0x0 };
	char test3output7[] = { 0xFF, 0xFE, 0xFD, 0xFC, 0xFB, 0xFA, 0xF9, 0xF8, 0x0 };
	struct FUNC_3_TEST func3Test6 = { test3string6, 0, test3string6, test3output6, sizeof(test3string6) };
	struct FUNC_3_TEST func3Test7 = { test3string7, 0, test3string7, test3output7, sizeof(test3string7) };
	//// Hidden strings
	char test3string8[] = { "This is not the only sentence in this char array. There's another sentence hidden after the nul character." };
	test3string8[49] = 0x0;
	char test3output8[] = { "tHIS IS NOT THE ONLY SENTENCE IN THIS CHAR ARRAY. There's another sentence hidden after the nul character." };
	test3output8[49] = 0x0;
	char test3string9[] = { "tHIS IS NOT THE ONLY SENTENCE IN THIS CHAR ARRAY. There's another sentence hidden after the nul character." };
	test3string9[49] = 0x0;
	char test3output9[] = { "This is not the only sentence in this char array. There's another sentence hidden after the nul character." };
	test3output9[49] = 0x0;
	char test3string10[] = { "One. Two. Three." };
	test3string10[4] = 0x0;
	test3string10[9] = 0x0;
	char test3output10[] = { "oNE. Two. Three." };
	test3output10[4] = 0x0;
	test3output10[9] = 0x0;
	char test3string11[] = { "oNE. Two. Three." };
	test3string11[4] = 0x0;
	test3string11[9] = 0x0;
	char test3output11[] = { "One. Two. Three." };
	test3output11[4] = 0x0;
	test3output11[9] = 0x0;
	struct FUNC_3_TEST func3Test8 = { test3string8, 0, test3string8, test3output8, sizeof(test3string8) };
	struct FUNC_3_TEST func3Test9 = { test3string9, 0, test3string9, test3output9, sizeof(test3string9) };
	struct FUNC_3_TEST func3Test10 = { test3string10, 0, test3string10, test3output10, sizeof(test3string10) };
	struct FUNC_3_TEST func3Test11 = { test3string11, 0, test3string11, test3output11, sizeof(test3string11) };
	//// Zero length strings
	char test3string12[1] = { 0x0 };
	char test3output12[1] = { 0x0 };
	char test3string13[] = { 0x0, 0x41, 0x42, 0x43, 0x31, 0x32, 0x33, 0x0 };
	char test3output13[] = { 0x0, 0x41, 0x42, 0x43, 0x31, 0x32, 0x33, 0x0 };
	struct FUNC_3_TEST func3Test12 = { test3string12, 0, NULL, test3output12, sizeof(test3string12) };
	struct FUNC_3_TEST func3Test13 = { test3string13, 0, NULL, test3output13, sizeof(test3string13) };
	//// NOTE: Don't forget a NULL pointer
	struct FUNC_3_TEST func3Test14 = { NULL, 0, NULL, 0 };
	//// Mixed input
	char test3string15[] = { "This string has it all:\n\tPrintable characters, non-printable characters, ______, hidden strings... the works! You shouldn't be changing anything back here!\nStop reading this!" };
	test3string15[73] = 232; // 0
	test3string15[74] = 124; // 1
	test3string15[75] = 253; // 2
	test3string15[76] = 227; // 3
	test3string15[77] = 252; // n
	test3string15[78] = 236; // infinity
	test3string15[108] = 0x0;
	char test3output15[] = { "tHIS STRING HAS IT ALL:\n\tpRINTABLE CHARACTERS, NON-PRINTABLE CHARACTERS, ______, HIDDEN STRINGS... THE WORKS! You shouldn't be changing anything back here!\nStop reading this!" };
	test3output15[73] = 232; // 0
	test3output15[74] = 124; // 1
	test3output15[75] = 253; // 2
	test3output15[76] = 227; // 3
	test3output15[77] = 252; // n
	test3output15[78] = 236; // infinity
	test3output15[108] = 0x0;
	//	puts(test3output15); // DEBUGGING
	char test3string16[] = { 0x48, 0x61, 0x72, 0x6B, 0x3F, 0x9, 159, 230, 40, 204, 60, 0x0, 0x53, 0x74, 0x6F, 0x70, 0x21, 0x0 };
	char test3output16[] = { 0x68, 0x41, 0x52, 0x4B, 0x3F, 0x9, 159, 230, 40, 204, 60, 0x0, 0x53, 0x74, 0x6F, 0x70, 0x21, 0x0 };
	//	puts(test3string16); // DEBUGGING
	struct FUNC_3_TEST func3Test15 = { test3string15, 0, test3string15, test3output15, sizeof(test3string15) };
	struct FUNC_3_TEST func3Test16 = { test3string16, 0, test3string16, test3output16, sizeof(test3string16) };
	//// Normal strings with unreasonable lengths
	char test3string17[SAFE_BUFF] = { "Normal string.  Bad starting point." };
	char test3output17[SAFE_BUFF] = { "Normal string.  Bad starting point." };
	char test3string18[SAFE_BUFF] = { "This is a reasonable string but the length that got passed is unreasonable.\0DON'T DO IT!1!!!1!!eleven!1!!!" };
	char test3output18[SAFE_BUFF] = { "This is a reasonable string but the length that got passed is unreasonable.\0DON'T DO IT!1!!!1!!eleven!1!!!" };
	char test3string19[SAFE_BUFF] = { "I hope you didn't modify this string because the starting position is out of bounds.\0hIdDeN sTrInG!1!\0" };
	char test3output19[SAFE_BUFF] = { "I hope you didn't modify this string because the starting position is out of bounds.\0hIdDeN sTrInG!1!\0" };
	char test3string20[SAFE_BUFF] = { "Dont' modify this string.  You're going to have a bad time." };
	char test3output20[SAFE_BUFF] = { "Dont' modify this string.  You're going to have a bad time." };
	char test3string21[] = { "Don't do it!" };
	char test3output21[] = { "Don't do it!" };
	struct FUNC_3_TEST func3Test17 = { test3string17, 35, NULL, test3output17, sizeof(test3string17) };
	struct FUNC_3_TEST func3Test18 = { test3string18, 76, NULL, test3output18, sizeof(test3string18) };
	struct FUNC_3_TEST func3Test19 = { test3string19, 85, NULL, test3output19, sizeof(test3string19) };
	struct FUNC_3_TEST func3Test20 = { test3string20, (SAFE_BUFF - 1), NULL, test3output20, sizeof(test3string20) };
	struct FUNC_3_TEST func3Test21 = { test3string21, 90318, NULL, test3output21, sizeof(test3string21) };


	struct FUNC_3_TEST * func3TestArray[] = { \
		&func3Test0, &func3Test1, &func3Test2, &func3Test3, \
		&func3Test4, &func3Test5, &func3Test6, &func3Test7, \
		&func3Test8, &func3Test9, &func3Test10, &func3Test11, \
		&func3Test12, &func3Test13, &func3Test14, &func3Test15, \
		&func3Test16, &func3Test17, &func3Test18, &func3Test19, \
		&func3Test20, &func3Test21
	};

	int numfunc3Tests = sizeof(func3TestArray) / sizeof((*(func3TestArray)));
	int numfunc3TestsRun = 0;
	int numfunc3TestsPassed = 0;
	struct FUNC_3_TEST * currentTest3 = &func3Test0;
	char * tempReturnValue3 = NULL;

#ifdef RUN_FUNC3_TEST
	// Run and report on test completion
	printf("\n\nRUNNING FUNCTION 3 TESTS:\n");
	for (i = 0; i < numfunc3Tests; i++)
	{
		currentTest3 = (*(func3TestArray + i));
		if (currentTest3)
		{
			printf("    Func3 Test %02d:\t", i);
			tempReturnValue3 = chg_starting_here(currentTest3->inputString, currentTest3->inputPosition);
			numfunc3TestsRun++;

			if (currentTest3->expectedString != NULL && currentTest3->expected_ptr != NULL && tempReturnValue3 != NULL)
			{
				if ((!(memcmp(currentTest3->expectedString, currentTest3->inputString, currentTest3->arrayLength))) && \
					(tempReturnValue3 == currentTest3->expected_ptr))
				{
					printf("[*] Success! Arrays are equivalent.\n");
					numfunc3TestsPassed++;
				}
				else
				{
#ifdef EXTRA_DEBUG
					puts("Something went wrong.");
					printf("Expected:\t%s\n", currentTest3->expectedString);
					printf("Modified:\t%s\n", currentTest3->inputString);
					for (i = 0; i < currentTest3->arrayLength; i++)
					{
						if ((*((currentTest3->expectedString) + i)) != (*((currentTest3->inputString) + i)))
						{
							printf("Index %d is not equal.  Expected: %c\tReceived:\t%d\n", i, (*((currentTest3->expectedString) + i)), (*((currentTest3->inputString) + i)));
						}
					}
#endif // EXTRA_DEBUG
					printf("[x] Test Failed! Array mismatch!\n");
					printf("\tExpected: (%p) \t%s\n\tReceived: (%p) \t%s\n", currentTest3->expected_ptr, currentTest3->expected_ptr, tempReturnValue3, tempReturnValue3);
				}
			}
			else
			{
				if (currentTest3->expected_ptr == tempReturnValue3)
				{
					printf("[*] Success! Pointers are equivalent.\n");
					numfunc3TestsPassed++;
				}
				else
				{
					printf("[x] Test Failed! Pointer mismatch!\n");
					if (currentTest3->expected_ptr == NULL)
					{
						printf("\tExpected: (%p) \tNULL\n", currentTest3->expected_ptr);
					}
					else
					{
						printf("\tExpected: (%p) \t%s\n", currentTest3->expected_ptr, currentTest3->expected_ptr);
					}
					if (tempReturnValue3 == NULL)
					{
						printf("\tReceived: (%p) \tNULL\n", tempReturnValue3);
					}
					else
					{
						printf("\tReceived: (%p) \t%s\n", tempReturnValue3, tempReturnValue3);
					}
				}
			}
		}
		else
		{
			fprintf(stderr, "Function 3 Test %d struct pointer variable was NULL?!\n", i);
		}
	}

	// Provide overall score
	printf("END OF FUNCTION 3 TESTS\n");
	if (numfunc3Tests != numfunc3TestsRun)
	{
		fprintf(stderr, "\t***Error: Test Number Mismatch***\n");
	}
	printf("\tFunc3 Tests Run:\t%d\n", numfunc3TestsRun);
	printf("\tFunc3 Tests Passed:\t%d\n", numfunc3TestsPassed);
#endif /* RUN_FUNC3_TEST */

	return 0;
}
