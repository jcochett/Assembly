<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Introduction to Assembly</title><meta name="generator" content="Hovercraft! 1.0 http://regebro.github.com/hovercraft"></meta><link rel="stylesheet" href="css/hovercraft.css" media="all"></link><link rel="stylesheet" href="css/impressConsole.css" media="all"></link><link rel="stylesheet" href="css/highlight.css" media="all"></link><link rel="stylesheet" href="asm.css" media="screen,projection"></link></head><body class="impress-not-supported"><div id="impress" data-transition-duration="1500"><div class="step step-level-1" step="0" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><h1 id="introduction-to-assembly-programming">Introduction to Assembly Programming</h1><pre class="highlight code nasm"><span class="nf">instructor</span>      <span class="nv">db</span> <span class="s">"Aaron Bray"</span><span class="p">,</span> <span class="mh">0x0a</span><span class="p">,</span> <span class="mh">0x00</span>
<span class="nf">email</span>  <span class="nv">db</span> <span class="s">"aaron.m.bray@gmail.com"</span><span class="p">,</span> <span class="mh">0x0a</span><span class="p">,</span> <span class="mh">0x00</span></pre></div><div class="step step-level-1" step="1" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="1600" data-y="0" data-z="0"><h1 id="course-roadmap">Course Roadmap</h1><pre class="highlight code nasm"><span class="nl">content:</span>
        <span class="nf">jmp</span> <span class="nv">.introduction</span>

<span class="nl">.introduction:</span>
        <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="nv">HowToAsm</span>
        <span class="nf">jmp</span> <span class="nv">.basic_operations</span>

<span class="nl">.basic_operations:</span>
        <span class="nf">call</span> <span class="nv">.arithmetic</span>
        <span class="nf">call</span> <span class="nv">.bit_operations</span>
        <span class="nf">mov</span> <span class="nb">rcx</span><span class="p">,</span> <span class="nv">DataTypes</span>
        <span class="nf">jmp</span> <span class="nv">.control_flow</span>

<span class="nl">.control_flow:</span>
        <span class="nf">jmp</span> <span class="nv">.hardware_essentials</span>

<span class="nl">.hardware_essentials:</span>
        <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="nv">Memory</span>
        <span class="nf">mov</span> <span class="nb">rcx</span><span class="p">,</span> <span class="nv">Interrupts</span>
        <span class="nf">call</span> <span class="nv">FloatingPoint</span>
        <span class="nf">call</span> <span class="nb">Si</span><span class="nv">md</span>
        <span class="nf">call</span> <span class="nv">.systems_programming</span>

<span class="nl">.systems_programming:</span>
        <span class="nf">ret</span></pre></div><div class="step step-level-1" step="2" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="3200" data-y="0" data-z="0"><h1 id="assembly-an-introduction">Assembly: An Introduction</h1></div><div class="step step-level-1" step="3" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="4800" data-y="0" data-z="0"><h1 id="objectives">Objectives</h1><ul><li>Understand the relationship between assembly language and opcodes</li><li>Understand byte ordering, as it pertains to Assembly Programming</li><li>Identify x86(_64) General Purpose Registers</li><li>Perform basic memory access operations</li><li>Begin debugging with the GNU Source-Level Debugger (GDB)</li><li>Understand basic data sizes and types with regard to x86(_64)</li></ul></div><div class="step step-level-1" step="4" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="6400" data-y="0" data-z="0"><h1 id="understanding-assembly">Understanding Assembly</h1><ul><li><dl><dt>What is Assembly?</dt><dd><ul><li>Provides "instructions" (human-friendly) that map to "opcodes" (processor-friendly)</li><li>Typically very hardware-specific</li></ul></dd></dl></li><li><dl><dt>Why use assembly?</dt><dd><ul><li>Performance</li><li>Utilize otherwise unexposed hardware features</li><li>Some operations can't easily be expressed in higher level languages (such as C)</li></ul></dd></dl></li></ul><div class="notes"><p>Performance is now much less often a reason to use assembly than it was in the past (as compilers have steadily improved, and more features exposed via intrinsics).</p></div></div><div class="step step-level-1" step="5" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="8000" data-y="0" data-z="0"><h1 id="assembly-instructions">Assembly Instructions</h1><ul><li>Typically consist of an instruction of some kind, and some operands</li><li><dl><dt>Operands can consist of several things, to include:</dt><dd><ul><li>Registers</li><li>Memory Addresses</li><li>Immediate (literal) Values</li></ul></dd></dl></li><li>Other data types and some prefixes (which modify what the instruction does) also exist</li></ul></div><div class="step step-level-1" step="6" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="9600" data-y="0" data-z="0"><h1 id="opcodes">Opcodes</h1><ul><li>One or more bytes that the processor decodes (and executes)</li><li>Typically direct translations from assembly language instructions</li><li>x86 and x86_64 instructions are variable length</li><li>Syntax is (slightly) complicated</li></ul></div><div class="step step-level-1" step="7" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="11200" data-y="0" data-z="0"><h1 id="id1">Assembly Instructions</h1><p>This set of instructions:</p><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="mh">0x01</span>
<span class="nf">ret</span></pre><p>Becomes...</p><div class="notes"><p>Thus, this set of instructions becomes the follow set of opcodes.</p></div></div><div class="step step-level-1" step="8" data-x="11200" data-y="0" data-rotate-y="90" data-rotate-x="0" data-rotate-z="90" data-scale="1" data-z="0"><h1 id="id2">Opcodes</h1><p>...This set of opcodes</p><pre class="highlight code objdump-nasm"><span class="x">0xb8 0x01 0x00 0x00 0x00
0xc3</span></pre><div class="notes"><p>Perform opcodes demo</p></div></div><div class="step step-level-1" step="9" data-x="11200" data-y="2000" data-rotate-y="0" data-rotate-x="0" data-rotate-z="90" data-scale="1" data-z="0"><h1 id="assemblers-and-syntax">Assemblers and Syntax</h1><ul><li><dl><dt>A number of different options exist for assemblers</dt><dd><ul><li>GAS - the GNU Assembler</li><li>nasm/yasm - The Netwide Assembler/Yet another Assembler (a rewrite of NASM)</li><li>masm - the Microsoft assembler</li></ul></dd></dl></li><li>Most have special quirks and slight differences in how syntax is handled (though they are similar)</li><li>This course will focus on NASM, which uses Intel syntax</li></ul></div><div class="step step-level-1" step="10" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="11200" data-y="4000" data-z="0"><h1 id="syntax-differences-some-examples">Syntax Differences - Some Examples</h1><ul><li>Intel Syntax: Used by NASM/YASM and others</li></ul><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="mh">0x01</span></pre><ul><li>AT&amp;T Syntax: Used by GAS and others</li></ul><pre class="highlight code gas"><span class="nf">movl</span> <span class="no">$0x01</span><span class="p">,</span> <span class="nv">%eax</span></pre><ul><li>Other flavors also exist</li></ul><div class="notes"><p>This is one very blatant example, but many other assemblers (MASM, etc) will have small quirks to how you type in your assembly instructions. All equate to (about) the same thing, however.</p></div></div><div class="step step-level-1" step="11" data-y="6000" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="11200" data-z="0"><h1 id="byte-ordering">Byte Ordering</h1><ul><li>Determines the order bytes appear in memory</li><li><dl><dt>Big Endian stores the most significant (or biggest) value first</dt><dd><ul><li>the memory address: 0x10203040 would appear as: 0x10 0x20 0x30 0x40</li></ul></dd></dl></li><li><dl><dt>Little Endian puts the least significant (or little) value first</dt><dd><ul><li>the memory address: 0x10203040 would appear as: 0x40 0x30 0x20 0x10</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="12" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="11200" data-y="8000" data-z="0"><h1 id="id3">Byte Ordering</h1><ul><li>x86(_64) is little Endian</li><li>Again, least significant byte (not bit) appears first</li></ul><p>In memory, this address:</p><pre class="highlight code">0xdeadbeef</pre></div><div class="step step-level-1" step="13" data-x="11200" data-y="8000" data-rotate-y="90" data-rotate-x="0" data-rotate-z="90" data-scale="1" data-z="0"><h1 id="id4">Byte Ordering</h1><p>Becomes:</p><pre class="highlight code">0xefbeadde</pre></div><div class="step step-level-1 split-table" step="14" data-y="10000" data-rotate-x="0" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="11200" data-z="0"><h1 id="id5">Byte Ordering</h1><table cellpadding="0" cellspacing="0"><tbody><tr><td><p>Initial:</p></td><td><p>0xde</p></td><td><p>0xad</p></td><td><p>0xbe</p></td><td><p>0xef</p></td></tr><tr><td><p>Memory:</p></td><td><p>0xef</p></td><td><p>0xbe</p></td><td><p>0xad</p></td><td><p>0xde</p></td></tr></tbody></table></div><div class="step step-level-1" step="15" data-rotate-x="0" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="11200" data-y="12000" data-z="0"><h1 id="memory-the-10-000-foot-view">Memory: The 10,000 Foot View</h1><ul><li>Various Memory Components take differing amounts of time to access</li><li>Most higher level languages (such as C) abstract this away, the developer is not really exposed to it</li><li>Assembly gives you a bit more control (though some things are still hidden on most modern platforms)</li></ul></div><div class="step step-level-1" step="16" data-rotate-x="0" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="11200" data-y="14000" data-z="0"><h1 id="the-memory-hierarchy">The Memory Hierarchy</h1><p>From Fastest Access to Slowest:</p><ul><li>Registers</li><li>Cache (L1/L2/L3)</li><li>System Memory</li><li>Disk</li></ul></div><div class="step step-level-1" step="17" data-rotate-x="0" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="11200" data-y="16000" data-z="0"><h1 id="virtual-memory">Virtual Memory</h1><ul><li>Hardware allows abstraction of memory addressing</li><li>Most addressing deals with virtual addresses, which are translated (via lookup table) to physical addresses</li><li>More than one "view" of a physical memory segment can exist (in different processes)</li><li>Each user mode process appears to have a full range of addressable memory and resources</li><li>Most modern OSes support paging, allowing us to pretend we have a much greater amount of physical memory than actually exists</li></ul><div class="notes"><p>We will discuss virtual memory and memory mappings in general later on, when we discuss specific hardware features</p></div></div><div class="step step-level-1 shrink-image block-image" step="18" data-rotate-x="0" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="11200" data-y="18000" data-z="0"><h1 id="process-memory-layout">Process Memory Layout</h1><p>A Very High level view:</p><img src="./images/Process_Layout.svg"></img></div><div class="step step-level-1" step="19" data-rotate-x="0" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="11200" data-y="20000" data-z="0"><h1 id="id6">Process Memory Layout</h1><ul><li>Stack Segments typically grown from high to low memory addresses</li><li><dl><dt>Modules in the previous diagram indicate executable files loaded into the process space; some examples include:</dt><dd><ul><li>glibc (more specifically, the .so containing the libc code)</li><li>kernel32.dll</li><li>Currently running executable</li></ul></dd></dl></li><li>Heap sections and Anonymous Mappings</li><li>Kernel memory</li><li>Other Items</li></ul></div><div class="step step-level-1" step="20" data-rotate-x="0" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="11200" data-y="22000" data-z="0"><h1 id="registers">Registers</h1><ul><li>Assembly programming gives us total control over access to these</li><li>Special hardware structures on the processor</li><li>Some are general purpose (e.g., can store any type of data)</li><li>Others are specialized, and may contain status codes, flags, etc., or be associated with specific hardware</li><li>Limited in number</li></ul></div><div class="step step-level-1" step="21" data-rotate-x="0" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="11200" data-y="24000" data-z="0"><h1 id="general-purpose-registers">General Purpose Registers</h1><ul><li>Shared registers have addressable subregisters</li><li>64 bit/32 bit/16 bit/8 bit</li><li>x86_64 contains many more general purpose registers than x86
(though they don't all have subregisters)</li></ul></div><div class="step step-level-1 register-table" step="22" data-rotate-x="90" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="11200" data-y="26000" data-z="0"><h1 id="x86-and-x64-registers">x86 and x64 Registers</h1><img src="images/section_1_register_table.jpg"></img><ul><li>rbp/ebp - Base Pointer</li><li>rsp/esp - Stack Pointer</li></ul><div class="notes"><p>Being general purpose, most of the registers may be
used to store arbitrary values, though some may have defined
uses with certain instructions (which we'll discuss later on).
The registers listed at the bottom generally have some special uses
however, where RIP/EIP points at the current place in memory we are executing, and RSP/ESP typically points to the top of the stack (which will also be discussed in greater detail later on).</p></div></div><div class="step step-level-1" step="23" data-rotate-x="90" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="11200" data-y="28000" data-z="0"><h1 id="registers-cont-d">Registers (cont'd)</h1><ul><li>rip/eip - Instruction Pointer (Program Counter)</li><li>Additional x86_64 Registers: r8 - r15</li></ul></div><div class="step step-level-1" step="24" data-x="13200" data-rotate-x="90" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-y="30000" data-z="0"><h1 id="register-data-and-pointers">Register Data and Pointers</h1><ul><li>General Purpose Registers can contain up to pointer-sized amounts of data (4 bytes on 32 bit, 8 on 64)</li><li>They can also contain memory addresses (pointers) to blocks of data residing elsewhere in the process.</li><li>Addresses can be manipulated via addition, subtraction, multiplication, etc</li><li>Square brackets dereference (access the stuff stored AT the memory address)</li></ul><p>Example:</p><pre class="highlight code nasm"><span class="c1">; A register - we will be operating on whatever</span>
<span class="c1">; happens to be stored in it</span>
<span class="nf">rax</span>
<span class="c1">; We are attempting to access the stuff stored</span>
<span class="c1">; at the address in rax (dereference)</span>
<span class="err">[</span><span class="nf">rax</span><span class="p">]</span></pre></div><div class="step step-level-1" step="25" data-rotate-x="90" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="15200" data-y="32000" data-z="0"><h1 id="register-data-and-pointers-example">Register Data and Pointers - Example</h1><h2 id="first-we-ll-store-a-pointer-memory-address-in-rax-and-then-store-some-stuff-there">First, we'll store a pointer (memory address) in rax, and then store some stuff there:</h2><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mh">0xc0ffee</span> <span class="c1">; a memory address (hopefully valid!)</span>
<span class="nf">mov</span> <span class="p">[</span><span class="nb">rax</span><span class="p">],</span> <span class="mi">100</span> <span class="c1">; now we store some data there!</span></pre><img src="images/section_1_pointers.jpg"></img></div><div class="step step-level-1" step="26" data-rotate-x="90" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="17200" data-y="34000" data-z="0"><h1 id="register-data-and-pointers-example-part-2">Register Data and Pointers - Example (Part 2)</h1><h2 id="now-we-ll-copy-that-address-into-rcx">Now, we'll copy that address into rcx:</h2><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">rcx</span><span class="p">,</span> <span class="nb">rax</span> <span class="c1">; now we copy the pointer!</span></pre><img src="images/section_1_pointers_second_stage.jpg"></img><ul><li>Now both point to the same place!</li></ul></div><div class="step step-level-1" step="27" data-rotate-x="90" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="19200" data-y="36000" data-z="0"><h1 id="register-data-and-pointers-example-part-3">Register Data and Pointers - Example (Part 3)</h1><h2 id="now-we-ll-access-the-data-stored-at-the-address-and-copy-it-into-rcx">Now, we'll access the data stored at the address, and copy it into rcx</h2><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">rcx</span><span class="p">,</span> <span class="p">[</span><span class="nb">rcx</span><span class="p">]</span> <span class="c1">; copy the data from addr 0xc0ffee into rcx</span></pre><img src="images/section_1_pointers_third_stage.jpg"></img><p>Please note that this replaces the old value in rcx, which was just the address we're accessing.</p></div><div class="step step-level-1" step="28" data-rotate-x="90" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="21200" data-y="38000" data-z="0"><h1 id="now-for-our-first-instruction">Now, for our first instruction...</h1></div><div class="step step-level-1" step="29" data-rotate-x="90" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="23200" data-y="40000" data-z="0"><h1 id="nop">NOP</h1><ul><li>Does nothing! (Sort of)</li><li>Used for padding/alignment/timing reasons</li><li>Idempotent instruction (doesn't affect anything else in the system)</li><li>One-byte NOP translates to the opcode: 0x90</li></ul></div><div class="step step-level-1" step="30" data-rotate-x="90" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="25200" data-y="42000" data-z="0"><h1 id="debugging-assembly">Debugging Assembly</h1><ul><li>We will be using the GNU Project Debugger (GDB)</li><li><dl><dt>Command Line Debugger, provides a large set of features</dt><dd><ul><li>Natively supports Python scripting</li><li>Supports a large number of architectures (and even quite a few languages)</li><li>Provides a Text User Interface (TUI) mode</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="31" data-rotate-x="90" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="27200" data-y="44000" data-z="0"><h1 id="debugging-assembly-cont-d">Debugging Assembly (cont'd)</h1><ul><li>Setting breakpoints programmatically may be difficult at times</li><li>A good strategy may include applying breakpoints directly in your code for debugging purposes</li><li>Fortunately, an assembly instruction exists for doing just this:</li></ul><pre class="highlight code nasm"><span class="nf">int3</span> <span class="c1">; NOTE: no space between int and 3</span></pre><p>Which translates to the following opcode:</p><pre class="highlight code objdump-nasm"><span class="x">0xcc</span></pre><div class="notes"><p>Tips for debugging assembly: keep an eye on registers, use breakpoints liberally!</p></div></div><div class="step step-level-1" step="32" data-rotate-x="90" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="29200" data-y="46000" data-z="0"><h1 id="debugging-with-gdb">Debugging With GDB</h1><p>Preconfiguration:</p><ul><li>.gdbinit provides a way to run a number of setup commands on launch</li><li>Simply copy the config file to your home directory:</li></ul><pre class="highlight code bash">~/Desktop/handouts $ cp sample-gdbinit ~/.gdbinit</pre><p>Launching a program with GDB:</p><pre class="highlight code bash">~/Desktop/Lab1 $ gdb lab1
<span class="o">(</span>gdb<span class="o">)</span> run
...
<span class="o">(</span>gdb<span class="o">)</span> quit</pre></div><div class="step step-level-1" step="33" data-rotate-x="90" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="31200" data-y="48000" data-z="0"><h1 id="gdb">GDB</h1><ul><li><dl><dt>Basic Use: Generally useful commands</dt><dd><ul><li>info - Displays information (in general, or about specific commands)</li><li>help - Can provide context-specific help; e.g., listing available commands/options</li></ul></dd></dl></li><li>refresh:  will redraw the console window</li></ul></div><div class="step step-level-1" step="34" data-rotate-x="90" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="33200" data-y="50000" data-z="0"><h1 id="id7">GDB</h1><ul><li><dl><dt>Single Stepping (step/s)</dt><dd><ul><li>Can also use stepi</li></ul></dd></dl></li><li><dl><dt>Stepping Over (next/n)</dt><dd><ul><li>Can also use nexti</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="35" data-rotate-x="90" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="35200" data-y="52000" data-z="0"><h1 id="id8">GDB</h1><ul><li><dl><dt>Breakpoints (break)</dt><dd><ul><li>Allows us to programmatically set breakpoints without modifying application source code</li></ul></dd></dl></li><li>info break - shows us information about all currently set breakpoints</li><li>Removing breakpoints (clear and delete)</li></ul><p>Example:</p><pre class="highlight code bash"><span class="o">(</span>gdb<span class="o">)</span> <span class="nb">break</span> myfunc
Breakpoint <span class="m">1</span> at 0x4004a4
<span class="o">(</span>gdb<span class="o">)</span> info <span class="nb">break</span>
Num     Type             Disp Enb Address
<span class="m">1</span>               breakpoint   keep y   0x00000000004004a4
<span class="o">(</span>gdb<span class="o">)</span> delete 1
<span class="o">(</span>gdb<span class="o">)</span> info <span class="nb">break</span>
No breakpoints or watchpoints</pre><div class="notes"><p>Demo stepping and using GDB with a sample init file and our opcodes demo</p></div></div><div class="step step-level-1" step="36" data-rotate-x="90" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="37200" data-y="54000" data-z="0"><h1 id="memory-access-instructions">Memory Access Instructions</h1><ul><li>We'll begin looking at instructions to copy and access data from various locations in memory</li><li>Additionally, we will begin examining address calculation</li></ul></div><div class="step step-level-1" step="37" data-rotate-x="90" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="39200" data-y="56000" data-z="0"><h1 id="memory-access-mov">Memory Access - mov</h1><h2 id="description">Description</h2><p>Moves a small block of memory from a source (the right-hand operand) to destination (the left operand). An amount of data may be specified (more on this later).</p><h2 id="basic-use">Basic Use</h2><pre class="highlight code nasm">    <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mh">0x01</span>      <span class="c1">; immediate - rax is now 1</span>
    <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rcx</span>       <span class="c1">; register - rax now has a copy of ecx</span>
    <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbx</span><span class="p">]</span>     <span class="c1">; memory - rbx is treated as a pointer</span>
<span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="kt">qword</span> <span class="p">[</span><span class="nb">rbx</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span> <span class="c1">; copying a quad word (8 bytes)</span></pre><div class="notes"><p>The mov instruction simply copies data from source (the operand on the right), to destination (the operand on the left).</p></div></div><div class="step step-level-1" step="38" data-rotate-x="90" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="41200" data-y="58000" data-z="0"><h1 id="memory-access-lea">Memory Access - lea</h1><h2 id="id9">Description</h2><p>Calculates an address, but does not actually attempt to access it.</p><h2 id="id10">Basic Use</h2><pre class="highlight code nasm"><span class="c1">; calculate an address by taking the address</span>
<span class="c1">; of what RDX points at,</span>
<span class="c1">; and adding 8 bytes to it (perhaps indexing</span>
<span class="c1">; into an array). Note that we are just calc-</span>
<span class="c1">; ulating the address, NOT accessing memory.</span>
    <span class="nf">lea</span> <span class="nb">rax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rdx</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
    <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rax</span><span class="p">]</span>     <span class="c1">; actually accessing the memory</span></pre></div><div class="step step-level-1" step="39" data-y="60000" data-rotate-x="90" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="43200" data-z="0"><h1 id="memory-access-xchg">Memory Access - xchg</h1><h2 id="id11">Description</h2><p>Exchanges the values provided atomically (more on this later).</p><h2 id="id12">Basic Use</h2><pre class="highlight code nasm"><span class="nf">xchg</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rcx</span>   <span class="c1">; exchange two register values</span>
<span class="c1">; exchange a register value with a value stored in memory</span>
<span class="nf">xchg</span> <span class="nb">rax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rcx</span><span class="p">]</span></pre></div><div class="step step-level-1" step="40" data-rotate-y="180" data-rotate-x="90" data-rotate-z="90" data-scale="1" data-x="45200" data-y="62000" data-z="0"><h1 id="lab-1">Lab 1</h1><p>Memory Access</p><ul><li>Copy the Lab1 folder (and its contents)</li><li>Modify the *.nasm file (Each function should have a comment block - lines starting with ';' containing instructions)</li><li>Build and run using the following commands:</li></ul><pre class="highlight code bash">~/Desktop/Lab1 $ cmake . <span class="o">&amp;&amp;</span> cmake --build .
~/Desktop/Lab1 $ ./lab1</pre></div><div class="step step-level-1" step="41" data-rotate-x="90" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="47200" data-y="64000" data-z="0"><h1 id="assembly-and-data-types">Assembly and Data Types</h1><ul><li><dl><dt>Slightly different concept than in higher level languages</dt><dd><ul><li>Typically just bytes in a buffer</li><li>Data 'type' is really just interpretation</li><li>Generally differentiated by sizes, alignment, and certain bits being set</li></ul></dd></dl></li><li>Some operations will preserve special properties in a given data set (such as sign, e.g., +/-)</li><li>Other operations may expect different alignments in the data they work on, or may have issues with certain values (such as floating point)</li></ul></div><div class="step step-level-1" step="42" data-rotate-x="90" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="49200" data-y="66000" data-z="0"><h1 id="x86-64-general-data-sizes">x86(_64) general data sizes</h1><ul><li>byte - "smallest" addressable unit</li><li>word - two bytes</li><li>dword - double word (4 bytes - pointer width on x86)</li><li>qword - quad word (8 bytes - pointer width on x64)</li></ul></div><div class="step step-level-1" step="43" data-rotate-x="90" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="51200" data-y="68000" data-z="0"><h1 id="gdb-examining-memory">GDB: Examining Memory</h1><ul><li>We can use GDB to examing various places in memory with "x" (for "eXamine")</li><li><dl><dt>x has several options:</dt><dd><ul><li>x/nfu - where n is the Number of things to examine, f is the Format, and u is the Unit size</li><li>x addr</li><li>x $&lt;register&gt; - examines the memory address pointed to by the register</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="44" data-rotate-x="90" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="53200" data-y="70000" data-z="0"><h1 id="gdb-formatting">GDB Formatting</h1><ul><li>The "f" in x/nfu</li><li><dl><dt>Format options include:</dt><dd><ul><li>s - For a NULL-terminated string</li><li>i - For a machine instruction</li><li>x - For hexidecimal (the default, which changes when x is used)</li></ul></dd></dl></li><li>Example: Disassembling at RIP</li></ul><pre class="highlight code bash"><span class="o">(</span>gdb<span class="o">)</span> x/i <span class="nv">$rip</span></pre></div><div class="step step-level-1" step="45" data-rotate-x="90" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="55200" data-y="72000" data-z="0"><h1 id="gdb-unit-sizes">GDB Unit Sizes</h1><ul><li>The "u" in x/nfu</li><li><dl><dt>Unit size options are a bit confusing in the context of x86(_64) assembly, and include:</dt><dd><ul><li>b - bytes</li><li>h - Halfwords (equivalent to "word" in x86(_64) asm; e.g., 2 bytes)</li><li>w - Words (4 bytes, equivalent to dwords)</li><li>g - Giant words (8 bytes, equivalent to qwords)</li></ul></dd></dl></li></ul><div class="notes"><p>Demo - Dumping memory via GDB</p></div></div><div class="step step-level-1" step="46" data-rotate-x="90" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="57200" data-y="74000" data-z="0"><h1 id="sub-registers">Sub Registers</h1><img src="images/section_1_register_table.jpg"></img><ul><li>Subregisters are still part of the bigger "parent" register</li><li>Unless special instructions (not yet mentioned) are used, will NOT modify data in the other portions of the register.</li></ul></div><div class="step step-level-1" step="47" data-rotate-x="90" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="59200" data-y="76000" data-z="0"><h1 id="memory-register-access-mov">Memory/Register Access - mov</h1><ul><li>When accessing memory, amount of data to copy can be specified</li></ul><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="kt">byte</span> <span class="p">[</span><span class="nb">rsi</span><span class="p">]</span> <span class="c1">; copy a single byte</span>
<span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="kt">dword</span> <span class="p">[</span><span class="nb">rcx</span><span class="p">]</span> <span class="c1">; copy a dword (4 bytes)</span>
<span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="kt">qword</span> <span class="p">[</span><span class="nb">rsi</span><span class="p">]</span> <span class="c1">; copy a qword (8 bytes)</span></pre><ul><li>Also, data can be copied from subregister to subregister</li></ul><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="nb">cl</span>  <span class="c1">; copy from cl to al</span>
<span class="nf">xchg</span> <span class="nb">al</span><span class="p">,</span> <span class="nb">ah</span> <span class="c1">; exchange the low and high bytes in ax</span></pre></div><div class="step step-level-1" step="48" data-rotate-x="90" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="61200" data-y="78000" data-z="0"><h1 id="register-access-movzx">Register Access - movzx</h1><h2 id="id13">Description</h2><p>Move with zero extend. When moving data that is smaller than the destination size,
zero out the remaining bits.</p><h2 id="id14">Basic Use</h2><pre class="highlight code nasm"><span class="nf">movzx</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">cl</span> <span class="c1">; everything above al is now set to 0</span>
<span class="nf">movzx</span> <span class="nb">rax</span><span class="p">,</span> <span class="kt">byte</span> <span class="p">[</span><span class="nb">rsi</span> <span class="o">+</span> <span class="mi">5</span><span class="p">]</span></pre></div><div class="step step-level-1" step="49" data-rotate-x="90" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="63200" data-y="80000" data-z="0"><h1 id="lab-2">Lab 2</h1><p>Using subregisters, accessing smaller values, and zero extending.</p><ul><li>Copy the Lab2 folder (and its contents)</li><li>Modify the *.nasm file (Each function should have a comment block - lines starting with ';' containing instructions)</li><li>Build and run using the following commands:</li></ul><pre class="highlight code bash">~/Desktop/Lab2 $ cmake . <span class="o">&amp;&amp;</span> cmake --build .
~/Desktop/Lab2 $ ./lab2</pre></div><div class="step step-level-1" step="50" data-rotate-x="90" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="65200" data-y="82000" data-z="0"><h1 id="structures">Structures</h1><ul><li>NASM provides a data structure concept for convenience in handling complex data types</li><li>More of a macro than something truly representative of C-style structs</li><li>Very useful for keeping track of local variables or parameters (among other things)</li></ul></div><div class="step step-level-1" step="51" data-rotate-x="90" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="67200" data-y="84000" data-z="0"><h1 id="id15">Structures</h1><pre class="highlight code nasm"><span class="k">struc</span> <span class="nv">MyStruct</span>
        <span class="nf">.field1</span>         <span class="nv">resd</span> <span class="mi">1</span>  <span class="c1">; field1's size is 1 dword</span>
        <span class="nf">.field2</span>         <span class="nv">resd</span> <span class="mi">1</span>  <span class="c1">; field2's size is 1 dword</span>
        <span class="nf">.field3</span>         <span class="nv">resq</span> <span class="mi">1</span>  <span class="c1">; field3's size is 1 qword</span>
<span class="k">endstruc</span>

<span class="c1">; ...</span>
<span class="c1">; This will be equivalent to: mov rax, [rdi+8]</span>
<span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rdi</span> <span class="o">+</span> <span class="nv">MyStruct.field3</span><span class="p">]</span></pre></div><div class="step step-level-1" step="52" data-rotate-x="90" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="69200" data-y="86000" data-z="0"><h1 id="section-review">Section Review</h1><ul><li>Byte Ordering</li><li>Process Layout</li><li><dl><dt>Registers</dt><dd><ul><li>Stack Pointer</li><li>Base Pointer</li><li>Instruction Pointer</li></ul></dd></dl></li><li>Dereferencing Pointers via Register</li><li>Sub registers</li></ul></div></div><div id="hovercraft-help"><table><tr><th>Space</th><td>Forward</td></tr><tr><th>Right, Down, Page Down</th><td>Next slide</td></tr><tr><th>Left, Up, Page Up</th><td>Previous slide</td></tr><tr><th>P</th><td>Open presenter console</td></tr><tr><th>H</th><td>Toggle this help</td></tr></table></div><script type="text/javascript" src="js/impress.js"></script><script type="text/javascript" src="js/impressConsole.js"></script><script type="text/javascript" src="js/hovercraft.js"></script></body></html><!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Introduction to Assembly</title><meta name="generator" content="Hovercraft! 1.0 http://regebro.github.com/hovercraft"></meta><link rel="stylesheet" href="css/hovercraft.css" media="all"></link><link rel="stylesheet" href="css/impressConsole.css" media="all"></link><link rel="stylesheet" href="css/highlight.css" media="all"></link><link rel="stylesheet" href="asm.css" media="screen,projection"></link></head><body class="impress-not-supported"><div id="impress" data-transition-duration="1500"><div class="step step-level-1" step="0" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><h1 id="basic-operations">Basic Operations</h1></div><div class="step step-level-1" step="1" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="1600" data-y="0" data-z="0"><h1 id="objectives">Objectives</h1><ul><li>Utilize basic arithmetic and bit operations</li><li>Understand the difference between signed and unsigned values, from an assembly perspective</li><li>Understand the Two's Complement representation of signed numbers</li><li>Understand the Stack as it pertains to assembly programming, and implement functions that utilize it to load and store data</li></ul></div><div class="step step-level-1" step="2" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="3200" data-y="0" data-z="0"><h1 id="arithmetic-operations">Arithmetic Operations</h1><p>Basic Math Operations</p></div><div class="step step-level-1" step="3" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="4800" data-y="0" data-z="0"><h1 id="the-add-and-sub-instructions">The add and sub instructions</h1><h2 id="description">Description</h2><p>Adds and subtracts arbitrary values. The destination (where the result is stored) is the first value provided.</p><h2 id="basic-use">Basic Use</h2><p>We can use a combination of registers and immediates as operands:</p><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">1</span>
<span class="nf">add</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">2</span> <span class="c1">; rax now contains 3</span>
<span class="nf">sub</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">1</span> <span class="c1">; rax now contains 2</span>
<span class="nf">mov</span> <span class="nb">rcx</span><span class="p">,</span> <span class="mi">2</span>
<span class="nf">add</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rcx</span> <span class="c1">; as above, rax now contains 4</span>
<span class="nf">sub</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rcx</span> <span class="c1">; rax is now back to 2</span></pre></div><div class="step step-level-1" step="4" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="6400" data-y="0" data-z="0"><h1 id="the-mul-instruction">The mul instruction</h1><h2 id="id1">Description</h2><p>Allow multiplication of arbitrary values. Takes a single argument, multiplies by rax/eax/ax (depending on operand size).</p><h2 id="id2">Basic Use</h2><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="mi">10</span>
<span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="mi">10</span>
<span class="nf">mul</span> <span class="nb">ecx</span>         <span class="c1">; rax now contains 100</span>

<span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">5</span>
<span class="nf">mov</span> <span class="nb">rcx</span><span class="p">,</span> <span class="mi">7</span>
<span class="nf">mul</span> <span class="nb">rcx</span>     <span class="c1">; rax now contains 35</span></pre><div class="notes"><p>Results are mostly stored in the source operand (ax/eax/rax), but may be stored in dx/edx/rdx as well if overflow occurs. The table on the next slide illustrates this.</p></div></div><div class="step step-level-1" step="5" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="8000" data-y="0" data-z="0"><h1 id="the-mul-instruction-storing-results">The mul instruction: storing results</h1><p>Results are stored in the source (possible), or in a combination of registers in the configuration below:</p><img src="images/section_2_mul_table.jpg"></img></div><div class="step step-level-1" step="6" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="9600" data-y="0" data-z="0"><h1 id="the-div-instruction">The div instruction</h1><h2 id="id3">Description</h2><p>As with mul, div takes a single argument, and divides the value stored in the dividend register(s) by it. This is typically ax/eax/rax (and the *dx equivalents), but may vary a bit depending on the size (chart provided on the next slide).</p><h2 id="id4">Basic Use</h2><pre class="highlight code nasm"><span class="c1">; clearing the register where the</span>
<span class="c1">; high bits would be stored, we're only using what's in rax!</span>
<span class="nf">mov</span> <span class="nb">rdx</span><span class="p">,</span> <span class="mi">0</span>
<span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">10</span>
<span class="nf">mov</span> <span class="nb">rcx</span><span class="p">,</span> <span class="mi">2</span>
<span class="nf">div</span> <span class="nb">rcx</span>    <span class="c1">; rax now contains 5 this is rax/rcx</span></pre></div><div class="step step-level-1" step="7" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="11200" data-y="0" data-z="0"><h1 id="div-operation-results">div: operation results</h1><p>Where to retrieve the results of a div from depends on the size of the arguments. The table below illustrates this relationship:</p><img src="images/section_2_div_table.jpg"></img></div><div class="step step-level-1" step="8" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="12800" data-y="0" data-z="0"><h1 id="inc-and-dec">inc and dec</h1><h2 id="id5">Description</h2><p>Adds or subtracts one from the provided register, storing the result in place.</p><h2 id="id6">Basic Use</h2><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">1</span>      <span class="c1">; rax now contains 1</span>
<span class="nf">inc</span> <span class="nb">rax</span>         <span class="c1">; rax now contains 2</span>
<span class="nf">inc</span> <span class="nb">rax</span>         <span class="c1">; rax now contains 3</span>
<span class="nf">dec</span> <span class="nb">rax</span>         <span class="c1">; rax now contains 2</span></pre></div><div class="step step-level-1" step="9" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="14400" data-y="0" data-z="0"><h1 id="lab-3">Lab 3</h1><p>Arithmetic Operations</p><ul><li>Copy the Lab3 folder (and its contents)</li><li>Modify the *.nasm file (Each function should have a comment block - lines starting with ';' containing instructions)</li><li>Build and run using the following commands:</li></ul><pre class="highlight code bash">~/Desktop/Lab3 $ cmake . <span class="o">&amp;&amp;</span> cmake --build .
~/Desktop/Lab3 $ ./lab3</pre></div><div class="step step-level-1" step="10" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="16000" data-y="0" data-z="0"><h1 id="the-stack">The Stack</h1><ul><li>Grows from high memory to low memory</li><li>Current function typically exists within a stack "frame" (but not always!)</li></ul></div><div class="step step-level-1" step="11" data-x="16000" data-y="2000" data-rotate-y="0" data-rotate-x="0" data-rotate-z="90" data-scale="1" data-z="0"><h1 id="stack-frames">Stack Frames</h1><ul><li>RSP (or ESP) points to the top of the stack</li><li>RBP (or EBP) points to the "base" of the stack frame</li></ul></div><div class="step step-level-1" step="12" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="16000" data-y="4000" data-z="0"><h1 id="stack-frame-layout">Stack Frame Layout</h1><img src="images/section_2_stack_diagram_1.jpg"></img></div><div class="step step-level-1" step="13" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="16000" data-y="6000" data-z="0"><h1 id="expanding-the-stack-frame">Expanding the Stack Frame</h1><ul><li>Can modify the value of RSP directly to allocate more stack space:</li></ul><pre class="highlight code nasm"><span class="nf">sub</span> <span class="nb">rsp</span><span class="p">,</span> <span class="mi">16</span></pre><ul><li>But you must always ensure you clean up before the function returns:</li></ul><pre class="highlight code nasm"><span class="nf">add</span> <span class="nb">rsp</span><span class="p">,</span> <span class="mi">16</span></pre></div><div class="step step-level-1" step="14" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="16000" data-y="8000" data-z="0"><h1 id="stack-alignment">Stack Alignment</h1><ul><li>x86_64 expects 16 byte stack alignment</li><li>Allocating odd amounts of space can cause things to break</li><li>ALWAYS make sure you clean up your stack before returning</li></ul></div><div class="step step-level-1" step="15" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="16000" data-y="10000" data-z="0"><h1 id="gdb-stack-frames">GDB - Stack Frames</h1><ul><li>Examining the Call Stack (backtrace / bt)</li><li><dl><dt>Frames and information</dt><dd><ul><li>frame || f - Get information about the current frame</li><li>info args - Get information about function arguments</li><li>info locals - Information about local variables</li></ul></dd></dl></li></ul><div class="notes"><p>May be appropriate to demo GDB and stack frames</p></div></div><div class="step step-level-1" step="16" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="16000" data-y="12000" data-z="0"><h1 id="new-instructions-push-and-pop">New Instructions: push and pop</h1><h2 id="id7">Description</h2><p>Push will subtract a pointer-width amount of space from RSP, and place the argument in the newly-allocated location.
Pop performs the opposite action, storing the value just below RSP in the register provided, and adding a pointer-width amount to RSP.
For every push, you will need to pop!</p><h2 id="id8">Basic Use</h2><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">1</span>      <span class="c1">; 1 is now stored in rax.</span>
<span class="nf">push</span> <span class="nb">rax</span>        <span class="c1">; 1 is now stored at the top of the stack</span>
<span class="nf">pop</span> <span class="nb">rcx</span>         <span class="c1">; rcx now contains 1</span></pre></div><div class="step step-level-1" step="17" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="16000" data-y="14000" data-z="0"><h1 id="growing-the-stack">Growing the Stack</h1><p>After a push operation:</p><img src="images/section_2_stack_diagram_2.jpg"></img></div><div class="step step-level-1" step="18" data-x="16000" data-y="14000" data-rotate-y="90" data-rotate-x="0" data-rotate-z="90" data-scale="1" data-z="0"><h1 id="restoring-the-stack">Restoring the Stack</h1><p>After a pop operation:</p><img src="images/section_2_stack_diagram_3.jpg"></img></div><div class="step step-level-1" step="19" data-y="16000" data-rotate-x="0" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="16000" data-z="0"><h1 id="lab-4">Lab 4</h1><p>Stack Operations</p><ul><li>Copy the Lab4 folder (and its contents)</li><li>Modify the *.nasm file (Each function should have a comment block - lines starting with ';' containing instructions)</li><li>Build and run using the following commands:</li></ul><pre class="highlight code bash">~/Desktop/Lab4 $ cmake . <span class="o">&amp;&amp;</span> cmake --build .
~/Desktop/Lab4 $ ./lab4</pre></div><div class="step step-level-1" step="20" data-rotate-y="0" data-y="16100" data-x="15000" data-rotate-x="0" data-rotate-z="90" data-scale="1" data-z="0"><h1 id="negative-numbers">Negative Numbers</h1><h2 id="two-s-complement">Two's Complement</h2><img src="images/section_2_counter.jpeg"></img><ul><li>Negative numbers on the x86(_64) platform are represented via Two's Complement</li></ul><div class="notes"><p>On understanding Two's Complement: think of what happens when a mechanical counter (like the one pictured on the slide) counts down to zero,
and rolls over. You might see it flip all the numbers over: e.g., 9999</p></div></div><div class="step step-level-1" step="21" data-y="18600" data-z="0" data-x="15000" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1"><h1 id="id9">Two's Complement</h1><ul><li>Invert the bits of the number (in binary), and add one!</li></ul><img src="images/section_2_twos_complement_p1.jpg"></img></div><div class="step step-level-1" step="22" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="15000" data-y="21100" data-z="0"><h1 id="two-s-complement-cont-d">Two's Complement (cont'd)</h1><ul><li>Simplifies addition operations</li><li>Unified Add/Sub</li></ul><p>Example: Adding 2 and -1</p><pre class="highlight code">Carry Row:  11
            1111
          + 0010
            ----
            0001</pre></div><div class="step step-level-1" step="23" data-x="17000" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-y="23600" data-z="0"><h1 id="sub-registers-and-sign-extending">Sub Registers and Sign extending</h1><ul><li>When copying smaller data into a register, sign extending may be used (rather than zero extending)</li><li>Sign extending preserves the "signed" attributes of the data being copied.</li><li>The movsx instruction (just like movzx) handles this.</li></ul></div><div class="step step-level-1" step="24" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="19000" data-y="26100" data-z="0"><h1 id="the-movsx-instruction">The movsx Instruction</h1><h2 id="id10">Description</h2><p>Much like movzx, movsx can be used to move data into a portion of a larger register, while preserving its sign.</p><h2 id="id11">Basic Use</h2><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">cl</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
<span class="nf">movsx</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">cl</span>   <span class="c1">; rax now contains -1.</span></pre></div><div class="step step-level-1" step="25" data-y="0" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="21000" data-z="0"><h1 id="bitwise-operations">Bitwise Operations</h1></div><div class="step step-level-1" step="26" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="23000" data-y="0" data-z="0"><h1 id="bit-shifting">Bit shifting</h1><ul><li>Two unsigned shift operations exist: shl (shift left) and shr (shift right)</li><li>Shifting moves the bits in the register over the direction (left or right) and number of bits specified</li><li>Bits that fall off the end (and overflow) will disappear, except for the last one, which ends up in the
carry flag (which we'll discuss later)</li><li>The extra space created gets padded with 0's</li></ul></div><div class="step step-level-1" step="27" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="25000" data-y="0" data-z="0"><h1 id="left-shift-diagram">Left Shift Diagram</h1><p>The following snippet of assembly:</p><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">1</span>
<span class="nf">shl</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">1</span>
<span class="nf">shl</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">3</span></pre><p>Can be modelled by the following table:</p><img src="images/section_2_bitops_shl_1.jpg"></img></div><div class="step step-level-1" step="28" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="27000" data-y="0" data-z="0"><h1 id="right-shift-diagram">Right Shift Diagram</h1><p>Similarly, the following snippet of assembly:</p><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">32</span>
<span class="nf">shr</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">1</span>
<span class="nf">shr</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">4</span></pre><p>Can be modelled by the following table:</p><img src="images/section_2_bitops_shr_1.jpg"></img></div><div class="step step-level-1" step="29" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="29000" data-y="0" data-z="0"><h1 id="binary-and-or">Binary and/or</h1><ul><li>and can be used to determine whether or not one or more bits are set in</li><li>or will tell you if the bit is set in at least one place</li><li>Both take two operands, one of which will hold the result after the operation completes</li></ul><h2 id="use">Use:</h2><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">1</span>              <span class="c1">; rax contains 00000001</span>
<span class="nf">mov</span> <span class="nb">rcx</span><span class="p">,</span> <span class="mi">5</span>              <span class="c1">; rcx contains 00000101</span>

<span class="nf">and</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rcx</span>    <span class="c1">; rax contains 00000001</span>
<span class="nf">or</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rcx</span>             <span class="c1">; rax contains 00000101</span></pre><div class="notes"><p>Another way to think about this (if familiar with sets and set theory): AND gives us the intersection between the two sets of bits, OR gives us their union.</p></div></div><div class="step step-level-1" step="30" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="31000" data-y="0" data-z="0"><h1 id="and-table">And Table</h1><img src="images/section_2_bitops_and.jpg"></img></div><div class="step step-level-1" step="31" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="33000" data-y="0" data-z="0"><h1 id="or-table">Or Table</h1><img src="images/section_2_bitops_or.jpg"></img></div><div class="step step-level-1" step="32" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="35000" data-y="0" data-z="0"><h1 id="binary-not">Binary not</h1><ul><li>Inverts the bits in a given register</li></ul><p>Example:</p><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">0</span>      <span class="c1">; rax now contains 00000000</span>
<span class="nf">not</span> <span class="nb">rax</span>         <span class="c1">; rax is now all 1's (or 0xffffffff)</span></pre><p>Similarly:</p><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">rcx</span><span class="p">,</span> <span class="mi">1</span>      <span class="c1">; rcx now contains 1</span>
<span class="nf">not</span> <span class="nb">rcx</span>         <span class="c1">; rcx now contains:</span>
                <span class="c1">; 0xfffffffe (all 1's minus the first bit)</span></pre></div><div class="step step-level-1" step="33" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="37000" data-y="0" data-z="0"><h1 id="properties-of-exclusive-or">Properties of eXclusive Or</h1><ul><li>XOR yields 1 only if the bit is set in either the source or destination, but NOT both</li><li>Any value XOR'd with itself is 0.</li><li>0 XOR'd with any value is that value</li><li>For numbers A, B, and C, if A ^ B = C, then C ^ A = B
and C ^ B = A.</li></ul></div><div class="step step-level-1" step="34" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="39000" data-y="0" data-z="0"><h1 id="xor-table">XOR table</h1><img src="images/section_2_bitops_xor.jpg"></img></div><div class="step step-level-1" step="35" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="41000" data-y="0" data-z="0"><h1 id="rotating-bits">Rotating Bits</h1><ul><li>The values in the register are rotated the indicated number of places to the right or left</li><li>Bits that are rotated off the end of the register and moved back to the beginning</li></ul><p>Instruction:</p><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">1</span>      <span class="c1">; rax contains 1 (00000001)</span>
<span class="nf">rol</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">1</span>  <span class="c1">; rax now contains 2 (00000010)</span>
<span class="nf">ror</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">1</span>      <span class="c1">; rax now contains 1 (00000001)</span>
<span class="nf">ror</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">1</span>      <span class="c1">; rax now looks like: (10000000)</span></pre></div><div class="step step-level-1" step="36" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="43000" data-y="0" data-z="0"><h1 id="signed-bit-operations">Signed Bit Operations</h1><ul><li>Shift operations that are sign aware exist (SAR for right and SAL for left)</li><li>Work in the same fashion as shr/shl, except for how bits shifted off the end are treated (bits still disappear, but the sign of the resulting value is retained)</li></ul></div><div class="step step-level-1" step="37" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="45000" data-y="0" data-z="0"><h1 id="lab-5">Lab 5</h1><p>Bit operations</p><ul><li>Copy the Lab5 folder (and its contents)</li><li>Modify the *.nasm file (Each function should have a comment block - lines starting with ';' containing instructions)</li><li>Build and run using the following commands:</li></ul><pre class="highlight code bash">~/Desktop/Lab5 $ cmake . <span class="o">&amp;&amp;</span> cmake --build .
~/Desktop/Lab5 $ ./lab5</pre></div><div class="step step-level-1" step="38" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="47000" data-y="0" data-z="0"><h1 id="section-review">Section Review</h1><ul><li>Arithmetic Operations</li><li><dl><dt>The Stack</dt><dd><ul><li>Stack Frames</li><li>Stack Alignment</li></ul></dd></dl></li><li>Signed Values and Two's Complement</li><li>Bit Operations</li></ul></div></div><div id="hovercraft-help"><table><tr><th>Space</th><td>Forward</td></tr><tr><th>Right, Down, Page Down</th><td>Next slide</td></tr><tr><th>Left, Up, Page Up</th><td>Previous slide</td></tr><tr><th>P</th><td>Open presenter console</td></tr><tr><th>H</th><td>Toggle this help</td></tr></table></div><script type="text/javascript" src="js/impress.js"></script><script type="text/javascript" src="js/impressConsole.js"></script><script type="text/javascript" src="js/hovercraft.js"></script></body></html>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Introduction to Assembly</title><meta name="generator" content="Hovercraft! 1.0 http://regebro.github.com/hovercraft"></meta><link rel="stylesheet" href="css/hovercraft.css" media="all"></link><link rel="stylesheet" href="css/impressConsole.css" media="all"></link><link rel="stylesheet" href="css/highlight.css" media="all"></link><link rel="stylesheet" href="asm.css" media="screen,projection"></link></head><body class="impress-not-supported"><div id="impress" data-transition-duration="1500"><div class="step step-level-1" step="0" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><h1 id="control-flow">Control Flow</h1></div><div class="step step-level-1" step="1" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="1600" data-y="0" data-z="0"><h1 id="objectives">Objectives</h1><ul><li>Understand and utilize status flags and conditional control flow</li><li>Understand and utilize x86(_64) string instructions and corresponding instruction prefixes</li><li>Understand and implement methods utilizing a variety of calling conventions (both x86 and x86_64)</li></ul></div><div class="step step-level-1 split-table" step="2" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="3200" data-y="0" data-z="0"><h1 id="flags">FLAGS</h1><ul><li>A register that contains a variety of bits representing state and status information</li><li>Varies in size, but many portions (in newer processors) aren't used</li></ul><table cellpadding="0" cellspacing="0"><tbody><tr><td><p>FLAGS</p></td><td><p>16 bits</p></td></tr><tr><td><p>EFLAGS</p></td><td><p>32 bits</p></td></tr><tr><td><p>RFLAGS</p></td><td><p>64 bits</p></td></tr></tbody></table></div><div class="step step-level-1" step="3" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="4800" data-y="0" data-z="0"><h1 id="flag-layout">Flag Layout</h1><img src="images/eflags-intel2.jpg"></img><p>Credit: the Intel Manual</p></div><div class="step step-level-1" step="4" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="6400" data-y="0" data-z="0"><h1 id="flags-we-care-about-now">Flags we care about now</h1><ul><li>Zero Flag (ZF) - set when an operation that sets the zero flag produces a zero - includes arithmetic and bitshift operations</li><li><dl><dt>Carry Flag (CF) - set when an arithmetic borrow or carry occurs during add/sub - e.g., the result of an add would have set bit 33 (in x86), or bit 65 (in x86_64)</dt><dd><ul><li>also set with some bitshift operations (such as when a bit falls off the end in a shl/shr)</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="5" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="8000" data-y="0" data-z="0"><h1 id="flags-we-care-about-now-cont-d">Flags we care about now (cont'd)</h1><ul><li><dl><dt>Overflow Flag (OF) - Indicates that sign bit of the result of an operation is different than the sign bits of the operands</dt><dd><ul><li>Ex.: Adding two large position numbers ends up producing a negative result (due to overflow)</li></ul></dd></dl></li><li>Sign Flag (SF) - Set to indicate the result of an operation is negative</li></ul></div><div class="step step-level-1" step="6" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="9600" data-y="0" data-z="0"><h1 id="accessing-the-flags">Accessing the Flags</h1><ul><li><dl><dt>Can be set and checked manually</dt><dd><ul><li>Some have special instructions for set and clear (which we'll talk about later)</li><li>Flag register can be accessed and set via pushf(d|q)/popf(d|q)</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="7" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="11200" data-y="0" data-z="0"><h1 id="pushf-and-popf">pushf and popf</h1><h2 id="description">Description</h2><p>Pushes the flags register (or the first 16 bits... eflags (32 bits) or rflags (64 bits) if pushfd or pushfq) onto the stack, and pops the value on top of the stack into the flags register (or eflags/rflags)</p><h2 id="basic-use">Basic Use</h2><pre class="highlight code nasm"><span class="nf">pushf</span>   <span class="c1">; flags have been pushed to the stack</span>
<span class="c1">; ... do stuff</span>
<span class="nf">popf</span>    <span class="c1">; flags have been restored!</span></pre></div><div class="step step-level-1" step="8" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="12800" data-y="0" data-z="0"><h1 id="lab-6">Lab 6</h1><p>Flag manipulation...</p><ul><li>Copy the Lab6 folder (and its contents)</li><li>Modify the *.nasm file (Each function should have a comment block - lines starting with ';' containing instructions)</li><li>Build and run using the following commands:</li></ul><pre class="highlight code bash">~/Desktop/Lab6 $ cmake . <span class="o">&amp;&amp;</span> cmake --build .
~/Desktop/Lab6 $ ./lab6</pre></div><div class="step step-level-1" step="9" data-x="15300" data-y="0" data-rotate-z="90" data-rotate-x="0" data-rotate-y="0" data-scale="1" data-z="0"><h1 id="id1">Control Flow</h1></div><div class="step step-level-1" step="10" data-x="15300" data-y="2000" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-z="0"><h1 id="line-labels">Line Labels</h1><ul><li>Global and local</li></ul><pre class="highlight code nasm"><span class="nl">global_label:</span>
        <span class="c1">; stuff</span>

<span class="nl">.local_label:</span>
        <span class="c1">; more stuff</span></pre></div><div class="step step-level-1" step="11" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="15300" data-y="4000" data-z="0"><h1 id="everybody-jmp-around">Everybody jmp .around</h1><ul><li>jmp provides an unconditional branch, or transfer of execution to the target</li></ul><pre class="highlight code nasm"><span class="nl">.label1:</span>
    <span class="nf">xor</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rax</span>
    <span class="nf">inc</span> <span class="nb">rax</span>
    <span class="nf">mov</span> <span class="nb">rcx</span><span class="p">,</span> <span class="nb">rax</span>
    <span class="nf">jmp</span> <span class="nv">.label2</span>
    <span class="nf">mov</span> <span class="nb">rsp</span><span class="p">,</span> <span class="nb">rax</span>   <span class="c1">; never gets executed</span>
<span class="nl">.label2:</span>
    <span class="nf">shl</span> <span class="nb">rcx</span><span class="p">,</span> <span class="mi">3</span>  <span class="c1">; execution continues here...</span>
    <span class="nf">xchg</span> <span class="nb">rcx</span><span class="p">,</span> <span class="nb">rax</span>
    <span class="nf">ret</span></pre></div><div class="step step-level-1" step="12" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="15300" data-y="6000" data-z="0"><h1 id="call-and-ret">call and ret</h1><ul><li>Similar to jmp, but with a few key differences</li><li>Functionally equivalent to: push rip followed by a jmp X</li><li>Typically indicates a function call</li></ul><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">1</span>
<span class="nf">call</span> <span class="nv">label1</span> <span class="c1">; push RIP, jump to label1</span>
<span class="nf">jmp</span> <span class="nv">label2</span>
<span class="nl">label1:</span>
    <span class="nf">ror</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">1</span>
    <span class="nf">ret</span>     <span class="c1">; returns control returns to "jmp label2"</span>
<span class="nl">label2:</span>
    <span class="c1">; ...</span></pre></div><div class="step step-level-1" step="13" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="15300" data-y="8000" data-z="0"><h1 id="more-on-ret">More on ret</h1><ul><li>Pops the return pointer off the stack and jumps to it</li><li>Used to return to the last point of execution (as shown on the previous slide)</li></ul><p>The stack, during function execution:</p><img src="images/section_3_call_ret_pt1.jpg"></img></div><div class="step step-level-1" step="14" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="15300" data-y="10000" data-z="0"><p>Once we get to the end, and we're ready to return:</p><pre class="highlight code nasm"><span class="c1">; ...</span>
<span class="nf">pop</span> <span class="nb">rbp</span>
<span class="nf">ret</span></pre><p>Our stack frame does something like this:</p><img src="images/section_3_call_ret_pt2.jpg"></img><p>popping off the old RBP, then popping the return pointer, and jumping to it (effectively "pop rip")</p></div><div class="step step-level-1" step="15" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="15300" data-y="12000" data-z="0"><h1 id="a-side-note-about-functions">A Side Note About Functions</h1><ul><li>Typically store the stack pointer ((E|R)SP) at the top of the function</li><li><dl><dt>If stored, must be (re)stored before returning</dt><dd><ul><li>If we don't, our stack location will be off</li><li>If left at the top of the stack, we will return ONTO the stack!</li></ul></dd></dl></li><li>This is not always done, as in FPO (Frame Pointer Optimization/Omission)</li><li>Functions will be covered in more depth later</li></ul><pre class="highlight code nasm"><span class="nl">myfunc:</span>
    <span class="nf">mov</span> <span class="nb">rbp</span><span class="p">,</span> <span class="nb">rsp</span>
    <span class="nf">push</span> <span class="nb">rbp</span>
    <span class="c1">; ...</span>
    <span class="nf">pop</span> <span class="nb">rbp</span>
    <span class="nf">ret</span></pre></div><div class="step step-level-1" step="16" data-x="15300" data-y="13000" data-rotate-z="180" data-rotate-x="0" data-rotate-y="0" data-scale="1" data-z="0"><h1 id="conditional-control-flow-comparisons">Conditional Control Flow: Comparisons</h1></div><div class="step step-level-1" step="17" data-x="12800" data-y="13000" data-z="0" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1"><h1 id="cmp">cmp</h1><ul><li>Compares two values by subtraction (e.g., SUB op1, op2)</li><li>Sets flags to indicate whether the values were equal, or if one was larger</li><li>Flags set by this instruction: CF, OF, SF, ZF, AF, and PF</li></ul><p>Example:</p><pre class="highlight code nasm"><span class="nf">xor</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rax</span>
<span class="nf">cmp</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">0</span>  <span class="c1">; they're equal! the ZF is now set</span></pre></div><div class="step step-level-1" step="18" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="10300" data-y="13000" data-z="0"><h1 id="test">test</h1><ul><li>Compares two values by doing a bitwise AND</li><li>The SF, PF, and ZF get set by this operation</li><li>Often used to test whether or not a register is 0</li></ul><p>Example:</p><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">1</span>
<span class="nf">test</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rax</span> <span class="c1">; the ZF is set to 0, as the result isn't 0</span>

<span class="c1">; ...</span>

<span class="nf">xor</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rax</span>
<span class="nf">test</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rax</span> <span class="c1">; the ZF is now 1</span></pre></div><div class="step step-level-1" step="19" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="7800" data-y="13000" data-z="0"><h1 id="jcc">Jcc</h1><ul><li>A large set of conditional branch instructions</li><li>Most execute based on the value of one or more flags</li><li><dl><dt>Some common conditional jumps:</dt><dd><ul><li>je or jz - Jump if Equal (or Jump if Zero)</li><li>jne/jnz - Jump if Not Equal (or Not Zero)</li><li>ja - Jump if Above (if the operand compared previously is greater)</li><li>jb/jc - Jump if Below (or Jump if Carry)</li></ul></dd></dl></li><li>Many others - Refer to the intel manual for a comprehensive list</li></ul><div class="notes"><p>A large number of the Jcc instructions actually evaluate to the same thing (e.g., JE vs JZ)</p></div></div><div class="step step-level-1" step="20" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="5300" data-y="13000" data-z="0"><h1 id="jcc-cont-d">Jcc Cont'd</h1><p>A simple check to see if the result of an operation is 0:</p><pre class="highlight code nasm"><span class="nf">xor</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rax</span>
<span class="nf">test</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rax</span>
<span class="c1">; Because the zero flag is set here, we jump to the end</span>
<span class="nf">jz</span> <span class="nv">.end</span>
<span class="nf">mov</span> <span class="nb">rsi</span><span class="p">,</span> <span class="nb">rax</span>  <span class="c1">; not executed</span>
<span class="c1">; ...</span>
<span class="nl">.end:</span>
<span class="nf">ret</span></pre></div><div class="step step-level-1" step="21" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="2800" data-y="13000" data-z="0"><h1 id="id2">Jcc Cont'd</h1><p>A simple loop:</p><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">rcx</span><span class="p">,</span> <span class="mi">10</span>    <span class="c1">; set our loop count to 10</span>
<span class="nf">xor</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rax</span>   <span class="c1">; set rax to 0</span>
<span class="c1">; This evaluates to: 10 + 9 + 8 + ... + 1 + 0</span>
<span class="nl">.continue:</span>
    <span class="nf">add</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rcx</span>  <span class="c1">; add the current value of rcx to rax</span>
    <span class="nf">dec</span> <span class="nb">rcx</span>       <span class="c1">; subtract 1 from rcx</span>
    <span class="nf">test</span> <span class="nb">rcx</span><span class="p">,</span> <span class="nb">rcx</span> <span class="c1">; check to see if rcx is 0</span>
    <span class="nf">jnz</span> <span class="nv">.continue</span> <span class="c1">; jump back to .continue, if rcx isn't 0</span>

<span class="nf">ret</span></pre></div><div class="step step-level-1" step="22" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="300" data-y="13000" data-z="0"><h1 id="loop">loop</h1><ul><li>A simple macro for dec rcx/test rcx,rcx/jnz &lt;target&gt;</li><li>Expects ECX/RCX to be populated with a counter variable</li></ul><p>The loop from the previous slide could be re-written</p><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">rcx</span><span class="p">,</span> <span class="mi">10</span>
<span class="nf">xor</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rax</span>
<span class="nl">.continue:</span>
    <span class="nf">add</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rcx</span>
    <span class="nf">loop</span> <span class="nv">.continue</span>
<span class="nf">ret</span></pre></div><div class="step step-level-1" step="23" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="13000" data-z="0"><h1 id="lab-7">Lab 7</h1><p>Execution control flow...</p><ul><li>Copy the Lab7 folder (and its contents)</li><li>Modify the *.nasm file (Each function should have a comment block - lines starting with ';' containing instructions)</li><li>Build and run using the following commands:</li></ul><pre class="highlight code bash">~/Desktop/Lab7 $ cmake . <span class="o">&amp;&amp;</span> cmake --build .
~/Desktop/Lab7 $ ./lab7</pre></div><div class="step step-level-1" step="24" data-x="-2200" data-y="13000" data-rotate-x="90" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-z="0"><h1 id="string-instructions">String Instructions</h1><ul><li><dl><dt>What a "string" means to x86(_64)</dt><dd><ul><li>Really just a string of bytes</li><li>No particular qualms about terminators (e.g., '0')</li></ul></dd></dl></li><li>Several prefixes and a flag that will modify behavior (more on those later)</li><li>All of them have the unit to move/copy/initialize/scan appended to the end (e.g., scasb vs scasw vs scasd, etc)</li></ul></div><div class="step step-level-1" step="25" data-x="-2200" data-z="2500" data-rotate-x="90" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-y="13000"><h1 id="string-instructions-cont-d">String Instructions - Cont'd</h1><ul><li><dl><dt>Common features:</dt><dd><ul><li>RSI (or ESI, in x86) is treated as a pointer to the beginning of the "source"</li><li>RDI (or EDI, in x86) is treated as a pointer to the beginning of the "destination"</li><li>RCX (or ECX, in x86) is assumed to hold the count, if needed</li><li>RAX (or EAX, in x86) is assumed to hold the value to evaluate, if needed (e.g., store, compare against, etc)</li><li>Typically increments source and/or destination register pointers by the amount of data operated on (e.g., movsb would add 1 to both RSI and RDI, where movsd would add 4)</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="26" data-rotate-x="90" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="13000" data-z="5000"><h1 id="some-common-instructions">Some Common Instructions</h1><ul><li>Scan String - scas(b/w/d/q) - Scans a string located as RDI for the value found in RAX/EAX/AX/AL (depending on size used), and increments the pointer</li><li>Store String - stos(b/w/d/q) - Initializes the string located at RDI to the value pointer at by RAX/EAX/AX/AL (depending on size used) and increments the pointer</li><li>Load String - lods(b/w/d/q) - Copies the value from RSI into RAX/EAX/AX/AL, and increments the pointer</li><li>Move String - movs(b/w/d/q) - Copies data from RSI into RDI, and increments both pointers.</li><li>Compare String - cmps(b/w/d/q) - Compares the values stored at RSI and RDI, and increments the pointer, updating the RFLAGS (or EFLAGS) register with the result.</li></ul></div><div class="step step-level-1" step="27" data-rotate-x="90" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="13000" data-z="7500"><h1 id="prefixes">Prefixes</h1><ul><li>Several instruction prefixes available to modify behavior - looping the instruction over a section of memory</li><li>All of them tend to use RCX/ECX/etc as a termination condition - decrementing each execution</li><li><dl><dt>Some prefixes available:</dt><dd><ul><li>REP - continue performing the action RCX times.</li><li>REPNE - continue performing the action RCX times, or until the FLAGS register indicates the operands were equal.</li><li>REPE - Continue perform the action RCX times, or until the FLAGS register indicates the operands were not equal.</li></ul></dd></dl></li><li>Often used by compilers to essentially inline C string functions (such as strlen, memset, memcpy, etc)</li></ul></div><div class="step step-level-1" step="28" data-rotate-x="90" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="13000" data-z="10000"><h1 id="prefix-examples">Prefix Examples</h1><ul><li>Unconditional:</li></ul><pre class="highlight code nasm"><span class="nf">xor</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rax</span>    <span class="c1">; rax is now 0</span>
<span class="nf">mov</span> <span class="nb">rcx</span><span class="p">,</span> <span class="mi">20</span>     <span class="c1">; rcx now contains 20</span>
<span class="nf">mov</span> <span class="nb">rdi</span><span class="p">,</span> <span class="nv">_my_string_buf</span>
<span class="nf">rep</span> <span class="nv">stosb</span>       <span class="c1">; Continue to store 0 till rcx</span>
                <span class="c1">; is 0</span></pre><ul><li>Conditional:</li></ul><pre class="highlight code nasm"><span class="nf">xor</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rax</span>
<span class="nf">mov</span> <span class="nb">rcx</span><span class="p">,</span> <span class="mi">20</span>
<span class="c1">; assume the buffer below contains a string</span>
<span class="nf">mov</span> <span class="nb">rdi</span><span class="p">,</span> <span class="nv">_my_populated_buf</span>
<span class="nf">repne</span> <span class="nv">scasb</span>     <span class="c1">; continue until we hit a NULL byte</span>
<span class="c1">; RCX now contains 20 - &lt;the number of bytes we checked&gt;</span>
<span class="c1">; ...</span></pre></div><div class="step step-level-1" step="29" data-rotate-x="90" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="13000" data-z="12500"><h1 id="the-direction-flag">The Direction Flag</h1><ul><li>Controls the direction buffers are traversed when using the REP* prefixes</li><li>If set during execution/an operation, ALWAYS clear after (or crashes will likely occur)</li></ul><pre class="highlight code nasm"><span class="nf">std</span>     <span class="c1">; the direction flag has been set</span>
<span class="c1">; do stuff here</span>
<span class="nf">cld</span>     <span class="c1">; clear the direction flag, continue operations</span></pre></div><div class="step step-level-1" step="30" data-rotate-x="90" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="13000" data-z="15000"><h1 id="lab-8">Lab 8</h1><p>String Operations</p><ul><li>Copy the Lab8 folder (and its contents)</li><li>Modify the *.nasm file (Each function should have a comment block - lines starting with ';' containing instructions)</li><li>Build and run using the following commands:</li></ul><pre class="highlight code bash">~/Desktop/Lab8 $ cmake . <span class="o">&amp;&amp;</span> cmake --build .
~/Desktop/Lab8 $ ./lab8</pre></div><div class="step step-level-1" step="31" data-x="-2200" data-y="13000" data-z="15000" data-rotate-y="90" data-rotate-x="90" data-rotate-z="180" data-scale="1"><h1 id="functions">Functions</h1></div><div class="step step-level-1" step="32" data-x="-2200" data-y="10500" data-z="15000" data-rotate-x="90" data-rotate-y="90" data-rotate-z="180" data-scale="1"><h1 id="calling-conventions-x86">Calling Conventions: x86</h1><ul><li><dl><dt>Microsoft - many calling conventions exist for x86</dt><dd><ul><li>Different implications for how arguments get passed</li><li>Different implications for stack cleanup after function returns</li><li>Name mangling is often used to differentiate</li></ul></dd></dl></li><li><dl><dt>System V x86 Calling Convention</dt><dd><ul><li><dl><dt>Most POSIX-compliant (and POSIX-like) platforms abide by this</dt><dd><ul><li>Such as Linux, Solaris, BSD, OSX, etc</li><li>Also called cdecl</li></ul></dd></dl></li></ul></dd></dl></li><li>Other Calling Conventions</li></ul><div class="notes"><p>Many others exist (such as safecall or pascal) on Windows alone
Only a few will be covered here (outside of passing mention)</p></div></div><div class="step step-level-1" step="33" data-rotate-x="90" data-rotate-y="90" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="8000" data-z="15000"><h1 id="microsoft-conventions-stdcall">Microsoft Conventions: stdcall</h1><ul><li>Indicated to compiler (from C) by __stdcall prefix</li><li>Arguments pushed on the stack (in order from right to left)</li><li>The function being called (the "callee") cleans up the space allocated</li><li>Name gets decorated with an appended "@X", where X is the number of bytes to allocate (num args * 4)</li></ul></div><div class="step step-level-1" step="34" data-rotate-x="90" data-rotate-y="90" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="5500" data-z="15000"><h1 id="stdcall-cont-d">stdcall - cont'd</h1><p>Standard call in action - Stack Cleanup:</p><pre class="highlight code nasm"><span class="c1">; Equiv: void __stdcall myfunc(int a, int b);</span>
<span class="nl">_myfunc@8:</span>
    <span class="c1">; do stuff</span>
    <span class="nf">ret</span> <span class="mi">8</span>   <span class="c1">; we've cleaned up 8 bytes</span></pre><p>Optionally, we can clean up like this:</p><pre class="highlight code nasm"><span class="nl">_myfunc@4:</span>
    <span class="c1">; do stuff</span>
    <span class="nf">add</span> <span class="nb">esp</span><span class="p">,</span> <span class="mi">4</span>
    <span class="nf">ret</span></pre></div><div class="step step-level-1" step="35" data-rotate-x="90" data-rotate-y="90" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="3000" data-z="15000"><h1 id="id3">stdcall - cont'd</h1><p>Standard call in action - Accessing Parameters:</p><ul><li>If EBP hasn't been pushed to the stack:</li></ul><pre class="highlight code nasm"><span class="nl">_myfunc@8:</span>
    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">esp</span> <span class="o">+</span> <span class="mi">4</span><span class="p">]</span> <span class="c1">; parameter 1-above the return pointer</span>
    <span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="p">[</span><span class="nb">esp</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span> <span class="c1">; parameter 2-above param 1</span>
    <span class="c1">; do stuff</span>
    <span class="nf">ret</span> <span class="mi">8</span></pre><ul><li>Otherwise:</li></ul><pre class="highlight code nasm"><span class="nl">_myfunc@8:</span>
    <span class="nf">push</span> <span class="nb">ebp</span>
    <span class="nf">mov</span> <span class="nb">ebp</span><span class="p">,</span> <span class="nb">esp</span>
    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebp</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>  <span class="c1">; above both the ret ptr and old ebp</span>
    <span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebp</span> <span class="o">+</span> <span class="mi">12</span><span class="p">]</span>
    <span class="nf">pop</span> <span class="nb">ebp</span>
    <span class="nf">ret</span> <span class="mi">8</span></pre></div><div class="step step-level-1" step="36" data-rotate-x="90" data-rotate-y="90" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="500" data-z="15000"><h1 id="microsoft-conventions-cdecl">Microsoft Conventions: cdecl</h1><ul><li>This is also the System V calling convention (e.g., what most non-microsoft platforms use)</li><li>Paramters passed in the same fashion as in stdcall</li><li>Stack cleanup is different, the calling function (e.g., caller) is responsible for cleanup</li><li>No real name mangling, aside from a leading underscore "_"</li></ul></div><div class="step step-level-1" step="37" data-rotate-x="90" data-rotate-y="90" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="-2000" data-z="15000"><h1 id="cdecl-cont-d">cdecl - cont'd</h1><p>Cdecl in action: Stack cleanup</p><pre class="highlight code nasm"><span class="c1">; callee</span>
<span class="nl">_myfunc:</span>
    <span class="nf">push</span> <span class="nb">ebp</span>
    <span class="nf">mov</span> <span class="nb">ebp</span><span class="p">,</span> <span class="nb">esp</span>
    <span class="c1">; do stuff</span>
    <span class="nf">pop</span> <span class="nb">ebp</span>
    <span class="nf">ret</span>

<span class="nl">_caller:</span>
    <span class="c1">; ...</span>
    <span class="nf">push</span> <span class="mi">2</span>  <span class="c1">; arg 2</span>
    <span class="nf">push</span> <span class="mi">1</span>  <span class="c1">; arg 1</span>
    <span class="nf">call</span> <span class="nv">_myfunc</span>
    <span class="nf">add</span> <span class="nb">esp</span><span class="p">,</span> <span class="mi">8</span>  <span class="c1">; clean up</span>
    <span class="c1">; ...</span></pre></div><div class="step step-level-1" step="38" data-rotate-x="90" data-rotate-y="90" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="-4500" data-z="15000"><h1 id="microsft-conventions-fastcall">Microsft Conventions: fastcall</h1><ul><li>First two arguments (from left to right) passed via registers (ECX and EDX)</li><li>Remaining arguments pushed on the stack (right to left, as with cdecl and stdcall)</li><li>Cleanup is performed by callee (as with stdcall)</li><li>Name mangling is similar to stdcall, but an additional "@" is prepended (e.g., "_@myfunc@8")</li></ul></div><div class="step step-level-1" step="39" data-rotate-x="90" data-rotate-y="90" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="-7000" data-z="15000"><h1 id="conventions-thiscall">Conventions: thiscall</h1><ul><li>"Special" convention used for C++ non-static member functions</li><li>Defines a method of passing the "this" pointer (which allows those functions access to a specific instance of a class)</li><li>Slightly different between Microsoft and System V</li><li>Microsoft: The "this" pointer is passed in ECX, other parameters work like stdcall</li><li>System V: Works like cdecl, but the "this" pointer is the first argument to the function</li><li>C++ name mangling is a more complex topic (and somewhat compiler dependent)</li></ul></div><div class="step step-level-1" step="40" data-rotate-x="90" data-rotate-y="90" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="-9500" data-z="15000"><h1 id="x64-calling-conventions">x64 Calling Conventions</h1><ul><li>Only one convention for each (Mostly... there are still some oddballs like vectorcall, but we aren't going to dive into those)</li><li>thiscall on x64 (both conventions) passes the "this" pointer as an implicit first argument (as it does for System V x86)</li><li>Both conventions work similarly to __fastcall, passing arguments in registers (though the registers differ between platforms)</li></ul></div><div class="step step-level-1" step="41" data-rotate-x="90" data-rotate-y="90" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="-12000" data-z="15000"><h1 id="microsoft-x64-calling-convention">Microsoft x64 Calling Convention</h1><ul><li>Uses 4 registers to pass the first 4 parameters (RCX, RDX, R8, and R9)</li><li>Floating point values are passed via SIMD registers (XMM0-3... we'll talk more about this later)</li><li>Remaining values are added to the stack</li><li>Caller's responsibility to clean up (as with __cdecl)</li></ul></div><div class="step step-level-1" step="42" data-rotate-x="90" data-rotate-y="90" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="-14500" data-z="15000"><h1 id="shadow-space">Shadow Space</h1><ul><li>x64 Calling Conventions require stack allocation for passed variables</li><li>Intent is to allow function being called to immediately spill registers (if desired)</li><li>Windows ABI requires space to be allocated for 4 registers (regardless of function parameter count)</li><li><dl><dt>Additional arguments (beyond 4) are added via the stack</dt><dd><ul><li>BUT in the location they would normally occur at if all parameters were passed that way</li><li>Example: param 5 would begin at [rsp + 0x20]</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="43" data-rotate-x="90" data-rotate-y="90" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="-17000" data-z="15000"><h1 id="id4">Microsoft x64 Calling Convention</h1><p>No parameters:</p><pre class="highlight code nasm"><span class="nl">callee:</span>
    <span class="c1">; ...</span>
    <span class="nf">ret</span>

<span class="nl">caller:</span>
    <span class="nf">sub</span> <span class="nb">rsp</span><span class="p">,</span> <span class="mh">0x20</span>   <span class="c1">; 8 * 4 - for register spillage</span>
    <span class="nf">call</span> <span class="nv">callee</span>
    <span class="nf">add</span> <span class="nb">rsp</span><span class="p">,</span> <span class="mh">0x20</span>   <span class="c1">; cleanup</span></pre></div><div class="step step-level-1" step="44" data-rotate-x="90" data-rotate-y="90" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="-19500" data-z="15000"><h1 id="id5">Microsoft x64 Calling Convention</h1><p>5 Or More Parameters</p><pre class="highlight code nasm"><span class="nf">sub</span> <span class="nb">rsp</span><span class="p">,</span> <span class="mh">0x28</span>           <span class="c1">; space to store 5 params</span>
<span class="nf">mov</span> <span class="nb">rcx</span><span class="p">,</span> <span class="mh">0x41</span>           <span class="c1">; param 1 = A</span>
<span class="nf">mov</span> <span class="nb">rdx</span><span class="p">,</span> <span class="mh">0x42</span>           <span class="c1">; param 2 = B</span>
<span class="nf">mov</span> <span class="nv">r8</span><span class="p">,</span> <span class="mh">0x43</span>            <span class="c1">; param 3 = C</span>
<span class="nf">mov</span> <span class="nv">r9</span><span class="p">,</span> <span class="mh">0x44</span>            <span class="c1">; param 4 = D</span>
<span class="nf">mov</span> <span class="p">[</span><span class="nb">rsp</span> <span class="o">+</span> <span class="mh">0x20</span><span class="p">],</span> <span class="mh">0x45</span>  <span class="c1">; param 5 = E</span>
<span class="nf">call</span> <span class="nv">myfunc</span>
<span class="nf">add</span> <span class="nb">rsp</span><span class="p">,</span> <span class="mh">0x28</span>           <span class="c1">; cleanup</span></pre></div><div class="step step-level-1" step="45" data-rotate-x="90" data-rotate-y="90" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="-22000" data-z="15000"><h1 id="id6">Microsoft x64 Calling Convention</h1><p>Some additional reading on Microsoft's x64 calling convention:</p><ul><li><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040114-00/?p=41053/">https://blogs.msdn.microsoft.com/oldnewthing/20040114-00/?p=41053/</a></li></ul></div><div class="step step-level-1" step="46" data-rotate-x="90" data-rotate-y="90" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="-24500" data-z="15000"><h1 id="system-v-x64-calling-convention">System V x64 Calling Convention</h1><ul><li>Similar to the Microsoft calling convention, but more values are passed via registers</li><li>The first 6 arguments are passed via register (RDI, RSI, RCX, RDX, R8, and R9)</li><li>Floating point arguments go in SIMD registers (XMM0-7)</li><li>Additional arguments are pushed onto the stack</li><li>Shadow space is not required, but stack must remain 16-byte aligned</li><li>Red zone optimization provides free stack space for leaf functions</li></ul></div><div class="step step-level-1" step="47" data-rotate-x="90" data-rotate-y="90" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="-27000" data-z="15000"><h1 id="red-zone">Red Zone</h1><ul><li>Allows use of the next 128 bytes below RSP without modifying stack pointer</li><li><dl><dt>Further function calls WILL clobber space</dt><dd><ul><li>Because of this, Red Zone use is most suitable for leaf functions</li><li>Safe from interrupt handlers, etc.</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="48" data-rotate-x="90" data-rotate-y="90" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="-29500" data-z="15000"><h1 id="system-v-x64-example">System V x64 Example</h1><p>Calling strlen</p><pre class="highlight code nasm"><span class="k">extern</span> <span class="nv">strlen</span>

<span class="c1">; ensure NULL termination!</span>
<span class="nf">mystring</span> <span class="nv">db</span> <span class="s">"this is a string"</span><span class="p">,</span> <span class="mh">0x00</span>

<span class="nl">call_strlen:</span>
    <span class="nf">mov</span> <span class="nb">rdi</span><span class="p">,</span> <span class="nv">mystring</span>
    <span class="nf">call</span> <span class="nv">strlen</span>
    <span class="nf">ret</span></pre></div><div class="step step-level-1" step="49" data-rotate-x="90" data-rotate-y="90" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="-32000" data-z="15000"><h1 id="return-values">Return Values</h1><p>Typically, the value returned at the end of the function call will be stored in RAX (for x64), or EAX (for x86)</p></div><div class="step step-level-1" step="50" data-rotate-x="90" data-rotate-y="90" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="-34500" data-z="15000"><h1 id="register-preservation-x86">Register Preservation - x86</h1><ul><li>Volatile: EAX, ECX, and EDX don't need to be saved during a function call</li><li>All others must be preserved.</li></ul></div><div class="step step-level-1" step="51" data-rotate-x="90" data-rotate-y="90" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="-37000" data-z="15000"><h1 id="register-preservation-x64">Register Preservation - x64</h1><ul><li><dl><dt>Windows: Volatile Registers (don't need to be preserved by callee)</dt><dd><ul><li>RAX, RCX, RDX, R8, R9, R10, and R11</li><li>XMM0-3 and 5</li><li>All others need to be preserved</li></ul></dd></dl></li><li><dl><dt>System V</dt><dd><ul><li>Most registers are volatile (need to be preserved by caller if the values are to be retained)</li><li>Exception: RBP, RBX, and R12-15 are non-volatile (must be preserved)</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="52" data-rotate-x="90" data-rotate-y="90" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="-39500" data-z="15000"><h1 id="additional-links">Additional Links</h1><p>More information on both x64 calling conventions:</p><ul><li><a href="http://eli.thegreenplace.net/2011/09/06/stack-frame-layout-on-x86-64/">http://eli.thegreenplace.net/2011/09/06/stack-frame-layout-on-x86-64/</a></li></ul></div><div class="step step-level-1" step="53" data-rotate-x="90" data-rotate-y="90" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="-42000" data-z="15000"><h1 id="lab-9">Lab 9</h1><p>Functions</p><ul><li>Copy the Lab9 folder (and its contents)</li><li>Modify the *.nasm file (Each function should have a comment block - lines starting with ';' containing instructions)</li><li>Build and run using the following commands:</li></ul><pre class="highlight code bash">~/Desktop/Lab9 $ cmake . <span class="o">&amp;&amp;</span> cmake --build .
~/Desktop/Lab9 $ ./lab9</pre></div><div class="step step-level-1" step="54" data-rotate-x="90" data-rotate-y="90" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="-44500" data-z="15000"><h1 id="windows-functions-lab">Windows Functions Lab</h1><p>Functions - Calling Conventions (x86)</p><ul><li>Copy the WinFunctions folder to your Windows system</li><li>Copy the nasm binary to WinFunctions\ASM\nasm.exe</li><li>Edit WinLab.nasm under WinFunctions\ASM\ASM\WinLab.nasm</li><li>build via VS2015 (as normal), or via msbuild using the following command:</li></ul><pre class="highlight code">C:\..\WinFunctions\ASM&gt; "%VS140COMNTOOLS%vsvars32.bat"
C:\..\WinFunctions\ASM&gt; msbuild ASM.sln</pre></div><div class="step step-level-1" step="55" data-rotate-x="90" data-rotate-y="90" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="-47000" data-z="15000"><h1 id="section-review">Section Review</h1><ul><li>Flags</li><li>Jumps</li><li>Call and ret</li><li><dl><dt>string instructions</dt><dd><ul><li>prefix</li></ul></dd></dl></li><li>Functions and calling conventions</li></ul></div></div><div id="hovercraft-help"><table><tr><th>Space</th><td>Forward</td></tr><tr><th>Right, Down, Page Down</th><td>Next slide</td></tr><tr><th>Left, Up, Page Up</th><td>Previous slide</td></tr><tr><th>P</th><td>Open presenter console</td></tr><tr><th>H</th><td>Toggle this help</td></tr></table></div><script type="text/javascript" src="js/impress.js"></script><script type="text/javascript" src="js/impressConsole.js"></script><script type="text/javascript" src="js/hovercraft.js"></script></body></html><!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Introduction to Assembly</title><meta name="generator" content="Hovercraft! 1.0 http://regebro.github.com/hovercraft"></meta><link rel="stylesheet" href="css/hovercraft.css" media="all"></link><link rel="stylesheet" href="css/impressConsole.css" media="all"></link><link rel="stylesheet" href="css/highlight.css" media="all"></link><link rel="stylesheet" href="asm.css" media="screen,projection"></link></head><body class="impress-not-supported"><div id="impress" data-transition-duration="1500"><div class="step step-level-1" step="0" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><h1 id="hardware-overview">Hardware Overview</h1></div><div class="step step-level-1" step="1" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="1600" data-y="0" data-z="0"><h1 id="objectives">Objectives</h1><ul><li>Understand the different privilege modes of operation, and some of their implications</li><li>Understand basic memory segmentation and some descriptor tables</li><li>Understand, at a basic level, virtual memory</li><li>Understand basic processor features, control registers, and how they fit together</li><li>Understand and implement Model Specific Registers  (MSRs)</li><li>Utilize x86(_64) instructions to identify the current processor, and understand how to programmatically query its capabilities</li></ul></div><div class="step step-level-1" step="2" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="3200" data-y="0" data-z="0"><h1 id="processor-modes">Processor Modes</h1></div><div class="step step-level-1" step="3" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="4800" data-y="0" data-z="0"><h1 id="user-and-kernel-modes">User and Kernel modes</h1><ul><li>x86(_64) defines several modes of operation (or "rings") the processor can work in</li><li>Each mode has various instructions (and portions of memory) it is allowed to perform</li><li>User mode (which is least privileged) is Ring 3 (which is where most of your applications reside)</li><li>Kernel mode (most privileged) is Ring 0, which is where the core (or kernel) of the OS resides</li><li>Rings 1 and 2 are (largely) unused by most operatings systems</li></ul></div><div class="step step-level-1" step="4" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="6400" data-y="0" data-z="0"><h1 id="user-mode">User Mode</h1><ul><li>Mode of least privilege (Ring 3)</li><li>Cannot touch more privileged memory sections</li><li>Cannot execute "privileged" instructions</li><li>Typically must task some facility in the kernel in order to get resources</li></ul></div><div class="step step-level-1" step="5" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="8000" data-y="0" data-z="0"><h1 id="kernel-mode">Kernel Mode</h1><ul><li>Mode of most privilege (Ring 0)</li><li>Can access any portion of memory (and change protection)</li><li>Can perform privileged instructions</li><li>Device drivers often run here (in addition to the core portions of the OS)</li></ul></div><div class="step step-level-1" step="6" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="9600" data-y="0" data-z="0"><img src="./images/ring_levels.svg"></img></div><div class="step step-level-1" step="7" data-x="9600" data-y="2000" data-rotate-z="90" data-rotate-x="0" data-rotate-y="0" data-scale="1" data-z="0"><h1 id="interrupts-and-memory-segmentation">Interrupts and Memory Segmentation</h1></div><div class="step step-level-1" step="8" data-x="9600" data-y="4000" data-z="0" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1"><h1 id="tables-and-memory-segmentation">Tables and Memory Segmentation</h1><ul><li><dl><dt>Intel Specifies a number of tables, populated by the OS, which map functionality to the processor.</dt><dd><ul><li>The Interrupt Descriptor Table, or IDT</li><li>The Global Descriptor Table, or GDT</li><li>The Local Descriptor Table, or LDT</li></ul></dd></dl></li><li>Virtual memory also relies on a set of page tables</li></ul></div><div class="step step-level-1" step="9" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="9600" data-y="6000" data-z="0"><h1 id="interrupts-and-the-interrupt-descriptor-table">Interrupts and The Interrupt Descriptor Table</h1></div><div class="step step-level-1" step="10" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="9600" data-y="8000" data-z="0"><h1 id="interrupts">Interrupts</h1><ul><li><dl><dt>What are interrupts?</dt><dd><ul><li>Interrupts provide a special mechanism to alert the kernel of an event</li><li>Some (though not all) can be temporarily disabled</li><li>Specified via the IDT</li></ul></dd></dl></li><li><dl><dt>Interrupts can be generated many ways:</dt><dd><ul><li>Via hardware events (e.g., a keypress on a keyboard)</li><li>Page or segmentation faults</li><li>Software interrupts also exist</li><li>Many others</li></ul></dd></dl></li></ul><div class="notes"><p>We won't spend too much time on this particular topic (as it only loosely relates to segmentation), but it is important to understand how interrupts work (at a low level), and this will give you the foundational knowledge needed to understand what's happening under the hood later on.</p></div></div><div class="step step-level-1" step="11" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="9600" data-y="10000" data-z="0"><h1 id="interrupts-cont-d">Interrupts (Cont'd)</h1><ul><li><dl><dt>Interrupt Service Routines (ISRs)</dt><dd><ul><li>Functions that respond to interrupts</li><li>Set via Interrupt Gates in the IDT (See below)</li></ul></dd></dl></li><li><dl><dt>Interrupt Gates</dt><dd><ul><li>Essentially the entry number (in the IDT) of the ISR you want to call</li><li>The 'int' assembly instruction will call the corresponding ISR</li><li>The 'iret' instruction is provided (on the kernel side) to return back to user mode</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="12" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="9600" data-y="12000" data-z="0"><h1 id="interrupts-example">Interrupts - Example:</h1><p>The following code will perform an exit(0) on Linux (x86):</p><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="mh">0x01</span>   <span class="c1">; the system call number</span>
<span class="nf">mov</span> <span class="nb">ebx</span><span class="p">,</span> <span class="mh">0x00</span>   <span class="c1">; first parameter</span>
<span class="nf">int</span> <span class="mh">0x80</span>                <span class="c1">; interrupt</span></pre></div><div class="step step-level-1" step="13" data-x="9600" data-rotate-y="90" data-z="0" data-rotate-x="0" data-rotate-z="90" data-scale="1" data-y="14000"><h1 id="segment-registers">Segment Registers</h1><ul><li><dl><dt>Segment registers are a special type of register not covered yet, which come in a variety of flavors</dt><dd><ul><li>Each of them can be mapped to provide a special "view" of a section of memory</li><li>Most modern operating systems use a "flat" memory model, forgoing segmentation (almost) entirely</li><li>Still have some real world applications, particularly in Windows</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="14" data-rotate-x="0" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="9600" data-y="16000" data-z="0"><h1 id="id1">Segment Registers</h1><ul><li><dl><dt>The Basics:</dt><dd><ul><li>CS - Code Segment</li><li>DS - Data Segment</li><li>SS - Stack Segment</li><li>FS - Far Segment</li><li>GS - Global Segment</li></ul></dd></dl></li><li>Example: Getting a value from some offset into a segment</li></ul><pre class="highlight code nasm"><span class="c1">; Retrieves the value stored at offset</span>
<span class="c1">; 0x33 into the Global Segment</span>
<span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="p">[</span><span class="nb">gs</span><span class="p">:</span><span class="mh">0x33</span><span class="p">]</span></pre></div><div class="step step-level-1" step="15" data-x="9600" data-rotate-y="180" data-z="1000" data-rotate-x="0" data-rotate-z="90" data-scale="1" data-y="18000"><h1 id="segmentation-segments">Segmentation - Segments</h1><ul><li><dl><dt>What is a segment?</dt><dd><ul><li>Describes a logical section of memory</li><li>Specifies who can access it (e.g., what privilege level you need)</li><li>Indicates the range (start address and length)</li></ul></dd></dl></li><li><dl><dt>Why are they important?</dt><dd><ul><li>Part of the segmentation model, used to map a flat section of memory to the segment registers</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="16" data-x="9600" data-y="20000" data-z="1000" data-rotate-x="0" data-rotate-y="180" data-rotate-z="90" data-scale="1"><h1 id="segmentation">Segmentation</h1><p>The Global Descriptor Table (GDT)</p><ul><li>Initialized by the operating system</li><li>Contains various segment descriptors in its entries</li><li>The GDT Register (GDTR) indicates where it is located</li><li>Contains information about how the memory in your system gets mapped</li><li>Also (partially) defines how the transition from user to kernel mode occurs</li><li>Intended to be a global structure</li></ul></div><div class="step step-level-1" step="17" data-rotate-x="0" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="9600" data-y="22000" data-z="1000"><h1 id="id2">Segmentation</h1><p>The Local Descriptor Table (LDT)</p><ul><li>Similar to the GDT</li><li>Intended to have smaller scope: e.g., a per-process construct</li></ul></div><div class="step step-level-1" step="18" data-rotate-x="0" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="9600" data-y="24000" data-z="1000"><h1 id="segmentation-real-world-examples">Segmentation - Real World examples</h1><ul><li>Microsoft uses segmentation to provide fast access to key data structures</li><li><dl><dt>The Thread Environment Block (TEB) in user mode</dt><dd><ul><li>Hangs off of the FS register in x86/GS in x64</li><li>Provides lots of important per-thread information</li></ul></dd></dl></li><li><dl><dt>The Processor Control Block (or KPRCB) in kernel mode</dt><dd><ul><li>Hangs off of the FS register in x86/GS in x64</li><li>Provides lots of important per-processor information</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="19" data-rotate-x="0" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="9600" data-y="26000" data-z="1000"><h1 id="id3">Segmentation</h1><p>Further Reading (if interested):</p><ul><li>The OSDev Wiki describes GDT initialization - <a href="http://wiki.osdev.org/GDT_Tutorial">http://wiki.osdev.org/GDT_Tutorial</a></li><li>The Segment Descriptor Cache - Mr. Robert Collins (from a Dr. Dobbs article) - <a href="http://www.rcollins.org/ddj/Aug98/Aug98.html">http://www.rcollins.org/ddj/Aug98/Aug98.html</a></li></ul></div><div class="step step-level-1" step="20" data-rotate-x="0" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="9600" data-y="28000" data-z="1000"><h1 id="other-processor-features">Other Processor Features</h1></div><div class="step step-level-1" step="21" data-rotate-x="0" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="9600" data-y="30000" data-z="1000"><h1 id="processor-security-features">Processor Security Features</h1><ul><li>DEP/NX</li><li>SMEP/SMAP</li><li>Page Protection</li><li>Write Protection</li></ul></div><div class="step step-level-1" step="22" data-rotate-x="0" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="9600" data-y="32000" data-z="1000"><h1 id="control-registers">Control Registers</h1><ul><li>Control CPU enforcement of a variety of features</li><li>Most security features are enabled in this fashion</li><li>Requires privileged execution (Ring0) to access</li><li>Other features (such as hardware virtualization) also enabled in this fashion</li><li>Feature mappings detailed in the Intel manuals</li></ul></div><div class="step step-level-1" step="23" data-rotate-x="0" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="9600" data-y="34000" data-z="1000"><h1 id="virtual-memory">Virtual Memory</h1><ul><li>Allows a virtual abstraction of hardware addresses</li><li>Paging enabled via CR1</li><li>Page Table location stored in CR3</li><li>Tables and Directories provide fast lookup of address translations</li></ul></div><div class="step step-level-1" step="24" data-rotate-x="0" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="9600" data-y="36000" data-z="1000"><h1 id="page-tables-and-directories">Page Tables and Directories</h1><img src="./images/page_tables2.png"></img><p>Image Credit: <a href="https://notes.shichao.io/utlk/ch2/">https://notes.shichao.io/utlk/ch2/</a></p></div><div class="step step-level-1" step="25" data-rotate-x="0" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="9600" data-y="38000" data-z="1000"><h1 id="model-specific-registers-msrs">Model Specific Registers (MSRs)</h1><ul><li>Many of these exist for x86(_64)</li><li>Most only accessible in privileged mode</li><li>used (sometimes) via RDMSR and WRMSR</li><li>Others have special instructions</li><li>Mainly documented by vendor (e.g., Intel manual)</li></ul></div><div class="step step-level-1" step="26" data-rotate-x="0" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="9600" data-y="40000" data-z="1000"><h1 id="time-stamp-counter">Time Stamp Counter</h1><ul><li>Can read from user mode (via rdtsc)</li><li>Can only modify from kernel mode</li><li><dl><dt>Low bits of result are stored into EAX/high bits in EDX</dt><dd><ul><li>This is the same on both x86 and x86_x64</li><li>x64 - rdtsc will clear the high bits of storage registers</li><li>Results can be combined on x64 to full width with a left-shift and a bitwise or</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="27" data-rotate-x="0" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="9600" data-y="42000" data-z="1000"><h1 id="feature-support">Feature Support</h1><ul><li><dl><dt>The CPUID instruction can provide information about the current CPU</dt><dd><ul><li>Vender string</li><li>Model number</li><li>Size of internal cache</li><li>Various features supported</li></ul></dd></dl></li><li>The instruction behaves similarly on BOTH x86 and x86_64</li></ul></div><div class="step step-level-1" step="28" data-rotate-x="0" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="9600" data-y="44000" data-z="1000"><h1 id="feature-support-cont-d">Feature Support (Cont'd)</h1><ul><li><dl><dt>The value in EAX at the time of the CPUID call determines what information comes back</dt><dd><ul><li>0 -&gt; Vender ID String - stored in EBX/EDX/ECX</li><li>1 -&gt; Returns a bitfield containing supported features</li><li>...</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="29" data-rotate-x="0" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="9600" data-y="46000" data-z="1000"><h1 id="lab-10">Lab 10</h1><p>MSRs and CPUID</p><ul><li>Copy the Lab10 folder (and its contents)</li><li>Modify the *.nasm file (Each function should have a comment block - lines starting with ';' containing instructions)</li><li>Build and run using the following commands:</li></ul><pre class="highlight code bash">~/Desktop/Lab10 $ cmake . <span class="o">&amp;&amp;</span> cmake --build .
~/Desktop/Lab10 $ ./lab10</pre></div><div class="step step-level-1" step="30" data-rotate-x="0" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="9600" data-y="48000" data-z="1000"><h1 id="section-review">Section Review</h1><ul><li>Ring 0/3</li><li>Interrupts</li><li><dl><dt>Memory Segmentation</dt><dd><ul><li>GDT</li><li>LDT</li></ul></dd></dl></li><li>MSRs</li></ul></div></div><div id="hovercraft-help"><table><tr><th>Space</th><td>Forward</td></tr><tr><th>Right, Down, Page Down</th><td>Next slide</td></tr><tr><th>Left, Up, Page Up</th><td>Previous slide</td></tr><tr><th>P</th><td>Open presenter console</td></tr><tr><th>H</th><td>Toggle this help</td></tr></table></div><script type="text/javascript" src="js/impress.js"></script><script type="text/javascript" src="js/impressConsole.js"></script><script type="text/javascript" src="js/hovercraft.js"></script></body></html><!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Introduction to Assembly</title><meta name="generator" content="Hovercraft! 1.0 http://regebro.github.com/hovercraft"></meta><link rel="stylesheet" href="css/hovercraft.css" media="all"></link><link rel="stylesheet" href="css/impressConsole.css" media="all"></link><link rel="stylesheet" href="css/highlight.css" media="all"></link><link rel="stylesheet" href="asm.css" media="screen,projection"></link></head><body class="impress-not-supported"><div id="impress" data-transition-duration="1500"><div class="step step-level-1" step="0" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><h1 id="floating-point-and-simd">Floating Point and SIMD</h1></div><div class="step step-level-1" step="1" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="1600" data-y="0" data-z="0"><h1 id="objectives">Objectives</h1><ul><li>Understand at a basic level how floating point numbers are represented</li><li>Perform basic floating point operations</li><li>Understand and utilize the Single Instruction Multiple Data hardware to perform basic operations</li></ul></div><div class="step step-level-1" step="2" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="3200" data-y="0" data-z="0"><h1 id="x87-the-floating-point-architecture">x87 - The Floating Point Architecture</h1><img src="./images/fpu_outline.jpg"></img></div><div class="step step-level-1" step="3" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="4800" data-y="0" data-z="0"><h1 id="data-registers">Data Registers</h1><ul><li>Can contain any 32 or 64 bit data</li><li>Can't transfer directly from standard registers (e.g., EAX/RAX)</li></ul><img src="./images/fpu_data_regs.jpg"></img></div><div class="step step-level-1" step="4" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="6400" data-y="0" data-z="0"><h1 id="gdb">GDB</h1><p>Display floating point registers:</p><pre class="highlight code bash"><span class="o">(</span>gdb<span class="o">)</span> tui reg float</pre></div><div class="step step-level-1" step="5" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="8000" data-y="0" data-z="0"><h1 id="floating-point-exceptions">Floating Point Exceptions</h1><ul><li>Floating point exceptions are separate from typical interrupts</li><li>They are the only interrupts you can disable from an unprivileged operating context</li><li>The previous instruction pointer (and other contextual information) are stored via special registers</li></ul></div><div class="step step-level-1" step="6" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="9600" data-y="0" data-z="0"><h1 id="floating-point-additional-information">Floating Point - Additional Information</h1><ul><li>Floating point hardware also includes its own FLAGS register</li><li>As mentioned in the previous slide, contextual information is stored in special registers under certain circumstances</li></ul><img src="./images/fpu_outline.jpg"></img></div><div class="step step-level-1" step="7" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="11200" data-y="0" data-z="0"><h1 id="floating-point-encoding">Floating Point Encoding</h1><ul><li>Data encoding is a great deal more complicated for floating point than other types</li><li>Floating point numbers are represented via scientific notation (sort of)</li><li><dl><dt>We can store floats in one of three ways:</dt><dd><ul><li>Single Precision -&gt; which is 32 bits</li><li>Double Precision -&gt; which is 64 bits</li><li>Quad Precision -&gt; which is 128 bits</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="8" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="12800" data-y="0" data-z="0"><h1 id="floating-point-encoding-cont-d">Floating Point Encoding (cont'd)</h1><p>Four parts to the equation:</p><blockquote><ul><li>Significand (also called the mantissa) - This is the decimal representation of our number. A non-zero value will always be in the left-most position</li><li>Radix - The base to multiply by (e.g., 10)</li><li>Exponent - The power to raise the radix to</li></ul></blockquote></div><div class="step step-level-1" step="9" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="14400" data-y="0" data-z="0"><h1 id="floating-point-data-encoding">Floating Point Data Encoding</h1><ul><li>x87 Registers Show the split between different parts (under the hood)</li></ul><p>So if we have a number like 1378.5, and our hardware looks like this:</p><img src="./images/fpu_data_regs.jpg"></img><p>We have:</p><img src="./images/fpu_equation.png"></img></div><div class="step step-level-1" step="10" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="16000" data-y="0" data-z="0"><h1 id="binary-representation">Binary Representation</h1><ol><li>We take the base 2 representation of the number</li><li>We transform the number, such that it can be represented via scientific notation</li><li>The exponent is encoded using a "biased" value, which expedites compare operations</li><li>Since we know that the left-most position of the significand will always be 1, it is dropped for single precision numbers (though it is preserved in doubles).</li></ol></div><div class="step step-level-1" step="11" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="17600" data-y="0" data-z="0"><h1 id="exponent-values">Exponent Values</h1><p>Bias value added to exponent</p><img src="./images/fpu_biased_table.jpg"></img><p>e.g., an exponent of 3 (111 in binary) would get added with 127 (in the case of a single precision float), or 1111111, to get 10000110.</p></div><div class="step step-level-1" step="12" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="19200" data-y="0" data-z="0"><h1 id="special-exponent-values">Special Exponent Values</h1><ul><li><dl><dt>Some values are preserved for special cases in exponent representation</dt><dd><ul><li>00000000 (all 0s) - This value is used to encode +/- infinity</li><li>11111111 (all 1s) - This value is used to indicate NaN (Not a Number)</li></ul></dd></dl></li><li>NaN simply indicates that the floating point encoded value is not valid.</li></ul></div><div class="step step-level-1" step="13" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="20800" data-y="0" data-z="0"><h1 id="working-with-floating-point">Working with Floating Point</h1><ul><li>The floating point registers are treated like a stack</li><li>Values get pushed on (via "load" instructions) and popped off/copied (via "store" instructions)</li></ul></div><div class="step step-level-1" step="14" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="22400" data-y="0" data-z="0"><h1 id="fpu-instruction-set">FPU Instruction Set</h1><p>Basic Operations</p><ul><li><dl><dt>Loads (push)</dt><dd><ul><li>fld - Loads a floating point value from the indicated location, onto the stack</li><li>flid - Loads an integer value, encoding it as a double, onto the stack</li></ul></dd></dl></li><li><dl><dt>Stores</dt><dd><ul><li>fst - Stores the value on the top of the stack at the specified location (either memory or elsewhere in the floating point stack)</li><li>fstp - Performs the same operation as above, but also pops the value off the stack.</li><li>fist - Converts the value at the top of the stack to an integer, and stores it at the destination.</li></ul></dd></dl></li><li>Exchange: fxch - Swaps the contents of the given floating point registers</li></ul></div><div class="step step-level-1" step="15" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="24000" data-y="0" data-z="0"><h1 id="fpu-conditional-move">FPU Conditional Move</h1><p>fcmovcc - Move if: Copies the contents from the requested register in the stack to the top if the condition is satisfied</p><ul><li>b (e.g., fcmovb) - Move if below (if CF is set to 1)</li><li>nb - Move if not below (e.g., CF is 0)</li><li>e - Move if equal (e.g., ZF is 1)</li><li>ne - Move if not equal (ZF is 0)</li><li>be - Move if below or equal (CF is 1 or ZF is 1)</li><li>nbe - Move if not below or equal (CF is 0 and ZF is 0)</li></ul></div><div class="step step-level-1" step="16" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="25600" data-y="0" data-z="0"><h1 id="fpu-arithmetic-operations">FPU Arithmetic Operations</h1><ul><li>fadd/fsub/fmul - Performs the requested operation on the source and destination operands, storing the results in the destination</li><li>fiadd/fisub/fimul - Similar to above, but performs the requested operation on a floating point and integer value</li></ul></div><div class="step step-level-1" step="17" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="27200" data-y="0" data-z="0"><h1 id="lab-11">Lab 11</h1><p>Floating Point Operations</p><ul><li>Copy the Lab11 folder (and its contents)</li><li>Modify the *.nasm file (Each function should have a comment block - lines starting with ';' containing instructions)</li><li>Build and run using the following commands:</li></ul><pre class="highlight code bash">~/Desktop/Lab11 $ cmake . <span class="o">&amp;&amp;</span> cmake --build .
~/Desktop/Lab11 $ ./lab11</pre></div><div class="step step-level-1" step="18" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="28800" data-y="0" data-z="0"><h1 id="single-instruction-multiple-data-simd">Single Instruction, Multiple Data (SIMD)</h1></div><div class="step step-level-1" step="19" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="30400" data-y="0" data-z="0"><h1 id="what-is-simd">What is SIMD?</h1><ul><li>Set of specialized hardware and instructions</li><li>SSE (Streaming SIMD Extensions) is part of this (among others)</li><li>Provide a mechanism for operating on "vectors" of data at a time</li><li>Can perform a variety of operations 128 bits at a time</li></ul></div><div class="step step-level-1" step="20" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="32000" data-y="0" data-z="0"><h1 id="simd-hardware">SIMD Hardware</h1><ul><li>x86: 8 SSE registers available, from XMM0 - XMM7</li><li>x64: provides 16 SSE registers, from XMM0 - XMM15</li></ul></div><div class="step step-level-1" step="21" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="33600" data-y="0" data-z="0"><h1 id="simd-operations-moving-data">SIMD Operations - Moving Data</h1><ul><li><dl><dt>Operations typically operate on vector or scalar values</dt><dd><ul><li>Scalar - 32 bits (single element)</li><li>Vector - All elements of the SIMD register (128 bits)</li></ul></dd></dl></li><li><dl><dt>Moving data in/out:</dt><dd><ul><li>movups - Move 128 bits of data between memory and/or SIMD register(s), unaligned</li><li>movaps - Move 128 bits of data between memory and/or SIMD register(s), aligned</li><li>movhps - Move 64 bits into the high part of a SIMD register</li><li>movlps - Move 64 bits into the low part of a SIMD register</li><li>movss - Move a 32 bit value between memory and/or SIMD register(s)</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="22" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="35200" data-y="0" data-z="0"><h1 id="simd-moving-around">SIMD: Moving Around</h1><pre class="highlight code nasm"><span class="nf">movups</span> <span class="nv">xmm0</span><span class="p">,</span> <span class="p">[</span><span class="nb">rdi</span><span class="p">]</span>      <span class="c1">; moving 128 bits of data into xmm0</span>
<span class="nf">movss</span> <span class="nv">xmm1</span><span class="p">,</span> <span class="p">[</span><span class="nb">rsi</span><span class="p">]</span>       <span class="c1">; moving 32 bits of data into xmm1</span>
<span class="nf">mov</span> <span class="p">[</span><span class="nb">rdx</span><span class="p">],</span> <span class="nb">eax</span>
<span class="nf">movss</span> <span class="nv">xmm2</span><span class="p">,</span> <span class="p">[</span><span class="nb">rdx</span><span class="p">]</span></pre></div><div class="step step-level-1 instruction-table" step="23" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="36800" data-y="0" data-z="0"><h1 id="simd-arithmetic">SIMD Arithmetic</h1><p>The table below lists arithmetic instructions, both the scalar and vector variations:</p><table cellpadding="0" cellspacing="0"><tbody><tr><td><p>Vector</p></td><td><p>Scalar</p></td><td><p>Description</p></td></tr><tr><td><p>addps</p></td><td><p>addss</p></td><td><p>Adds operands</p></td></tr><tr><td><p>subps</p></td><td><p>subss</p></td><td><p>Subtracts operands</p></td></tr><tr><td><p>mulps</p></td><td><p>mulss</p></td><td><p>Multiplies operands</p></td></tr><tr><td><p>divps</p></td><td><p>divss</p></td><td><p>Divides operands</p></td></tr></tbody></table></div><div class="step step-level-1" step="24" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="38400" data-y="0" data-z="0"><h1 id="id1">SIMD Arithmetic</h1><p>Example use:</p><pre class="highlight code nasm"><span class="nf">movups</span> <span class="nv">xmm0</span><span class="p">,</span> <span class="p">[</span><span class="nb">rdi</span><span class="p">]</span>      <span class="c1">; load first vector</span>
<span class="nf">movups</span> <span class="nv">xmm1</span><span class="p">,</span> <span class="p">[</span><span class="nb">rsi</span><span class="p">]</span>      <span class="c1">; load second vector</span>
<span class="nf">addps</span> <span class="nv">xmm0</span><span class="p">,</span> <span class="nv">xmm1</span>        <span class="c1">; add the two</span>
<span class="nf">movups</span> <span class="p">[</span><span class="nb">rdx</span><span class="p">],</span> <span class="nv">xmm0</span>      <span class="c1">; store the result</span></pre></div><div class="step step-level-1" step="25" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="40000" data-y="0" data-z="0"><h1 id="simd-comparisons">SIMD Comparisons</h1><p>Comparison Operations</p><ul><li><dl><dt>cmp* operation is a bit strange at first</dt><dd><ul><li>Compares a combination of registers/memory</li><li>Stores the result in the first operand</li><li>Third param indicates the type of compare to do (next slide)</li><li>Result stored as 0 if the condition is false, -1 (all 1's) if true</li></ul></dd></dl></li><li>Min and max preserve the values that are greater (or smaller) between operands</li></ul></div><div class="step step-level-1 instruction-table" step="26" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="41600" data-y="0" data-z="0"><h1 id="id2">SIMD Comparisons</h1><p>Cmp's third parameter:</p><table cellpadding="0" cellspacing="0"><tbody><tr><td><p>Number</p></td><td><p>Operation</p></td><td><p>C Equiv</p></td></tr><tr><td><p>0</p></td><td><p>Equal</p></td><td><p>==</p></td></tr><tr><td><p>1</p></td><td><p>Less Than</p></td><td><p>&lt;</p></td></tr><tr><td><p>2</p></td><td><p>Less or equal</p></td><td><p>&lt;=</p></td></tr><tr><td><p>3</p></td><td><p>Unordered</p></td><td><p>n/a</p></td></tr><tr><td><p>4</p></td><td><p>Not Equal</p></td><td><p>!=</p></td></tr><tr><td><p>5</p></td><td><p>Not Less than</p></td><td><p>!(x &lt; y)</p></td></tr><tr><td><p>6</p></td><td><p>Not less or equal</p></td><td><p>!(x &lt;= y)</p></td></tr><tr><td><p>7</p></td><td><p>Ordered</p></td><td><p>n/a</p></td></tr></tbody></table></div><div class="step step-level-1 instruction-table" step="27" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="43200" data-y="0" data-z="0"><h1 id="id3">SIMD Comparisons</h1><p>Operations</p><table cellpadding="0" cellspacing="0"><tbody><tr><td><p>Vector</p></td><td><p>Scalar</p></td><td><p>Description</p></td></tr><tr><td><p>maxps</p></td><td><p>maxss</p></td><td><p>Obtains maximum of operands</p></td></tr><tr><td><p>minps</p></td><td><p>minss</p></td><td><p>Obtains minimum of operands</p></td></tr><tr><td><p>cmpps</p></td><td><p>cmpss</p></td><td><p>Compares operands, all 1's or
0's returned.</p></td></tr></tbody></table></div><div class="step step-level-1" step="28" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="44800" data-y="0" data-z="0"><h1 id="id4">SIMD Comparisons</h1><p>Example:</p><pre class="highlight code nasm"><span class="nf">movups</span> <span class="nv">xmm0</span><span class="p">,</span> <span class="p">[</span><span class="nb">rax</span><span class="p">]</span>
<span class="nf">movups</span> <span class="nv">xmm1</span><span class="p">,</span> <span class="p">[</span><span class="nb">rcx</span><span class="p">]</span>
<span class="nf">cmpps</span> <span class="nv">xmm0</span><span class="p">,</span> <span class="nv">xmm1</span><span class="p">,</span> <span class="mi">4</span>     <span class="c1">; find the values that are not equal</span></pre></div><div class="step step-level-1 instruction-table" step="29" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="46400" data-y="0" data-z="0"><h1 id="simd-bitwise-operations">SIMD Bitwise Operations</h1><table cellpadding="0" cellspacing="0"><tbody><tr><td><p>Vector</p></td><td><p>Description</p></td></tr><tr><td><p>andps</p></td><td><p>Bitwise and of operands</p></td></tr><tr><td><p>orps</p></td><td><p>Bitwise or of operands</p></td></tr><tr><td><p>xorps</p></td><td><p>Bitwise xor of operands</p></td></tr></tbody></table></div><div class="step step-level-1" step="30" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="48000" data-y="0" data-z="0"><h1 id="id5">GDB</h1><p>Display SIMD registers:</p><pre class="highlight code bash"><span class="o">(</span>gdb<span class="o">)</span> tui reg vector</pre></div><div class="step step-level-1" step="31" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="49600" data-y="0" data-z="0"><h1 id="lab-12">Lab 12</h1><p>SIMD</p><ul><li>Copy the Lab12 folder (and its contents)</li><li>Modify the *.nasm file (Each function should have a comment block - lines starting with ';' containing instructions)</li><li>Build and run using the following commands:</li></ul><pre class="highlight code bash">~/Desktop/Lab12 $ cmake . <span class="o">&amp;&amp;</span> cmake --build .
~/Desktop/Lab12 $ ./lab12</pre></div><div class="step step-level-1" step="32" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="51200" data-y="0" data-z="0"><h1 id="section-review">Section Review</h1><ul><li><dl><dt>Floating Point Architecture</dt><dd><ul><li>Interrupts</li><li>Register Stack</li><li>Flags</li></ul></dd></dl></li><li><dl><dt>SIMD</dt><dd><ul><li>Registers</li><li>Vectors vs Scalars</li></ul></dd></dl></li></ul></div></div><div id="hovercraft-help"><table><tr><th>Space</th><td>Forward</td></tr><tr><th>Right, Down, Page Down</th><td>Next slide</td></tr><tr><th>Left, Up, Page Up</th><td>Previous slide</td></tr><tr><th>P</th><td>Open presenter console</td></tr><tr><th>H</th><td>Toggle this help</td></tr></table></div><script type="text/javascript" src="js/impress.js"></script><script type="text/javascript" src="js/impressConsole.js"></script><script type="text/javascript" src="js/hovercraft.js"></script></body></html><!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Introduction to Assembly</title><meta name="generator" content="Hovercraft! 1.0 http://regebro.github.com/hovercraft"></meta><link rel="stylesheet" href="css/hovercraft.css" media="all"></link><link rel="stylesheet" href="css/impressConsole.css" media="all"></link><link rel="stylesheet" href="css/highlight.css" media="all"></link><link rel="stylesheet" href="asm.css" media="screen,projection"></link></head><body class="impress-not-supported"><div id="impress" data-transition-duration="1500"><div class="step step-level-1" step="0" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><h1 id="section-2">Section 2</h1><p>Practical Application</p></div><div class="step step-level-1" step="1" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="1600" data-y="0" data-z="0"><h1 id="utility-methods">Utility Methods</h1></div><div class="step step-level-1" step="2" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="3200" data-y="0" data-z="0"><h1 id="objectives">Objectives</h1><ul><li>Implement a number of basic standard library functions in assembly</li><li>Implement some essential data structures in assembly</li><li>(OPTIONAL) Complete provided bonus labs</li></ul></div><div class="step step-level-1" step="3" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="4800" data-y="0" data-z="0"><p>Assembly: A Practical Application</p><div class="notes"><p>This section of the course will be mostly hands-on, with relatively short sections of lecture, followed
by larger blocks of labs. The labs have (mostly) been staged so that there are a set of easier exercises,
followed by a section of bonus material. If you complete any of the labs early, the bonus material is
provided for you to work on. Most of the bonus sections have a C implementation provided for reference.</p></div></div><div class="step step-level-1" step="4" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="6400" data-y="0" data-z="0"><h1 id="utility-functions">Utility Functions</h1><ul><li><dl><dt>Copy and search functions (Some methods from previous labs, such as the string instruction lab, may be helpful here)</dt><dd><ul><li>strlen</li><li>memcpy</li><li>memset</li><li>memchr</li><li>memcmp</li><li>strchr</li><li>strcmp</li><li>strcpy</li><li>strstr</li></ul></dd></dl></li><li><dl><dt>Conversion</dt><dd><ul><li>atoi</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="5" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="8000" data-y="0" data-z="0"><p>atoi</p><pre class="highlight code C"><span class="kt">int</span> <span class="nf">atoi</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">long</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">accum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">if</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

        <span class="c1">// We will start from the 1's place
</span>        <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
        <span class="o">--</span><span class="n">len</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// subtract 0x30 (the difference
</span>                <span class="c1">// between the number and its
</span>                <span class="c1">// ordinal value as an ASCII character),
</span>                <span class="c1">// multiply by the step,
</span>                <span class="c1">// and add.
</span>                <span class="n">accum</span> <span class="o">+=</span> <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">len</span><span class="p">]</span> <span class="o">-</span> <span class="mh">0x30</span><span class="p">)</span> <span class="o">*</span> <span class="n">step</span><span class="p">;</span>
                <span class="o">--</span><span class="n">len</span><span class="p">;</span>
                <span class="c1">// Move up by a factor of 10.
</span>                <span class="c1">// First: 1's place, then 10's, etc.
</span>                <span class="n">step</span> <span class="o">*=</span> <span class="mi">10</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">accum</span><span class="p">;</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="6" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="9600" data-y="0" data-z="0"><h1 id="sorting-bonus-labs">Sorting (Bonus Labs)</h1><ul><li>Insertion Sort</li><li>Quicksort</li></ul></div><div class="step step-level-1" step="7" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="11200" data-y="0" data-z="0"><h1 id="lab-13-utility-functions">Lab 13 - Utility Functions</h1></div><div class="step step-level-1" step="8" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="12800" data-y="0" data-z="0"><h1 id="system-calls-an-introduction">System Calls - an Introduction</h1></div><div class="step step-level-1" step="9" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="14400" data-y="0" data-z="0"><h1 id="id1">Objectives</h1><ul><li>Understand the basic function and implementation of system calls (including legacy methods)</li><li>Understand the basic functionality provided by a C Runtime</li><li>Implement a system call wrapper in assembly</li><li>Begin work on a C Runtime</li></ul></div><div class="step step-level-1" step="10" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="16000" data-y="0" data-z="0"><h1 id="system-calls">System Calls</h1><ul><li>What they are</li><li>How they work</li></ul></div><div class="step step-level-1" step="11" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="17600" data-y="0" data-z="0"><h1 id="legacy-system-call-method">Legacy System Call Method</h1><ul><li>int 0x80/0x2e</li></ul></div><div class="step step-level-1" step="12" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="19200" data-y="0" data-z="0"><h1 id="modern-alternative">Modern Alternative</h1><ul><li>x86: sysenter / sysexit</li><li>x64: syscall</li></ul></div><div class="step step-level-1" step="13" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="20800" data-y="0" data-z="0"><h1 id="my-first-syscall">My First Syscall</h1><p>Wrapping system calls</p><ul><li>x86</li><li>x64</li></ul></div><div class="step step-level-1" step="14" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="22400" data-y="0" data-z="0"><h1 id="getting-information">Getting Information</h1><ul><li>Man pages often have a comprehensive list of required flags (even if definitions are buried in header files)</li><li>May be more than 1 section to a man page (if the page overlaps with a utility page "2" generally has dev docs)</li></ul><pre class="highlight code bash">~$ man mmap
~$ man <span class="m">2</span> open</pre></div><div class="step step-level-1" step="15" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="24000" data-y="0" data-z="0"><h1 id="c-runtimes-a-good-start">C Runtimes: A good _start</h1><ul><li>What is a runtime?</li><li>int main() vs your program's real entry point</li><li>Building without a standard library</li><li>stuff your crt usually does</li></ul></div><div class="step step-level-1" step="16" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="25600" data-y="0" data-z="0"><h1 id="compiling-with-no-crt">Compiling with no CRT</h1><ul><li>All functions will need to implemented/provided</li><li><dl><dt>Initial effort: Wrap system functionality</dt><dd><ul><li>sys_exit</li><li>write</li></ul></dd></dl></li></ul></div><div class="step step-level-1 split-table" step="17" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="27200" data-y="0" data-z="0"><h1 id="sys-exit">sys_exit</h1><table cellpadding="0" cellspacing="0"><tbody><tr><td><p>RAX</p></td><td><p>RDI</p></td></tr><tr><td><p>60</p></td><td><p>status (int)</p></td></tr></tbody></table></div><div class="step step-level-1" step="18" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="28800" data-y="0" data-z="0"><h1 id="implementing-sys-exit">Implementing sys_exit</h1><pre class="highlight code nasm">    <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">60</span>  <span class="c1">; the syscall number (in this case exit)</span>
    <span class="nf">xor</span> <span class="nb">rdi</span><span class="p">,</span> <span class="nb">rdi</span> <span class="c1">; argument 1, the exit code</span>
<span class="nf">syscall</span>
    <span class="nf">ret</span></pre></div><div class="step step-level-1 split-table" step="19" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="30400" data-y="0" data-z="0"><h1 id="some-setup">Some Setup</h1><ul><li>STDOUT - A special kind of file descriptor (1)</li><li>sys_write</li></ul><table cellpadding="0" cellspacing="0"><tbody><tr><td><p>RAX</p></td><td><p>RDI</p></td><td><p>RSI</p></td><td><p>RDX</p></td></tr><tr><td><p>1</p></td><td><p>fd</p></td><td><p>buffer ptr</p></td><td><p>Count</p></td></tr></tbody></table></div><div class="step step-level-1" step="20" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="32000" data-y="0" data-z="0"><h1 id="lab-14">Lab 14</h1><p>Finally, time for "Hello, World!"</p></div><div class="step step-level-1" step="21" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="33600" data-y="0" data-z="0"><h1 id="allocation">Allocation</h1></div><div class="step step-level-1" step="22" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="35200" data-y="0" data-z="0"><h1 id="id2">Objectives</h1><ul><li>Understand the basic roles and responsibilities of a simple allocator</li><li>Understand the function of the mmap syscall</li><li>Implement a simple allocator</li></ul></div><div class="step step-level-1" step="23" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="36800" data-y="0" data-z="0"><h1 id="allocating-memory">Allocating Memory</h1><ul><li>The Heap - no longer just a call to malloc</li><li>How do we add memory to our process?</li></ul></div><div class="step step-level-1" step="24" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="38400" data-y="0" data-z="0"><h1 id="about-allocators">About Allocators</h1><ul><li><dl><dt>Many different strategies for heap management</dt><dd><ul><li>Lots of special cases to consider</li><li>Multithreading adds more concerns (we'll talk more about this later)</li></ul></dd></dl></li><li>Our strategy here will try to remain simple</li></ul></div><div class="step step-level-1" step="25" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="40000" data-y="0" data-z="0"><h1 id="our-allocator-strategy">Our Allocator Strategy</h1><ul><li>Getting new memory from the kernel every time we need to allocate is very inefficient</li><li>We'll want to build a list of unused (or "free") chunks to hand out when allocations are requested</li><li>When a chunk is requested, we can check the free list first (if initialized), to see if we have something that will work</li><li>If not, we'll need to allocate memory</li></ul></div><div class="step step-level-1" step="26" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="41600" data-y="0" data-z="0"><h1 id="asking-for-more">Asking for More</h1><ul><li><dl><dt>We can actually ask for memory from the kernel in two ways:</dt><dd><ul><li>mmap - This is the more "modern" approach; we can ask the kernel for more memory by requesting an anonymous page mapping (we'll be discussing mmap in much greater detail over the next few sections)</li><li>brk - We won't really touch this too much; it lets you extend or shrink the end of the memory mappings in your program</li></ul></dd></dl></li><li>Some additional initialization logic can also be added to _start, if needed</li></ul></div><div class="step step-level-1 split-table" step="27" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="43200" data-y="0" data-z="0"><h1 id="mmap">mmap</h1><ul><li>Lets us create a memory mapping</li><li>May be backed by a file, or anonymous</li><li>This will be the base for our allocator</li></ul><table cellpadding="0" cellspacing="0"><tbody><tr><td><p>RAX</p></td><td><p>RDI</p></td><td><p>RSI</p></td><td><p>RDX</p></td><td><p>R10</p></td><td><p>R8</p></td><td><p>R9</p></td></tr><tr><td><p>9</p></td><td><p>addr (or NULL)</p></td><td><p>length</p></td><td><p>Protection</p></td><td><p>Flags</p></td><td><p>Descriptor (or NULL)</p></td><td><p>offset</p></td></tr></tbody></table></div><div class="step step-level-1" step="28" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="44800" data-y="0" data-z="0"><h1 id="arguments">Arguments</h1><ul><li>Protection (from mman-linux.h)</li></ul><pre class="highlight code nasm"><span class="cp">%define PROT_READ       0x1      </span><span class="c1">; Page can be read.
</span><span class="cp">%define PROT_WRITE      0x2      </span><span class="c1">; Page can be written.
</span><span class="cp">%define PROT_EXEC       0x4      </span><span class="c1">; Page can be executed.
</span><span class="cp">%define PROT_NONE       0x0      </span><span class="c1">; Page can not be accessed.</span></pre><ul><li>Flags (need to be OR'd together)</li></ul><pre class="highlight code nasm"><span class="cp">%define MAP_ANONYMOUS   0x20  </span><span class="c1">; Don't use a file.
; ...</span>
<span class="cp">%define MAP_PRIVATE             0x02  </span><span class="c1">; Changes are private.</span></pre></div><div class="step step-level-1" step="29" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="46400" data-y="0" data-z="0"><h1 id="creating-a-heap">Creating a Heap</h1><ul><li>Beginning the Process: malloc and free</li><li><dl><dt>Steps to success</dt><dd><ul><li>Initialization: Handled in _start</li><li>Making Requests: Define a "block" size</li><li>Keeping a list: Maintain a list of "free" chunks</li></ul></dd></dl></li></ul></div><div class="step step-level-1 split-table" step="30" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="48000" data-y="0" data-z="0"><h1 id="munmap">munmap</h1><table cellpadding="0" cellspacing="0"><tbody><tr><td><p>RAX</p></td><td><p>RDI</p></td><td><p>RSI</p></td></tr><tr><td><p>11</p></td><td><p>addr</p></td><td><p>length</p></td></tr></tbody></table></div><div class="step step-level-1" step="31" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="49600" data-y="0" data-z="0"><h1 id="problem-description">Problem Description</h1><p>Some pseudo-C to describe our malloc strategy:</p><p>Some initial structure information:</p><pre class="highlight code c"><span class="cm">/**
* Our free list node structure definition.
* In this case, just a simple linked list.
*/</span>
<span class="k">struct</span> <span class="n">heap_node</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">heap_node</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">heap_node</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">heap_node</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">free_list</span> <span class="p">{</span>
        <span class="n">heap_node</span><span class="o">*</span> <span class="n">head</span><span class="p">;</span>
<span class="p">}</span> <span class="n">free_list</span><span class="p">;</span>

<span class="cm">/* Add structure overhead to our alloc size */</span>
<span class="cp">#define HEAP_ALLOC_SIZE(x)      (sizeof(heap_node) + x)
</span><span class="cm">/* The beginning of our free list; head starts out NULL */</span>
<span class="n">free_list</span> <span class="n">free_start</span><span class="p">;</span></pre></div><div class="step step-level-1" step="32" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="51200" data-y="0" data-z="0"><h1 id="id3">Problem Description</h1><pre class="highlight code c"><span class="cm">/* NOTE: n is the allocation size requested */</span>
<span class="n">heap_node</span><span class="o">*</span> <span class="nf">check_free_list</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">heap_node</span><span class="o">*</span> <span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">heap_node</span><span class="o">*</span> <span class="n">current</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

        <span class="cm">/*
        * If our list is empty, we need to
        * allocate.
        */</span>
        <span class="k">if</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">free_start</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">)</span>
                <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

        <span class="n">current</span> <span class="o">=</span> <span class="n">free_start</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
                <span class="cm">/* Remove from the list */</span>
                <span class="n">free_start</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">?</span>
                                <span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="nl">next</span> <span class="p">:</span> <span class="nb">NULL</span><span class="p">;</span>
                <span class="k">return</span> <span class="n">current</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">do</span> <span class="p">{</span>
        <span class="cm">/* Walk the list, find and remove a
        * chunk of at least size n
        */</span>
        <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="33" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="52800" data-y="0" data-z="0"><h1 id="id4">Problem Description</h1><pre class="highlight code c"><span class="kt">void</span><span class="o">*</span> <span class="nf">allocate</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">heap_node</span><span class="o">*</span> <span class="n">tmp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">alloc_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="cm">/*
        * We'll check the free list first,
        * and see if there is a suitable chunk
        */</span>
        <span class="k">if</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">check_free_list</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span> <span class="p">{</span>
                <span class="cm">/* We found a match! */</span>
                <span class="k">return</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/*
        * Since we need to allocate, we have
        * to add enough to our header to
        * account for our heap_node struct!
        */</span>
        <span class="n">alloc_size</span> <span class="o">=</span> <span class="n">HEAP_ALLOC_SIZE</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="cm">/* We'll allocate some space */</span>
        <span class="k">if</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">mmap_anon_page</span><span class="p">(</span><span class="n">alloc_size</span><span class="p">)))</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
        <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="cm">/* Return the beginning of the data buffer */</span>
        <span class="k">return</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="34" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="54400" data-y="0" data-z="0"><h1 id="id5">Problem Description</h1><pre class="highlight code c"><span class="kt">void</span> <span class="nf">deallocate</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">heap_node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

        <span class="k">if</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">p</span><span class="p">)</span>
                <span class="k">return</span><span class="p">;</span>
        <span class="cm">/*
        * Subtract the size of the bookkeeping struct to get
        * back to the top of the heap_node structure in
        * memory
        */</span>
        <span class="n">node</span> <span class="o">=</span> <span class="p">(</span><span class="n">heap_node</span><span class="o">*</span><span class="p">)(((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">heap_node</span><span class="p">));</span>
        <span class="cm">/* Zero the user provided data */</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
        <span class="cm">/* Add the node to the free list */</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">free_start</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
        <span class="n">free_start</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="35" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="56000" data-y="0" data-z="0"><h1 id="additional-steps-to-consider">Additional Steps to Consider</h1><ul><li>Keep track of the number of items on the free list; release some if it becomes too large</li><li>Keep multiple free lists based on chunk size</li></ul></div><div class="step step-level-1" step="36" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="57600" data-y="0" data-z="0"><h1 id="lab-creating-an-allocator">Lab - Creating an Allocator</h1></div></div><div id="hovercraft-help"><table><tr><th>Space</th><td>Forward</td></tr><tr><th>Right, Down, Page Down</th><td>Next slide</td></tr><tr><th>Left, Up, Page Up</th><td>Previous slide</td></tr><tr><th>P</th><td>Open presenter console</td></tr><tr><th>H</th><td>Toggle this help</td></tr></table></div><script type="text/javascript" src="js/impress.js"></script><script type="text/javascript" src="js/impressConsole.js"></script><script type="text/javascript" src="js/hovercraft.js"></script></body></html><!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Introduction to Assembly</title><meta name="generator" content="Hovercraft! 1.0 http://regebro.github.com/hovercraft"></meta><link rel="stylesheet" href="css/hovercraft.css" media="all"></link><link rel="stylesheet" href="css/impressConsole.css" media="all"></link><link rel="stylesheet" href="css/highlight.css" media="all"></link><link rel="stylesheet" href="asm.css" media="screen,projection"></link></head><body class="impress-not-supported"><div id="impress" data-transition-duration="1500"><div class="step step-level-1" step="0" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><h1 id="i-o">I/O</h1></div><div class="step step-level-1" step="1" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="1600" data-y="0" data-z="0"><h1 id="objectives">Objectives</h1><ul><li>Understand and Identify basic facts about Linux files and file descriptors</li><li>Implement wrappers for several file I/O system calls</li><li>Understand and utilize file-based process bookkeeping mechanisms (via /proc)</li></ul></div><div class="step step-level-1" step="2" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="3200" data-y="0" data-z="0"><h1 id="files-and-operations">Files and Operations</h1><ul><li>UNIX Model - Everything is a file!</li><li><dl><dt>File Descriptors</dt><dd><ul><li>A bookkeeping mechanism to represent your access to a resource</li><li>Some typically reserved numbers: 0/1/2 (for std in/out/err)</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="3" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="4800" data-y="0" data-z="0"><h1 id="file-operations">File Operations</h1><ul><li>Read and Write</li><li>Open and Close (for existing files)</li><li>Unlink (for deleting)</li><li>Syncing changes - msync and fsync</li></ul></div><div class="step step-level-1" step="4" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="6400" data-y="0" data-z="0"><h1 id="process-information-and-virtual-memory">Process Information and Virtual Memory</h1></div><div class="step step-level-1" step="5" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="8000" data-y="0" data-z="0"><h1 id="mmap-a-different-use">mmap - A different use</h1><ul><li>Can be used to map a file into memory</li><li>Essentially (part of) how executables are loaded</li><li>Can be more efficient for I/O</li></ul></div><div class="step step-level-1" step="6" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="9600" data-y="0" data-z="0"><h1 id="mmap-some-new-flags">mmap - Some new flags</h1><ul><li>Required to be set to Shared for changes to appear in base file</li><li>Changes may not show up until either munmap or a call to msync</li></ul><pre class="highlight code nasm"><span class="cp">%define MAP_SHARED      0x01  </span><span class="c1">; Share changes.</span></pre></div><div class="step step-level-1" step="7" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="11200" data-y="0" data-z="0"><h1 id="id1">Process Information and Virtual Memory</h1><ul><li>/proc - a special type of directory</li><li>/proc/self</li><li>Getting to process parameters - /proc/self/cmdline</li></ul></div><div class="step step-level-1 split-table shrink-table" step="8" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="12800" data-y="0" data-z="0"><h1 id="syscall-info-pt1">Syscall Info - pt1</h1><table cellpadding="0" cellspacing="0"><tbody><tr><td><p>Syscall</p></td><td><p>RAX</p></td><td><p>RDI</p></td><td><p>RSI</p></td><td><p>RDX</p></td><td><p>R10</p></td><td><p>R8</p></td><td><p>R9</p></td></tr><tr><td><p>mmap</p></td><td><p>9</p></td><td><p>address</p></td><td><p>length</p></td><td><p>Protection</p></td><td><p>Flags</p></td><td><p>Descriptor</p></td><td><p>offset</p></td></tr><tr><td><p>munmap</p></td><td><p>11</p></td><td><p>address</p></td><td><p>length</p></td><td></td><td></td><td></td><td></td></tr><tr><td><p>read</p></td><td><p>0</p></td><td><p>Descriptor</p></td><td><p>buffer ptr</p></td><td><p>Count</p></td><td></td><td></td><td></td></tr><tr><td><p>write</p></td><td><p>1</p></td><td><p>Descriptor</p></td><td><p>buffer ptr</p></td><td><p>Count</p></td><td></td><td></td><td></td></tr><tr><td><p>open</p></td><td><p>2</p></td><td><p>filename (char*)</p></td><td><p>flags</p></td><td><p>mode</p></td><td></td><td></td><td></td></tr><tr><td><p>close</p></td><td><p>3</p></td><td><p>Descriptor</p></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><div class="step step-level-1 split-table shrink-table" step="9" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="14400" data-y="0" data-z="0"><h1 id="syscall-info-pt2">Syscall Info - pt2</h1><table cellpadding="0" cellspacing="0"><tbody><tr><td><p>Syscall</p></td><td><p>RAX</p></td><td><p>RDI</p></td><td><p>RSI</p></td><td><p>RDX</p></td><td><p>R10</p></td><td><p>R8</p></td><td><p>R9</p></td></tr><tr><td><p>unlink</p></td><td><p>87</p></td><td><p>Path (char*)</p></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><p>msync</p></td><td><p>26</p></td><td><p>address start</p></td><td><p>length</p></td><td><p>flags</p></td><td></td><td></td><td></td></tr><tr><td><p>fsync</p></td><td><p>74</p></td><td><p>Descriptor</p></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><div class="step step-level-1" step="10" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="16000" data-y="0" data-z="0"><h1 id="flags-and-modes">Flags and Modes</h1><p>Msync options</p><pre class="highlight code nasm"><span class="c1">; Flags to `msync'.</span>
<span class="cp">%define MS_ASYNC        1  </span><span class="c1">; Sync memory asynchronously.
</span><span class="cp">%define MS_SYNC         4  </span><span class="c1">; Synchronous memory sync.</span></pre><p>Open options:</p><ul><li>One of the following options must be chosen:</li></ul><pre class="highlight code nasm"><span class="cp">%define O_RDONLY           00
%define O_WRONLY           01
%define O_RDWR             02</span></pre><ul><li>Zero or more of the following may be chosen:</li></ul><pre class="highlight code nasm"><span class="cp">%define O_CREAT    0100 </span><span class="c1">; Create the file
</span><span class="cp">%define O_TRUNC   01000 </span><span class="c1">; Truncate (if exists)
</span><span class="cp">%define O_APPEND  02000 </span><span class="c1">; Append</span></pre></div><div class="step step-level-1" step="11" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="17600" data-y="0" data-z="0"><h1 id="mode">Mode</h1><ul><li>If file is being created, specifies permissions to set on it</li><li>Can be one of the following values (follow UNIX-style permission rules) specified on the next slide</li></ul></div><div class="step step-level-1 split-table shrink-table" step="12" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="19200" data-y="0" data-z="0"><table cellpadding="0" cellspacing="0"><tbody><tr><td><p>S_IRWXU</p></td><td><p>00700</p></td><td><p>user  (file  owner)  has read, write and execute
permission</p></td></tr><tr><td><p>S_IRUSR</p></td><td><p>00400</p></td><td><p>user has read permission</p></td></tr><tr><td><p>S_IWUSR</p></td><td><p>00200</p></td><td><p>user has write permission</p></td></tr><tr><td><p>S_IXUSR</p></td><td><p>00100</p></td><td><p>user has execute permission</p></td></tr><tr><td><p>S_IRWXG</p></td><td><p>00070</p></td><td><p>group has read, write and execute permission</p></td></tr><tr><td><p>S_IRGRP</p></td><td><p>00040</p></td><td><p>group has read permission</p></td></tr><tr><td><p>S_IWGRP</p></td><td><p>00020</p></td><td><p>group has write permission</p></td></tr><tr><td><p>S_IXGRP</p></td><td><p>00010</p></td><td><p>group has execute permission</p></td></tr><tr><td><p>S_IRWXO</p></td><td><p>00007</p></td><td><p>others have read, write and execute permission</p></td></tr></tbody></table></div><div class="step step-level-1" step="13" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="20800" data-y="0" data-z="0"><h1 id="lseek">Lseek</h1><ul><li>Lets you move to an offset within a file</li><li>Returns the distance (in bytes) your current offset is from the file's beginning</li></ul></div><div class="step step-level-1" step="14" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="22400" data-y="0" data-z="0"><h1 id="id2">Lseek</h1><table cellpadding="0" cellspacing="0"><tbody><tr><td><p>Syscall</p></td><td><p>RAX</p></td><td><p>RDI</p></td><td><p>RSI</p></td><td><p>RDX</p></td><td><p>R10</p></td><td><p>R8</p></td><td><p>R9</p></td></tr><tr><td><p>lseek</p></td><td><p>8</p></td><td><p>int (fd)</p></td><td><p>long offset</p></td><td><p>origin</p></td><td></td><td></td><td></td></tr></tbody></table></div><div class="step step-level-1" step="15" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="24000" data-y="0" data-z="0"><h1 id="id3">Lseek</h1><p>Values for origin (indicating where to move from):</p><pre class="highlight code nasm"><span class="cp">%define SEEK_SET        0   </span><span class="c1">; Seek from beginning of file
</span><span class="cp">%define SEEK_CUR        1   </span><span class="c1">; Seek from current position
</span><span class="cp">%define SEEK_END        2   </span><span class="c1">; Seek from the end of the file</span></pre></div><div class="step step-level-1" step="16" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="25600" data-y="0" data-z="0"><h1 id="lab-file-i-o">Lab - File I/O</h1></div><div class="step step-level-1" step="17" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="27200" data-y="0" data-z="0"><h1 id="directories">Directories</h1><ul><li>Several syscalls exist to read directories</li><li>Focus will be on getdents</li></ul></div><div class="step step-level-1" step="18" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="28800" data-y="0" data-z="0"><h1 id="getdents">Getdents</h1><table cellpadding="0" cellspacing="0"><tbody><tr><td><p>Syscall</p></td><td><p>RAX</p></td><td><p>RDI</p></td><td><p>RSI</p></td><td><p>RDX</p></td><td><p>R10</p></td><td><p>R8</p></td><td><p>R9</p></td></tr><tr><td><p>getdents</p></td><td><p>78</p></td><td><p>int (fd)</p></td><td><p>struct dirent*</p></td><td><p>buff size</p></td><td></td><td></td><td></td></tr></tbody></table></div><div class="step step-level-1" step="19" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="30400" data-y="0" data-z="0"><h1 id="misc-syscalls">Misc Syscalls</h1><ul><li>Execve - Execute a program</li><li>First arg is the binary path to run</li><li>Second is argv[]</li><li>Third is environment strings</li></ul><table cellpadding="0" cellspacing="0"><tbody><tr><td><p>Syscall</p></td><td><p>RAX</p></td><td><p>RDI</p></td><td><p>RSI</p></td><td><p>RDX</p></td><td><p>R10</p></td><td><p>R8</p></td><td><p>R9</p></td></tr><tr><td><p>execve</p></td><td><p>59</p></td><td><p>char*</p></td><td><p>char* argv[]</p></td><td><p>char* envp[]</p></td><td></td><td></td><td></td></tr></tbody></table></div><div class="step step-level-1" step="20" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="32000" data-y="0" data-z="0"><h1 id="threading">Threading</h1></div><div class="step step-level-1" step="21" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="33600" data-y="0" data-z="0"><h1 id="id4">Objectives</h1><ul><li>Understand at a basic level the Linux threading model</li><li>Understand some of the pitfalls of working with multithreaded applications</li><li>Understand and implement some of the basic synchronization tools provided by the x86(_64) instruction set</li><li>Implement a simple threading library</li></ul></div><div class="step step-level-1" step="22" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="35200" data-y="0" data-z="0"><h1 id="what-is-a-thread">What is a Thread?</h1><ul><li><dl><dt>Each thread is essentially a separate stream of execution</dt><dd><ul><li>The register values for each thread are different</li><li>This is referred to as "context"</li><li>Transitions from one thread to another is referred to as "switching context"</li></ul></dd></dl></li><li>Multiple threads may be running at the same time</li><li>It is difficult (if not impossible!) to predict how scheduling will occur</li></ul></div><div class="step step-level-1" step="23" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="36800" data-y="0" data-z="0"><h1 id="synchronization">Synchronization</h1><ul><li>Access to data needs to be synchronized (meaning: we need to make sure only one thread at a time can modify it)</li><li>Race conditions happen if multiple threads are trying to update the same data at once</li></ul></div><div class="step step-level-1" step="24" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="38400" data-y="0" data-z="0"><h1 id="safe-memory-access">Safe memory access</h1><ul><li>Think in terms of "transactions"</li><li>The lock prefix</li><li>Some instructions, such as xchg, implicitly lock</li></ul></div><div class="step step-level-1" step="25" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="40000" data-y="0" data-z="0"><h1 id="the-clone-syscall">The clone Syscall</h1><ul><li>This syscall creates a new process, but allows you to specify some amount of sharing with the parent process</li><li>Threads and processes in Linux are synonymous, but the amount of resources they share may differ</li></ul></div><div class="step step-level-1 split-table" step="26" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="41600" data-y="0" data-z="0"><h1 id="clone">Clone</h1><table cellpadding="0" cellspacing="0"><tbody><tr><td><p>Syscall</p></td><td><p>RAX</p></td><td><p>RDI</p></td><td><p>RSI</p></td><td><p>RDX</p></td><td><p>R10</p></td></tr><tr><td><p>Clone</p></td><td><p>56</p></td><td><p>Clone flags</p></td><td><p>Stack Pointer</p></td><td><p>parent tid</p></td><td><p>child tid</p></td></tr></tbody></table></div><div class="step step-level-1" step="27" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="43200" data-y="0" data-z="0"><h1 id="flags">Flags</h1><p>Some flags we'll want for our thread library:</p><pre class="highlight code nasm"><span class="cp">%define CLONE_VM      0x00000100 </span><span class="c1">; VM shared between procs.
</span><span class="cp">%define CLONE_FS      0x00000200 </span><span class="c1">; fs info shared
</span><span class="cp">%define CLONE_FILES   0x00000400 </span><span class="c1">; open files shared
</span><span class="cp">%define CLONE_SIGHAND 0x00000800 </span><span class="c1">; signal handlers shared.
</span><span class="cp">%define CLONE_THREAD  0x00010000 </span><span class="c1">; add to same thread group.</span></pre></div><div class="step step-level-1" step="28" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="44800" data-y="0" data-z="0"><h1 id="basic-steps-to-success">Basic Steps to Success</h1><ol><li>Allocate Stack Space</li><li>Call Clone</li><li>Transfer Control to Intended function</li><li>Block main thread until children are done</li></ol></div><div class="step step-level-1" step="29" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="46400" data-y="0" data-z="0"><h1 id="allocating-stack-space">Allocating Stack Space</h1><ul><li>The stack grows down, and thus we need to give the high part of the new stack segment to clone</li><li>mmap is the best choice to do this, as it has flags that let us specify that we wish to use the allocated memory as a thread stack:</li></ul><pre class="highlight code nasm"><span class="cp">%define MAP_GROWSDOWN   0x0100</span></pre></div><div class="step step-level-1" step="30" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="48000" data-y="0" data-z="0"><h1 id="calling-clone">Calling Clone</h1><ul><li>As seen above, clone has several arguments</li><li>For our purposes, only two are really useful: the flags argument (RDI), and a pointer to our new stack</li><li>We'll need to get to the end of the new stack:</li></ul><pre class="highlight code nasm"><span class="c1">; assuming rsi contains a pointer to</span>
<span class="c1">; our newly allocated stack segment</span>
<span class="nf">lea</span> <span class="nb">rsi</span><span class="p">,</span> <span class="p">[</span><span class="nb">rsi</span> <span class="o">+</span> <span class="nv">STACK_SIZE</span><span class="p">]</span></pre></div><div class="step step-level-1" step="31" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="49600" data-y="0" data-z="0"><h1 id="calling-clone-cont-d">Calling Clone (cont'd)</h1><ul><li>After clone, both the parent and child continue executing in the same place (right after the syscall)</li><li><dl><dt>The child (our newly created thread) will have the same initial register values as the parent, with two exceptions:</dt><dd><ul><li>RAX - this will be set to 0</li><li>RSP - this will now point to our new stack</li></ul></dd></dl></li><li>The parent will now have (in RAX) the PID of the thread</li></ul></div><div class="step step-level-1" step="32" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="51200" data-y="0" data-z="0"><h1 id="running-the-thread-function">Running the Thread Function</h1><ul><li><dl><dt>A number of options exist to transfer control to the new function</dt><dd><ul><li>Pass via non-volatile register</li><li>Pass via stack</li></ul></dd></dl></li><li>If any thread-specific setup is to be done, just need to:</li></ul><pre class="highlight code nasm"><span class="nf">test</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rax</span>
<span class="nf">jz</span> <span class="nv">.child</span>
<span class="nf">jmp</span> <span class="nv">.parent</span></pre><ul><li>easiest method of control transfer is probably passing via the new stack</li></ul></div><div class="step step-level-1" step="33" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="52800" data-y="0" data-z="0"><h1 id="running-the-thread-function-cont-d">Running the Thread Function (cont'd)</h1><ul><li>Recall from our section on control flow that the ret instruction essentially performs "pop rip" (or pop X + jmp X)</li><li>Thus, we can now set our stack up so that the new thread function will be our return point (we'll just change the way our stack looks before the call to clone):</li></ul><p>Now, instead of:</p><pre class="highlight code nasm"><span class="nf">lea</span> <span class="nb">rsi</span><span class="p">,</span> <span class="p">[</span><span class="nb">rsi</span> <span class="o">+</span> <span class="nv">STACK_SIZE</span><span class="p">]</span>
<span class="c1">; ...</span>
<span class="nf">syscall</span></pre><p>we will:</p><pre class="highlight code nasm"><span class="nf">lea</span> <span class="nb">rsi</span><span class="p">,</span> <span class="p">[</span><span class="nb">rsi</span> <span class="o">+</span> <span class="nv">STACK_SIZE</span> <span class="o">-</span> <span class="mi">8</span><span class="p">]</span>
<span class="nf">mov</span> <span class="p">[</span><span class="nb">rsi</span><span class="p">],</span> <span class="nb">rdi</span>  <span class="c1">; our function pointer</span>
<span class="c1">; ...</span>
<span class="nf">syscall</span>
<span class="c1">; ...</span>
<span class="nf">ret</span></pre></div><div class="step step-level-1" step="34" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="54400" data-y="0" data-z="0"><h1 id="id5">Running the Thread Function (cont'd)</h1><ul><li>With our function set to be at the top of the new stack, we can now simply return</li><li>On return, our new thread will begin executing inside of the thread function</li><li><dl><dt>This works wonderfully, BUT</dt><dd><ul><li>What happens when the thread function returns?</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="35" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="56000" data-y="0" data-z="0"><h1 id="exit">Exit</h1><ul><li>We need to ensure that we call exit after execution completes</li><li>Since we are at the top of the stack to begin with, there is no place to go</li><li>The easy solution:</li></ul><pre class="highlight code nasm">        <span class="nf">lea</span> <span class="nb">rsi</span><span class="p">,</span> <span class="p">[</span><span class="nb">rsi</span> <span class="o">+</span> <span class="nv">STACK_SIZE</span> <span class="o">-</span> <span class="mi">8</span><span class="p">]</span>
        <span class="nf">mov</span> <span class="p">[</span><span class="nb">rsi</span><span class="p">],</span> <span class="nb">rdi</span>  <span class="c1">; our function pointer</span>
        <span class="c1">; ...</span>
        <span class="nf">syscall</span>
        <span class="nf">test</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rax</span> <span class="c1">; check to see if we are parent/child</span>
        <span class="nf">jnz</span> <span class="nv">.parent</span>     <span class="c1">; jump to end if we are the parent</span>
        <span class="nf">pop</span> <span class="nb">rax</span> <span class="c1">; pop the function pointer (top of stack)</span>
        <span class="nf">call</span> <span class="nb">rax</span>        <span class="c1">; call our thread function!</span>
        <span class="c1">; ...</span>
        <span class="nf">call</span> <span class="nv">exit</span>       <span class="c1">; call exit (no place to return)</span>
<span class="nl">.parent:</span>
        <span class="c1">; ...           ; parent: cleanup/return</span>
        <span class="nf">ret</span></pre></div><div class="step step-level-1" step="36" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="57600" data-y="0" data-z="0"><h1 id="a-better-exit-strategy">A Better Exit Strategy</h1><ul><li>We can take the previous code a step further, and add another return address to the stack</li><li>If we put exit first, we will still be able to transfer control in the same fashion, but don't need to wrap out child function with additional calls</li></ul><pre class="highlight code nasm"><span class="nf">lea</span> <span class="nb">rsi</span><span class="p">,</span> <span class="p">[</span><span class="nb">rsi</span> <span class="o">+</span> <span class="nv">STACK_SIZE</span> <span class="o">-</span> <span class="mi">8</span><span class="p">]</span>
<span class="nf">mov</span> <span class="p">[</span><span class="nb">rsi</span><span class="p">],</span> <span class="nv">exit</span>         <span class="c1">; our exit function</span>
<span class="nf">sub</span> <span class="nb">rsi</span><span class="p">,</span> <span class="mi">8</span>                      <span class="c1">; go back just a bit</span>
<span class="nf">mov</span> <span class="p">[</span><span class="nb">rsi</span><span class="p">],</span> <span class="nb">rdi</span>          <span class="c1">; now our function pointer</span>
<span class="c1">; ...</span>
<span class="nf">syscall</span>
<span class="c1">; ...</span>
<span class="nf">ret</span></pre></div><div class="step step-level-1" step="37" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="59200" data-y="0" data-z="0"><h1 id="waiting-till-done">Waiting till done</h1><ul><li>Since all of the threads are part of the same thread group, can't wait() for them</li><li><dl><dt>Alternate strategy is to "pause"</dt><dd><ul><li>Will block us until a signal of some sort happens (such as all child threads exiting)</li><li>Syscall takes no arguments</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="38" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="60800" data-y="0" data-z="0"><h1 id="pause">Pause</h1><table cellpadding="0" cellspacing="0"><tbody><tr><td><p>Syscall</p></td><td><p>RAX</p></td><td><p>RDI</p></td><td><p>RSI</p></td><td><p>RDX</p></td><td><p>R10</p></td></tr><tr><td><p>Pause</p></td><td><p>34</p></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><div class="step step-level-1" step="39" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="62400" data-y="0" data-z="0"><h1 id="race-conditions">Race Conditions</h1><ul><li>Can occur when multiple threads access data at once, where the data is being modified</li><li>Can be rather difficult to spot at first</li><li><dl><dt>Multiple strategies exist to mitigate</dt><dd><ul><li>Locks</li><li>Atomic Instructions</li></ul></dd></dl></li><li>Can be difficult to get absolutely correct</li></ul><div class="notes"><p>Think in terms of a busy intersection with no stop sign.</p></div></div><div class="step step-level-1" step="40" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="64000" data-y="0" data-z="0"><h1 id="what-do-race-conditions-look-like">What do Race Conditions look like?</h1><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rdi</span><span class="p">]</span> <span class="c1">; we load our data</span>
<span class="c1">; but by the time we reach here,</span>
<span class="c1">; any number of things could have</span>
<span class="c1">; happened to the value in the pointer</span>
<span class="nf">test</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rax</span>
<span class="nf">jz</span> <span class="nv">.bad_stuff</span></pre></div><div class="step step-level-1" step="41" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="65600" data-y="0" data-z="0"><h1 id="more-problems">More Problems</h1><ul><li>Deadlocks</li><li>Starvation</li><li>Recursive locking</li><li>And much, much, more!</li></ul></div><div class="step step-level-1" step="42" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="67200" data-y="0" data-z="0"><h1 id="making-atomic-adds-and-comparisons">Making Atomic adds and Comparisons</h1><pre class="highlight code nasm"><span class="nf">lock</span> <span class="nv">xadd</span>               <span class="c1">; exchange and add</span>
<span class="nf">lock</span> <span class="nv">bts</span>                <span class="c1">; bit test and set</span>
<span class="nf">lock</span> <span class="nv">btr</span>                <span class="c1">; bit test and clear</span>
<span class="nf">lock</span> <span class="nv">cmpxchg</span>    <span class="c1">; compare and swap</span>
<span class="nf">xchg</span>                    <span class="c1">; implicitly locks</span></pre></div><div class="step step-level-1" step="43" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="68800" data-y="0" data-z="0"><h1 id="xadd">XADD</h1><h2 id="description">Description</h2><p>Exchanges the values in its two operands, adds them together, and stores the result into the first operand. Can be used with the lock prefix.</p><pre class="highlight code nasm"><span class="nf">xadd</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rdx</span>
<span class="c1">; rdi contains: a pointer to "20", rax contains: 10</span>
<span class="nf">lock</span> <span class="nv">xadd</span> <span class="p">[</span><span class="nb">rdi</span><span class="p">],</span> <span class="nb">rax</span> <span class="c1">; rdi now contains a pointer to "30"</span></pre></div><div class="step step-level-1" step="44" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="70400" data-y="0" data-z="0"><h1 id="bit-test-and-set-bit-test-and-clear">Bit Test and Set, Bit Test and Clear</h1><h2 id="id6">Description</h2><p>Tests and sets the selected bit in memory, sets the carry bit to indicate the previous value. Bit test and clear resets the bit to 0, setting the carry bit to indicate the previous value.</p><pre class="highlight code nasm"><span class="nf">lock</span> <span class="nv">bts</span> <span class="kt">dword</span> <span class="p">[</span><span class="nb">rdi</span><span class="p">],</span> <span class="mi">0</span>
<span class="nf">jc</span> <span class="nv">.was_set</span>
<span class="c1">; ...</span>
<span class="nf">lock</span> <span class="nv">btr</span> <span class="kt">dword</span> <span class="p">[</span><span class="nb">rdi</span><span class="p">],</span> <span class="mi">0</span>
<span class="nf">jc</span> <span class="nv">.was_set</span></pre></div><div class="step step-level-1" step="45" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="72000" data-y="0" data-z="0"><h1 id="compare-and-swap">Compare and Swap</h1><h2 id="id7">Description</h2><p>Compares the first operand to the value in RAX/EAX/AX/AL, if they are equal, copies the second operand into the destination, and sets the zero flag (ZF). Otherwise, it leaves the destination alone, and clears the zero flag.</p><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rdi</span><span class="p">]</span>
<span class="nf">lock</span> <span class="nv">cmpxchg</span> <span class="p">[</span><span class="nb">rdi</span><span class="p">],</span> <span class="mi">1</span>
<span class="nf">jnz</span> <span class="nv">.not_replaced</span></pre></div><div class="step step-level-1" step="46" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="73600" data-y="0" data-z="0"><h1 id="creating-a-simple-spinlock">Creating a Simple Spinlock</h1><pre class="highlight code nasm"><span class="nl">lock_func:</span>
        <span class="c1">; ...</span>
        <span class="nf">lock</span> <span class="nv">bts</span> <span class="p">[</span><span class="nb">rdi</span><span class="p">],</span> <span class="mi">0</span>
        <span class="nf">jc</span> <span class="nv">.done</span>
        <span class="nf">jmp</span> <span class="nv">lock_func</span>
        <span class="c1">; ...</span>
<span class="nl">.done:</span>
        <span class="nf">ret</span>

<span class="nl">unlock_func:</span>
        <span class="c1">; ...</span>
        <span class="nf">lock</span> <span class="nv">btr</span> <span class="p">[</span><span class="nb">rdi</span><span class="p">],</span> <span class="mi">0</span>
        <span class="c1">; ...</span></pre></div><div class="step step-level-1" step="47" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="75200" data-y="0" data-z="0"><h1 id="lab-and-demo-threading-and-synchronization">Lab and Demo - Threading and Synchronization</h1></div><div class="step step-level-1" step="48" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="76800" data-y="0" data-z="0"><h1 id="review">Review</h1></div></div><div id="hovercraft-help"><table><tr><th>Space</th><td>Forward</td></tr><tr><th>Right, Down, Page Down</th><td>Next slide</td></tr><tr><th>Left, Up, Page Up</th><td>Previous slide</td></tr><tr><th>P</th><td>Open presenter console</td></tr><tr><th>H</th><td>Toggle this help</td></tr></table></div><script type="text/javascript" src="js/impress.js"></script><script type="text/javascript" src="js/impressConsole.js"></script><script type="text/javascript" src="js/hovercraft.js"></script></body></html>
